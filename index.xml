<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>L0phTg&#39;s Blog</title>
    <link>https://l0phtg.github.io/</link>
    <description>Recent content on L0phTg&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>l0phtg</copyright>
    <lastBuildDate>Mon, 20 Aug 2018 21:38:52 +0800</lastBuildDate>
    
        <atom:link href="https://l0phtg.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://l0phtg.github.io/about/</link>
      <pubDate>Mon, 20 Aug 2018 21:38:52 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/about/</guid>
      
        <description>&lt;p&gt;某邮电大学大四学生, 宅男一枚, 整日与电脑为生.&lt;/p&gt;

&lt;p&gt;从事方向: 移动安全.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>装机日志-deepin</title>
      <link>https://l0phtg.github.io/post/%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97-deepin/</link>
      <pubDate>Thu, 28 Dec 2017 11:47:58 +0000</pubDate>
      
      <guid>https://l0phtg.github.io/post/%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97-deepin/</guid>
      
        <description>&lt;p&gt;17年使用了一段时间deepin系统, 这里简单记录一些使用心得(现在已转ubuntu.&lt;/p&gt;

&lt;p&gt;主要就是&lt;strong&gt;装机的过程&lt;/strong&gt;, 以及&lt;strong&gt;装机后的效果展示&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;最近一直在码代码和写.md, 深刻体会到在windows上办公有多么艰难. 安装了一下&lt;code&gt;spacevim/neovim&lt;/code&gt;后, 意识到了高效率的办公会给人带来很大的乐趣. 所以, 在遇到了很多与环境配置相关的问题(却解决不了之后), 毅然决定更换系统.&lt;/p&gt;

&lt;h2 id=&#34;选择&#34;&gt;选择&lt;/h2&gt;

&lt;p&gt;犹豫了一天到底是该装&lt;code&gt;Ubuntu16.04&lt;/code&gt;还是&lt;code&gt;deepin&lt;/code&gt;(&lt;code&gt;导致上课前, 忘了给舍友刷卡...&lt;/code&gt;).最终还是经不住deepin&lt;code&gt;绚丽的UI设计&lt;/code&gt;的诱惑, 决定尝试一下&lt;code&gt;deepin&lt;/code&gt;.(&lt;strong&gt;没错, 颜值在我心中就是这么重要&lt;/strong&gt;)&lt;/p&gt;

&lt;h2 id=&#34;装机过程&#34;&gt;装机过程&lt;/h2&gt;

&lt;p&gt;装机过程很简单, 下载好官方的镜像源, 之后检验一下&lt;strong&gt;md5&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$checksum  

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后用&lt;strong&gt;官方的启动盘制作工具&lt;/strong&gt;把U盘装入deepin, 重启时插入U盘, 设置为U盘启动就可以了.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重点来了&lt;/strong&gt;, 因为我不想用windows10了, 所以直接把系统装在c盘中, 因为原来的系统有&lt;strong&gt;3个分区, 所以装机时不用格式化 D 盘 和 E 盘&lt;/strong&gt;(&lt;code&gt;我的E盘有7/8个虚拟机文件, 在装好deepin后, 依然可以正常使用&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;装机总结:
- deepin系统装入c盘.&lt;br /&gt;
- D盘, E盘可以不用格式化.(当然, 如果电脑里没啥重要文件的, skip it)&lt;/p&gt;

&lt;h2 id=&#34;下来就是激动人心的时刻了&#34;&gt;下来就是激动人心的时刻了&lt;/h2&gt;

&lt;p&gt;先放几张图:&lt;/p&gt;

&lt;p&gt;桌面
{% asset_img desktop.png 桌面%}&lt;/p&gt;

&lt;p&gt;分屏
{% asset_img splitScreen.png 分屏 %}&lt;/p&gt;

&lt;p&gt;我们最爱的vim
{% asset_img vimMarkdownPreview.png vimMarkdown %}&lt;/p&gt;

&lt;p&gt;当然, 还有很多其它的不错的设计, 这里就不多放图了.&lt;/p&gt;

&lt;h3 id=&#34;配置nvim-spacevim&#34;&gt;配置nvim/spacevim&lt;/h3&gt;

&lt;p&gt;依赖项:
- python支持: 建议先&lt;code&gt;pip install neovim&lt;/code&gt;和&lt;code&gt;pip3 install neovim&lt;/code&gt;.
- font支持: (读者可以自行查看readme进行安装) git地址: &lt;code&gt;https://github.com/powerline/fonts.git&lt;/code&gt; , 用来更好的显示vim界面(字体, 状态栏&amp;hellip;).
- tagbar支持: 安装 &lt;code&gt;ctags&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt install ctags
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;安装&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;neovim安装: &lt;code&gt;sudo apt install neovim&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Spacevim安装: (读者可以自行查看readme进行安装) git地址: &lt;code&gt;https://github.com/SpaceVim/SpaceVim&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;init.nvim(来, 放出我们的口号: &lt;strong&gt;打造属于自己的编辑器&lt;/strong&gt;, 这个文件是用户配置文件, 读者可以自行配置)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我这里只是对自己的需求进行了简单的配置:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;配置markdown预览:(因为它默认预览采用的插件是&lt;code&gt;iamcoo/MarkdownPreview.vim&lt;/code&gt;, 所以根据该插件作者的说明进行配置)&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;默认预览浏览器为&lt;code&gt;google-chrome&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let g:mkdp_path_to_chrome = &#39;google-chrome&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;映射预览为&lt;code&gt;F4&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nmap &amp;lt;silent&amp;gt; &amp;lt;F4&amp;gt; &amp;lt;Plug&amp;gt;MarkdownPreview        &amp;quot; for normal mode
imap &amp;lt;silent&amp;gt; &amp;lt;F4&amp;gt; &amp;lt;Plug&amp;gt;MarkdownPreview        &amp;quot; for insert mode
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;设置状态栏分隔符为箭头:
&lt;code&gt;
let g:spacevim_statusline_separator = &#39;arrow&#39;
&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;配置zsh-oh-my-zsh&#34;&gt;配置zsh/oh-my-zsh&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装zsh&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt install zsh
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安装oh-my-zsh&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;sh -c &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体的配置看个人喜好.&lt;/p&gt;

&lt;h3 id=&#34;安装tools&#34;&gt;安装tools&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/PikachuHy/..&#34;&gt;https://github.com/PikachuHy/..&lt;/a&gt;.       &lt;code&gt;一位大佬写的net工具,  大家懂得&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;总之, &lt;code&gt;deepin&lt;/code&gt;还是带给我很大的惊喜的.  &lt;code&gt;deepin终端&lt;/code&gt;, &lt;code&gt;深度截图&lt;/code&gt;, 还可以愉快的使用网络, 开心的在linux下办公hahahahaha.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>thumb指令虚拟化学习(一)</title>
      <link>https://l0phtg.github.io/post/thumb%E6%8C%87%E4%BB%A4%E8%99%9A%E6%8B%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B8%80/</link>
      <pubDate>Tue, 24 Oct 2017 20:23:30 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/thumb%E6%8C%87%E4%BB%A4%E8%99%9A%E6%8B%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B8%80/</guid>
      
        <description>&lt;p&gt;上半年接触过一些 &lt;strong&gt;app加固&lt;/strong&gt; 的知识, 对 &lt;strong&gt;vm&lt;/strong&gt; 这块一直空有兴趣而没有了解过;  最近, 阅读了几篇文章, &lt;code&gt;有所启发&lt;/code&gt;, 所以决定学习一下 &lt;strong&gt;vm&lt;/strong&gt; 这块的一些操作.&lt;/p&gt;

&lt;p&gt;主要内容分为:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;环境搭建&lt;/li&gt;
&lt;li&gt;提取指令&lt;/li&gt;
&lt;li&gt;capstone处理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;阅读资料&#34;&gt;阅读资料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/knownsec/KCon/blob/master/2017/%5BKCon%202017%5D0827_3_%E9%99%88%E6%84%89%E9%91%AB_%E7%AC%AC%E4%BA%94%E4%BB%A3%E5%8A%A0%E5%9B%BA%E6%8A%80%E6%9C%AFARM%20VMP%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%BA%94%E7%94%A8.pdf&#34;&gt;Kcon2017 第五代加固技术ARM VMP原理与应用&lt;/a&gt;
&lt;a href=&#34;http://www.cnblogs.com/2014asm/p/6534897.html&#34;&gt;ARM平台指令虚拟化探索&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;环境搭建&#34;&gt;环境搭建:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;需要安装python的capstone模块, 可以直接使用pip安装. (另外: &lt;strong&gt;强烈建议下载capstone源码, 以便随时阅读&lt;/strong&gt;.)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
    sudo apt install libcapstone3
    sudo apt install libcapstone-dev
    pip install capstone

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ida/radare2 &lt;code&gt;在本节中, 提取指令的时候会用到&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;arm官方文档(&lt;a href=&#34;https://yurichev.com/mirrors/ARMv8-A_Architecture_Reference_Manual_(Issue_A.a).pdf&#34;&gt;https://yurichev.com/mirrors/ARMv8-A_Architecture_Reference_Manual_(Issue_A.a).pdf&lt;/a&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;本篇文章大致分为如下几个部分&#34;&gt;本篇文章大致分为如下几个部分:&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;手动提取编译好的可执行文件中的 &lt;strong&gt;你想要加密的函数&lt;/strong&gt;, 并转换为 &lt;strong&gt;16进制的格式&lt;/strong&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;初步了解 &lt;strong&gt;capstone&lt;/strong&gt; 中的 &lt;strong&gt;对Arm指令进行处理的操作函数&lt;/strong&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;了解 &lt;strong&gt;thumb指令编码&lt;/strong&gt; , &lt;code&gt;此处研究thumb的原因是: 在提出函数的bytes时, 发现自定义的函数, 都被转换成了thumb指令的格式, 所以笔者先研究thumb;  当然, 要知道, thumb并不是独立于arm存在的, thumb的存在是为了提高效率&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;设计自己的一套 &lt;strong&gt;指令集&lt;/strong&gt; , &lt;code&gt;很简单的一套指令集, 能模拟常见的thumb指令, 例如 push, pop, str, ldr, add, sub, mov, cmp, blx ...&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;写代码, &lt;code&gt;此处参考了capstone源码中的/bindings/python/capstone/* 中的有关代码, 初学py, 代码写的差, 有什么建议还请多多交流)&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;提取指令&#34;&gt;提取指令.&lt;/h3&gt;

&lt;p&gt;我们提取的是下面程序中的 &lt;strong&gt;judge&lt;/strong&gt; 函数.&lt;/p&gt;

&lt;h4 id=&#34;用ida提取&#34;&gt;用ida提取:&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;我们将会在这篇文章中用到的程序:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

char key[16] = {&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;q&#39;, &#39;r&#39;, &#39;c&#39;, &#39;o&#39;, &#39;b&#39;, &#39;g&#39;, &#39;s&#39;, &#39;k&#39;};

int judge(const char *s)
{
    int ret = 1;
    char c[16] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;q&#39;, &#39;s&#39;, &#39;e&#39;, &#39;r&#39;, &#39;b&#39;, &#39;h&#39;, &#39;u&#39;, &#39;n&#39;};
    int i;
    for (i = 0; i &amp;lt; 16; i++)
    {
        switch(i % 4)   
        {
        case 0: 
            if (s[i]  == c[i])
                continue;
            break;  
        case 1:
            if (s[i] + 1 == c[i])
                continue;
            break;
        case 2:
            if (s[i] + 2 == c[i])
                continue;
            break;
        case 3:
            if (s[i] + 3 == c[i])
                continue; 
            break;
        } 
        ret = 0; 
    }
    return ret;
}

int main(int argc, char *argv[])
{
    printf(&amp;quot;hello World\n&amp;quot;);
    char a[16];
    scanf(&amp;quot;%s&amp;quot;, a);

    if (judge(a) == 1)
        printf(&amp;quot;ok&amp;quot;);
    else
        printf(&amp;quot;error&amp;quot;);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;用ndk-build编译成armv7a可执行程序后, 放入ida中, 用idc脚本提::&lt;/p&gt;

&lt;p&gt;idc脚本, start为judge函数的起始地址, end为judge函数的结束地址.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;idc.idc&amp;gt;

static main() {
    auto start, end, fd, i, inst;
    fd = fopen(&amp;quot;D:\\idaResult\\armOpcodeByte.txt&amp;quot;, &amp;quot;wt+&amp;quot;);
    start = 0x863c;
    end = 0x86BA;
    
    for(i = start; i &amp;lt; end; i++) {
        inst = Byte(i);
        fprintf(fd, &amp;quot;\\x%02x&amp;quot;, inst);
    }
    fclose(fd);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提取出来后的结果:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;\x1f\x49\xf0\xb5\x79\x44\x09\x68\x87\xb0\x07\x46\x0b\x68\x01\xaa\x0d\x46\x16\x46\x05\x93\x1b\x4b\x7b\x44\x03\xf1\x10\x0e\x18\x68\x08\x33\x53\xf8\x04\x1c\x73\x45\x14\x46\x03\xc4\x22\x46\xf6\xd1\x3a\x46\x00\x23\x01\x20\x03\xf0\x03\x01\x02\x29\x09\xd0\x03\x29\x0a\xd0\x01\x29\x02\xd0\x14\x78\xf1\x5c\x08\xe0\x11\x78\x01\x31\x04\xe0\x11\x78\x02\x31\x01\xe0\x11\x78\x03\x31\xf4\x5c\x01\x33\xa1\x42\x18\xbf\x00\x20\x10\x2b\x02\xf1\x01\x02\xe3\xd1\x05\x9a\x2b\x68\x9a\x42\x01\xd0\xff\xf7\x0a\xef\x07\xb0\xf0\xbd
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;用radare2提取&#34;&gt;用radare2提取&lt;/h4&gt;

&lt;p&gt;(才发现原来radare2 v2.0都已经发布了)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;对r2语法不做讲解了, 网上也有了一些文章, 大家可以去看&lt;/code&gt;.  笔者本身也不是很熟悉~&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;username-l0phtg@L0phTg:armeabi-v7a$ r2 test
 -- Interpret radare2 scripts with &#39;. &amp;lt;path-to-script&amp;gt;&#39;. Similar to the bash source alias command.
[0x000085a0]&amp;gt; aa
[x] Analyze all flags starting with sym. and entry0 (aa)
[0x000085a0]&amp;gt; afl~judge
0x0000863c   17 126          sym.judge
[0x000085a0]&amp;gt; 0x863c
[0x0000863c]&amp;gt; pcp 126
import struct
buf = struct.pack (&amp;quot;126B&amp;quot;, *[
0x1f,0x49,0xf0,0xb5,0x79,0x44,0x09,0x68,0x87,0xb0,0x07,
0x46,0x0b,0x68,0x01,0xaa,0x0d,0x46,0x16,0x46,0x05,0x93,
0x1b,0x4b,0x7b,0x44,0x03,0xf1,0x10,0x0e,0x18,0x68,0x08,
0x33,0x53,0xf8,0x04,0x1c,0x73,0x45,0x14,0x46,0x03,0xc4,
0x22,0x46,0xf6,0xd1,0x3a,0x46,0x00,0x23,0x01,0x20,0x03,
0xf0,0x03,0x01,0x02,0x29,0x09,0xd0,0x03,0x29,0x0a,0xd0,
0x01,0x29,0x02,0xd0,0x14,0x78,0xf1,0x5c,0x08,0xe0,0x11,
0x78,0x01,0x31,0x04,0xe0,0x11,0x78,0x02,0x31,0x01,0xe0,
0x11,0x78,0x03,0x31,0xf4,0x5c,0x01,0x33,0xa1,0x42,0x18,
0xbf,0x00,0x20,0x10,0x2b,0x02,0xf1,0x01,0x02,0xe3,0xd1,
0x05,0x9a,0x2b,0x68,0x9a,0x42,0x01,0xd0,0xff,0xf7,0x0a,
0xef,0x07,0xb0,0xf0,0xbd])
[0x0000863c]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;了解capstone中对arm指令进行操作的函数-接口&#34;&gt;了解capstone中对arm指令进行操作的函数 &lt;code&gt;接口&lt;/code&gt;&lt;/h3&gt;

&lt;h4 id=&#34;从源代码中提供的-example-来初步了解capstone提供给我们的可用的-接口-的使用&#34;&gt;从源代码中提供的&lt;code&gt;example&lt;/code&gt;, 来初步了解capstone提供给我们的可用的&lt;code&gt;接口&lt;/code&gt;的使用&lt;/h4&gt;

&lt;p&gt;我们参考的主要是 &lt;code&gt;/bindings/python/test_arm.py&lt;/code&gt; 和 &lt;code&gt;/bindings/python/test_detail.py&lt;/code&gt;这两个文件:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;test_arm.py   &lt;code&gt;源代码过多, 这里就不全部都放上来了&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python

# Capstone Python bindings, by Nguyen Anh Quynnh &amp;lt;aquynh@gmail.com&amp;gt;

from __future__ import print_function
from capstone import *
from capstone.arm import *
from xprint import to_hex, to_x, to_x_32

ARM_CODE = b&amp;quot;\xED\xFF\xFF\xEB\x04\xe0\x2d\xe5\x00\x00\x00\x00\xe0\x83\x22\xe5\xf1\x02\x03\x0e\x00\x00\xa0\xe3\x02\x30\xc1\xe7\x00\x00\x53\xe3\x00\x02\x01\xf1\x05\x40\xd0\xe8\xf4\x80\x00\x00&amp;quot;
THUMB_CODE = b&amp;quot;\x70\x47\x00\xf0\x10\xe8\xeb\x46\x83\xb0\xc9\x68\x1f\xb1\x30\xbf\xaf\xf3\x20\x84&amp;quot;

all_tests = (
        (CS_ARCH_ARM, CS_MODE_ARM, ARM_CODE, &amp;quot;ARM&amp;quot;, None),
        (CS_ARCH_ARM, CS_MODE_THUMB, THUMB_CODE, &amp;quot;Thumb&amp;quot;, None),
        )

def print_insn_detail(insn):
    # print address, mnemonic and operands
    print(&amp;quot;0x%x:\t%s\t%s&amp;quot; % (insn.address, insn.mnemonic, insn.op_str))

    # &amp;quot;data&amp;quot; instruction generated by SKIPDATA option has no detail
    if insn.id == 0:
        return

    if len(insn.operands) &amp;gt; 0:
        print(&amp;quot;\top_count: %u&amp;quot; % len(insn.operands))
        c = 0
        for i in insn.operands:
            if i.type == ARM_OP_REG:
                print(&amp;quot;\t\toperands[%u].type: REG = %s&amp;quot; % (c, insn.reg_name(i.reg)))
            if i.type == ARM_OP_IMM:
                print(&amp;quot;\t\toperands[%u].type: IMM = 0x%s&amp;quot; % (c, to_x_32(i.imm)))
...............................
            if i.type == ARM_OP_MEM:
                print(&amp;quot;\t\toperands[%u].type: MEM&amp;quot; % c)
                if i.mem.base != 0:
                    print(&amp;quot;\t\t\toperands[%u].mem.base: REG = %s&amp;quot; \
                        % (c, insn.reg_name(i.mem.base)))
                if i.mem.index != 0:
                    print(&amp;quot;\t\t\toperands[%u].mem.index: REG = %s&amp;quot; \
                        % (c, insn.reg_name(i.mem.index)))
                if i.mem.scale != 1:
                    print(&amp;quot;\t\t\toperands[%u].mem.scale: %u&amp;quot; \
                        % (c, i.mem.scale))
                if i.mem.disp != 0:
                    print(&amp;quot;\t\t\toperands[%u].mem.disp: 0x%s&amp;quot; \
                        % (c, to_x_32(i.mem.disp)))
...............................
            c += 1

    if insn.update_flags:
        print(&amp;quot;\tUpdate-flags: True&amp;quot;)
    if insn.writeback:
        print(&amp;quot;\tWrite-back: True&amp;quot;)
    if not insn.cc in [ARM_CC_AL, ARM_CC_INVALID]:
        print(&amp;quot;\tCode condition: %u&amp;quot; % insn.cc)
...............................

### Test class Cs
def test_class():

    for (arch, mode, code, comment, syntax) in all_tests:
        print(&amp;quot;*&amp;quot; * 16)
        print(&amp;quot;Platform: %s&amp;quot; % comment)
        print(&amp;quot;Code: %s&amp;quot; % to_hex(code))
        print(&amp;quot;Disasm:&amp;quot;)

        try:
            md = Cs(arch, mode)
            if syntax:
                md.syntax = syntax
            md.detail = True
            for insn in md.disasm(code, 0x80001000):
                print_insn_detail(insn)
                print ()
            print (&amp;quot;0x%x:\n&amp;quot; % (insn.address + insn.size))
        except CsError as e:
            print(&amp;quot;ERROR: %s&amp;quot; % e)


if __name__ == &#39;__main__&#39;:
    test_class()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;观察&lt;code&gt;test_arm.py&lt;/code&gt;, 我们可以看到的重要的一些操作有:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;md = Cs(arch, mode)
for insn in md.disasm(code, 0x80001000):
    print_insn_detail(insn)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先通过&lt;code&gt;md = Cs(arch, mode)&lt;/code&gt;来选择我们的架构, 然后调用&lt;code&gt;md.disasm&lt;/code&gt;返回 指令(insn) (这里Cs.disasm就是一个生成器, 参看py语法)
然后打印&lt;code&gt;insn&lt;/code&gt;的细节(助记符, 操作数, 以及每个操作数的类型等)&lt;/p&gt;

&lt;p&gt;打印的时候(这里我只列举了部分操作):
- 我们可以发现 &lt;strong&gt;针对指令&lt;/strong&gt; 调用了 &lt;strong&gt;insn.address&lt;/strong&gt;, &lt;strong&gt;insn.mnemonic&lt;/strong&gt;,  &lt;strong&gt;insn.op_str&lt;/strong&gt;, &lt;strong&gt;insn.operands&lt;/strong&gt;, &lt;strong&gt;insn.update_flags&lt;/strong&gt;, &lt;strong&gt;insn.cc&lt;/strong&gt;&amp;hellip;..
- 针对 &lt;strong&gt;操作数&lt;/strong&gt; 调用了 &lt;strong&gt;i.type&lt;/strong&gt;, &lt;strong&gt;i.reg&lt;/strong&gt;, &lt;strong&gt;i.mem&lt;/strong&gt;&amp;hellip;.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;test_detail.py (省略了一些和上面test_arm.py相似的代码)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;..........
def print_detail(insn):
    print(&amp;quot;0x%x:\t%s\t%s  // insn-ID: %u, insn-mnem: %s&amp;quot; \
        % (insn.address, insn.mnemonic, insn.op_str, insn.id, \
        insn.insn_name()))

    # &amp;quot;data&amp;quot; instruction generated by SKIPDATA option has no detail
    if insn.id == 0:
        return

    if len(insn.regs_read) &amp;gt; 0:
        print(&amp;quot;\tImplicit registers read: &amp;quot;, end=&#39;&#39;),
        for m in insn.regs_read:
            print(&amp;quot;%s &amp;quot; % insn.reg_name(m), end=&#39;&#39;),
        print()

    if len(insn.regs_write) &amp;gt; 0:
        print(&amp;quot;\tImplicit registers modified: &amp;quot;, end=&#39;&#39;),
        for m in insn.regs_write:
            print(&amp;quot;%s &amp;quot; % insn.reg_name(m), end=&#39;&#39;),
        print()

    if len(insn.groups) &amp;gt; 0:
        print(&amp;quot;\tThis instruction belongs to groups: &amp;quot;, end=&#39;&#39;),
        for m in insn.groups:
            print(&amp;quot;%s &amp;quot; % insn.group_name(m), end=&#39;&#39;),
        print()``
        ....................................

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;操作很明显:
&lt;strong&gt;insn.regs_read&lt;/strong&gt;, &lt;strong&gt;insn.regs_write&lt;/strong&gt;, &lt;strong&gt;insn.groups&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&#34;观察源代码中的-bindings-python-capstone-init-py-来了解-cs-和-csinsn-的实现&#34;&gt;观察源代码中的&lt;code&gt;/bindings/python/capstone/__init__.py&lt;/code&gt;来了解&lt;strong&gt;CS&lt;/strong&gt; 和 &lt;strong&gt;CsInsn&lt;/strong&gt; 的实现:&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Cs(object):
    def __init__(self, arch, mode):
        ....
        ....省略


    # Disassemble binary &amp;amp; return disassembled instructions in CsInsn objects   反汇编二进制代码&amp;amp;&amp;amp; 返回反汇编的指令in CsInsn对象中
    def disasm(self, code, offset, count=0):
        all_insn = ctypes.POINTER(_cs_insn)()
        &#39;&#39;&#39;if not _python2:
            print(code)
            code = code.encode()
            print(code)&#39;&#39;&#39;
        # Hack, unicorn&#39;s memory accessors give you back bytearrays, but they
        # cause TypeErrors when you hand them into Capstone.
        if isinstance(code, bytearray):
            code = bytes(code)
        res = _cs.cs_disasm(self.csh, code, len(code), offset, count, ctypes.byref(all_insn))*************
        if res &amp;gt; 0:
            try:
                for i in range(res):
                    yield CsInsn(self, all_insn[i])         ## all_info*********************************** 重点操作
            finally:
                _cs.cs_free(all_insn, res)
        else:
            status = _cs.cs_errno(self.csh)
            if status != CS_ERR_OK:
                raise CsError(status)
            return
            yield
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过观察&lt;strong&gt;Cs&lt;/strong&gt;这个类的实现, 我们发现了它是一个生成器, 一直返回&lt;strong&gt;CsInsn&lt;/strong&gt; 这个类的对象, 现在我们来看一下CsInsn 这个类的实现(从名字可以就可以看出来, 它保存了我们每条指令的性质)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;▼ CsInsn : class
   +__init__ : function
   +id : function           @property
   +address : function      @property // 返回 指令的地址
   +size : function         @property // 返回 大小
   +bytes : function        @property // 返回 字节码 []
   +mnemonic : function     @property // 返回 指令名称(助记符)
   +op_str : function       @property // 返回 操作string
   +regs_read : function    @property // 返回 会被*隐式*读的寄存器[]
   +regs_write : function   @property // 返回 会被*隐式*写的寄存器[]
   +groups : function       @property // 指令的group
   -__gen_detail : function
   -__getattr__ : function
   +errno : function
   +reg_name : function   (self, reg_id)  // 返回寄存器的名称
   +insn_name : function                  // 返回指令名称, 不同于mnemonic
   +group_name : function
   +group : function
   +reg_read : function   (self, reg_id)  // 识别该寄存器会被隐式read
   +reg_write : function  (self, reg_id)  // 识别该寄存器是否会被隐式 write
   +op_count : function
   +op_find : function
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我罗列了一下它的所有操作,  我们下面写代码的时候会用到.&lt;/p&gt;

&lt;h4 id=&#34;这里我们先简单写一个-py-来对上面的部分函数进行应用&#34;&gt;这里我们先简单写一个.py, 来对上面的部分函数进行应用&lt;/h4&gt;

&lt;p&gt;我们可以先看一下输出结果:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;l0phtg@l0phtg-PC:~/blogTest$ python test.py 
0x1000: push    {r4, r6, r7, lr}
id:426  groups:[150, 151]   size:2  
bytes:  0xd0 0xb5 
    op_count: 4
        operands[0].type: REG = r4
        operands[1].type: REG = r6
        operands[2].type: REG = r7
        operands[3].type: REG = lr

0x1002: pop {r4, r6, r7, pc}
id:425  groups:[150, 151]   size:2  
bytes:  0xd0 0xbd 
    op_count: 4
        operands[0].type: REG = r4
        operands[1].type: REG = r6
        operands[2].type: REG = r7
        operands[3].type: REG = pc

0x1004: beq #0x100e
id:17   groups:[150, 151, 1]    size:2  
bytes:  0x3 0xd0 
    op_count: 1
        operands[0].type: IMM = 0x100e

0x1006: movs    r0, #0
id:80   groups:[150, 151]   size:2  
bytes:  0x0 0x20 
    op_count: 2
        operands[0].type: REG = r0
        operands[1].type: IMM = 0x0
    Update-flags: True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每条指令的指令名称, 指令操作数, 操作数类型, 该指令是否更新flag都显示了出来.&lt;/p&gt;

&lt;p&gt;下面的代码(参考test_arm.py的实现)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python2
#-*- coding:utf-8 -*-

import sys
from capstone import *
from capstone.arm import *
from xprint import to_hex, to_x, to_x_32

my_thumb_code = b&amp;quot;\xd0\xb5\xd0\xbd\x03\xd0\x00\x20&amp;quot;


def print_insn_detail(insn):
    print(&amp;quot;0x%x:\t%s\t%s&amp;quot; % (insn.address, insn.mnemonic, insn.op_str))
    print(&amp;quot;id:%d\tgroups:%s\tsize:%x\t&amp;quot; % (insn.id, insn.groups, insn.size))
    sys.stdout.write(&#39;bytes:\t&#39;)
    for i in insn.bytes:
        sys.stdout.write(&amp;quot;%s &amp;quot; % hex(i))
    sys.stdout.write(&#39;\n&#39;)

    if len(insn.operands) &amp;gt; 0:
        print(&amp;quot;\top_count: %u&amp;quot; % len(insn.operands))
        c = 0
        for i in insn.operands:
            if i.type == ARM_OP_REG:
                print(&amp;quot;\t\toperands[%u].type: REG = %s&amp;quot; % (c, insn.reg_name(i.reg)))
            if i.type == ARM_OP_IMM:
                print(&amp;quot;\t\toperands[%u].type: IMM = 0x%s&amp;quot; % (c, to_x_32(i.imm)))
            if i.type == ARM_OP_PIMM:
                print(&amp;quot;\t\toperands[%u].type: P-IMM = %u&amp;quot; % (c, i.imm))
            if i.type == ARM_OP_CIMM:
                print(&amp;quot;\t\toperands[%u].type: C-IMM = %u&amp;quot; % (c, i.imm))
            if i.type == ARM_OP_FP:
                print(&amp;quot;\t\toperands[%u].type: FP = %f&amp;quot; % (c, i.fp))
            if i.type == ARM_OP_SYSREG:
                print(&amp;quot;\t\toperands[%u].type: SYSREG = %u&amp;quot; % (c, i.reg))
            if i.type == ARM_OP_SETEND:
                if i.setend == ARM_SETEND_BE:
                    print(&amp;quot;\t\toperands[%u].type: SETEND = be&amp;quot; % c)
                else:
                    print(&amp;quot;\t\toperands[%u].type: SETEND = le&amp;quot; % c)
            if i.type == ARM_OP_MEM:
                print(&amp;quot;\t\toperands[%u].type: MEM&amp;quot; % c)
                if i.mem.base != 0:
                    print(&amp;quot;\t\t\toperands[%u].mem.base: REG = %s&amp;quot; \
                        % (c, insn.reg_name(i.mem.base)))
                if i.mem.index != 0:
                    print(&amp;quot;\t\t\toperands[%u].mem.index: REG = %s&amp;quot; \
                        % (c, insn.reg_name(i.mem.index)))
                if i.mem.scale != 1:
                    print(&amp;quot;\t\t\toperands[%u].mem.scale: %u&amp;quot; \
                        % (c, i.mem.scale))
                if i.mem.disp != 0:
                    print(&amp;quot;\t\t\toperands[%u].mem.disp: 0x%s&amp;quot; \
                        % (c, to_x_32(i.mem.disp)))

            if i.shift.type != ARM_SFT_INVALID and i.shift.value:
                print(&amp;quot;\t\t\tShift: %u = %u&amp;quot; \
                    % (i.shift.type, i.shift.value))
            if i.vector_index != -1:
                print(&amp;quot;\t\t\toperands[%u].vector_index = %u&amp;quot; %(c, i.vector_index))
            if i.subtracted:
                print(&amp;quot;\t\t\toperands[%u].subtracted = True&amp;quot; %c)

            c += 1

    if insn.update_flags:
        print(&amp;quot;\tUpdate-flags: True&amp;quot;)

def test_class():

    md = Cs(CS_ARCH_ARM, CS_MODE_THUMB)
    md.detail=True
    for insn in md.disasm(my_thumb_code, 0x1000):
        print_insn_detail(insn)
        sys.stdout.write(&#39;\n&#39;)

if __name__ == &#39;__main__&#39;:
    test_class()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;了解-thumb-的指令编码&#34;&gt;了解 thumb 的指令编码:&lt;/h3&gt;

&lt;p&gt;在前面环境搭建的时候, 我向大家推荐了arm的一个文档, 本节主要针对该文档进行分析.&lt;/p&gt;

&lt;p&gt;首先定位到第&lt;code&gt;F3&lt;/code&gt;章节, 观看目录:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Chapter F3

T32 Base Instruction Set Encoding

This chapter introduces the T32 instruction set and describes how it uses the ARM programmers’ model. It contains

the following sections:


• T32 instruction set encoding on page F3-2432.

• 16-bit T32 instruction encoding on page F3-2435.

• 32-bit T32 instruction encoding on page F3-2442.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们在此分析的是&lt;strong&gt;16-bit T32 instruction&lt;/strong&gt;, 再次定位到&lt;code&gt;F3-2435&lt;/code&gt;.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>elf文件格式和AndroidLinker加载.so的源码分析</title>
      <link>https://l0phtg.github.io/post/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%92%8Candroidlinker%E5%8A%A0%E8%BD%BD-so%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Sun, 19 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://l0phtg.github.io/post/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%92%8Candroidlinker%E5%8A%A0%E8%BD%BD-so%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      
        <description>&lt;p&gt;最近在学习android应用的加壳和混淆方法, 所以遇到了一些有关.so是如何加载到android中去的问题, 看了一些视频和文章, 所以想在此总结一下.&lt;/p&gt;

&lt;p&gt;本文主要内容:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;elf的文件格式&lt;/li&gt;
&lt;li&gt;分析linker的源码, 主要dlopen流程.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;elf文件格式&#34;&gt;elf文件格式&lt;/h2&gt;

&lt;p&gt;本文只对elf文件格式进行简单的分析, 如果要进行深入的了解, 推荐&lt;code&gt;&amp;lt;&amp;lt;程序员的自我修养&amp;gt;&amp;gt;&lt;/code&gt;中第3章.&lt;/p&gt;

&lt;p&gt;/usr/includ/elf.h中定义了elf文件头结构和相关的常数.&lt;/p&gt;

&lt;p&gt;分析elf文件时, 建议使用&lt;code&gt;010 editor&lt;/code&gt;这款十六进制编辑软件, 运行elf模板后可以清晰的将文件格式显示出来, 大致的显示是(坑, 此处应该用图片的)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;                NAME                           Value            Start       Size        Color       Comment
    struct file                                                 0h          109Ch
        struct elf_header                                       0h          34h
        struct program_header_table                             34h         120h
        struct section_header_table                             1B274h      460h
        struct dynamic_symbol_table                             18Ch        F10h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到, 一个elf文件中包含一个header, 3个table, 我们一个一个的来分析一下.
首先分析&lt;code&gt;Elf header&lt;/code&gt;, 它位于每一个elf文件开始的地方:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct                                                            typedef struct
{                                                                         {
    unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */     unsigned char e_ident[EI_NIDENT];
    Elf32_Half    e_type;         /* Object file type */                    Elf64_Half    e_type;     
    Elf32_Half    e_machine;      /* Architecture */                        Elf64_Half    e_machine;  
    Elf32_Word    e_version;      /* Object file version */                 Elf64_Word    e_version;  
    Elf32_Addr    e_entry;        /* Entry point virtual address */         Elf64_Addr    e_entry;    
    Elf32_Off e_phoff;        /* Program header table file offset */        Elf64_Off e_phoff;        
    Elf32_Off e_shoff;        /* Section header table file offset */        Elf64_Off e_shoff;        
    Elf32_Word    e_flags;        /* Processor-specific flags */            Elf64_Word    e_flags;    
    Elf32_Half    e_ehsize;       /* ELF header size in bytes */            Elf64_Half    e_ehsize;   
    Elf32_Half    e_phentsize;        /* Program header table entry size */ Elf64_Half    e_phentsize;
    Elf32_Half    e_phnum;        /* Program header table entry count */    Elf64_Half    e_phnum;    
    Elf32_Half    e_shentsize;        /* Section header table entry size */ Elf64_Half    e_shentsize;
    Elf32_Half    e_shnum;        /* Section header table entry count */    Elf64_Half    e_shnum;    
    Elf32_Half    e_shstrndx;     /* Section header string table index */   Elf64_Half    e_shstrndx; 
} Elf32_Ehdr;                                                              } Elf64_Ehdr;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到, header中包含了magic number, 文件类型, 目标文件版本, 入口地址(如果为0, 说明此文件为可重定位文件), program header的开始地址(即为在so文件中的offset), section header的开始地址, 标志位, elf头本身的大小, program header和section header的size和数量, 最后是section header中string section在section中的下标.(用010 editor可以看到清楚的看到一个.so文件包含众多的program header 和 section header, 这两个段在做.so混淆时会经常分析)&lt;/p&gt;

&lt;p&gt;现在分析&lt;code&gt;program header&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* Program segment header.  */

typedef struct                                                      typedef struct
{                                                                   {
    Elf32_Word    p_type;         /* Segment type */                    Elf64_Word    p_type;   
    Elf32_Off p_offset;       /* Segment file offset */                 Elf64_Off p_offset;     
    Elf32_Addr    p_vaddr;        /* Segment virtual address */         Elf64_Addr    p_vaddr;  
    Elf32_Addr    p_paddr;        /* Segment physical address */        Elf64_Addr    p_paddr;  
    Elf32_Word    p_filesz;       /* Segment size in file */            Elf64_Word    p_filesz; 
    Elf32_Word    p_memsz;        /* Segment size in memory */          Elf64_Word    p_memsz;  
    Elf32_Word    p_flags;        /* Segment flags */                   Elf64_Word    p_flags;  
    Elf32_Word    p_align;        /* Segment alignment */               Elf64_Word    p_align;  
} Elf32_Phdr;                                                       } Elf64_Phdr;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来分析&lt;code&gt;section header&lt;/code&gt;, section相信了解过汇编的同学都非常熟悉了, 这个section header里面就存放了我们elf中各个段的信息.
看一下section header段描述符的结构:(64位的与32位的结构体大致相同, 只是把类型改为了Elf64的类型)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct
{
    Elf32_Word    sh_name;        /* Section name (string tbl index) 段名*/
    Elf32_Word    sh_type;        /* Section type 段类型*/
    Elf32_Word    sh_flags;       /* Section flags 标志位*/
    Elf32_Addr    sh_addr;        /* Section virtual addr at execution 段虚拟地址*/
    Elf32_Off sh_offset;          /* Section file offset 段偏移*/
    Elf32_Word    sh_size;        /* Section size in bytes 段的长度*/
    Elf32_Word    sh_link;        /* Link to another section 段的链接信息*/
    Elf32_Word    sh_info;        /* Additional section information 段链接的相关信息*/
    Elf32_Word    sh_addralign;   /* Section alignment 段地址对齐*/
    Elf32_Word    sh_entsize;     /* Entry size if section holds table 项的长度*/
} Elf32_Shdr;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后分析动态符号表(&lt;code&gt;symbol table&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct
{
    Elf32_Word    st_name;        /* Symbol name (string tbl index) */
    Elf32_Addr    st_value;       /* Symbol value */
    Elf32_Word    st_size;        /* Symbol size */
    unsigned char st_info;        /* Symbol type and binding */
    unsigned char st_other;       /* Symbol visibility */
    Elf32_Section st_shndx;       /* Section index */
} Elf32_Sym;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;包含的信息有符号名, 符号相对应的值, 符号大小, 符号类型和绑定信息, 符号所在的段.&lt;/p&gt;

&lt;h2 id=&#34;android-linker加载-so的源码分析&#34;&gt;Android Linker加载.so的源码分析&lt;/h2&gt;

&lt;p&gt;Android中的本地文件.so是通过Linker加载到内存中去并且执行的.(本文分析的源码为Android4.4.4)
                &amp;mdash;- 推荐一款好用的源码阅读工具 source Insight&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;java层:  System.LoadLibrary(&amp;quot;function&amp;quot;);
native:         ---&amp;gt;  Dalvik/vm/native/java_lang_Runtime.cpp: Dalvik_java_lang_Runtime_nativeLoad 
                        ---&amp;gt;Dalvik/vm/Native.cpp: dvmLoadNativeCode(const char* fileName, Object* ClassLoader, char** reason)
                                ---&amp;gt;bionic/linker/dlfcn.c: dlopen(const char* pathName, RTLD_LAZY)
                                        ---&amp;gt;bionic/linker/linker.cpp: do_dlopen(const char* name, int flags)
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;核心函数为&lt;code&gt;do_dlopen&lt;/code&gt;:
&lt;code&gt;cpp
soinfo* do_dlopen(const char* name, int flags) {  // 函数的参数为
if ((flags &amp;amp; ~(RTLD_NOW|RTLD_LAZY|RTLD_LOCAL|RTLD_GLOBAL)) != 0) {
    DL_ERR(&amp;quot;invalid flags to dlopen: %x&amp;quot;, flags);
    return NULL;
}
set_soinfo_pool_protection(PROT_READ | PROT_WRITE); // 设置so信息池的访问权限为可读可写
soinfo* si = find_library(name);                    // 找到name函数, 装载so, 并返回指向.soinfo的指针
if (si != NULL) {
                  si-&amp;gt;CallConstructors();           // 初始化so库
}
set_soinfo_pool_protection(PROT_READ);              // 设置so信息池的访问权限为只读
return si;
}
&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看&lt;code&gt;find_library&lt;/code&gt;函数可以发现它调用了&lt;code&gt;find_library_internal&lt;/code&gt;函数,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;static soinfo* find_library(const char* name) {
soinfo* si = find_library_internal(name);
if (si != NULL) {
    si-&amp;gt;ref_count++;
}
return si;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分析&lt;code&gt;find_library_internal&lt;/code&gt;函数, 发现其主要调用了&lt;code&gt;load_library()&lt;/code&gt;函数和 &lt;code&gt;soinfo_link_image()&lt;/code&gt; 函数.
_&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;static soinfo* find_library_internal(const char* name) {
if (name == NULL) {
    return somain;
}
soinfo* si = find_loaded_library(name);         // 判断.so是否完全加载, 如果加载: 返回有效的指针;如果没有加载, 返回null;
if (si != NULL) {                               // 如果已经加载，返回
    if (si-&amp;gt;flags &amp;amp; FLAG_LINKED) {
        return si;
    }
    DL_ERR(&amp;quot;OOPS: recursive link to \&amp;quot;%s\&amp;quot;&amp;quot;, si-&amp;gt;name);
    return NULL;
}

TRACE(&amp;quot;[ &#39;%s&#39; has not been loaded yet.  Locating...]&amp;quot;, name);  // 打印so还没有加载
si = load_library(name);        // 加载.so
if (si == NULL) {
    return NULL;
}
// At this point we know that whatever is loaded @ base is a valid ELF
// shared library whose segments are properly mapped in.
TRACE(&amp;quot;[ init_library base=0x%08x sz=0x%08x name=&#39;%s&#39; ]&amp;quot;,
        si-&amp;gt;base, si-&amp;gt;size, si-&amp;gt;name);

if (!soinfo_link_image(si)) {       // 完成.so的重定位
    munmap(reinterpret_cast&amp;lt;void*&amp;gt;(si-&amp;gt;base), si-&amp;gt;size);
    soinfo_free(si);
    return NULL;
}
return si;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;分析&lt;code&gt;load_library&lt;/code&gt;函数, 会找到elf_read.&lt;code&gt;Load()&lt;/code&gt;方法, 这个方法就是load&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;static soinfo* load_library(const char* name) {
// Open the file.
    int fd = open_library(name);                        // 打开文件, 获取fd
    if (fd == -1) {
        DL_ERR(&amp;quot;library \&amp;quot;%s\&amp;quot; not found&amp;quot;, name);
        return NULL;
    }

    // Read the ELF header and load the segments.
    ElfReader elf_reader(name, fd);                     // 初始化elfReader对象
    if (!elf_reader.Load()) {                           // 通过elfReader对象的Load()方法, 将so文件装载到内存
        return NULL;
    }

    const char* bname = strrchr(name, &#39;/&#39;);
    soinfo* si = soinfo_alloc(bname ? bname + 1 : name);    // 分配so_info结构, 并按照装载结果更新相应的成员变量
    if (si == NULL) {
        return NULL;
    }
    si-&amp;gt;base = elf_reader.load_start();
    si-&amp;gt;size = elf_reader.load_size();
    si-&amp;gt;load_bias = elf_reader.load_bias();
    si-&amp;gt;flags = 0;
    si-&amp;gt;entry = 0;
    si-&amp;gt;dynamic = NULL;
    si-&amp;gt;phnum = elf_reader.phdr_count();
    si-&amp;gt;phdr = elf_reader.loaded_phdr();

    return si;
}

这里放一个ElfReader结构:
class ElfReader {
public:
    ElfReader(const char* name, int fd);
    ~ElfReader();

    bool Load();

    size_t phdr_count() { return phdr_num_; }
    Elf32_Addr load_start() { return reinterpret_cast&amp;lt;Elf32_Addr&amp;gt;(load_start_); }
    Elf32_Addr load_size() { return load_size_; }
    Elf32_Addr load_bias() { return load_bias_; }
    const Elf32_Phdr* loaded_phdr() { return loaded_phdr_; }

private:
    bool ReadElfHeader();
    bool VerifyElfHeader();
    bool ReadProgramHeader();
    bool ReserveAddressSpace();
    bool LoadSegments();
    bool FindPhdr();
    bool CheckPhdr(Elf32_Addr); 

    const char* name_;
    int fd_;    

    Elf32_Ehdr header_;
    size_t phdr_num_;   

    void* phdr_mmap_;
    Elf32_Phdr* phdr_table_;
    Elf32_Addr phdr_size_;  

    // First page of reserved address space.
    void* load_start_;
    // Size in bytes of reserved address space.
    Elf32_Addr load_size_;
    // Load bias.
    Elf32_Addr load_bias_;

    // Loaded phdr.
    const Elf32_Phdr* loaded_phdr_;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里是&lt;code&gt;Load()&lt;/code&gt;函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool ElfReader::Load() {
    return ReadElfHeader() &amp;amp;&amp;amp;                   // 读取
        VerifyElfHeader() &amp;amp;&amp;amp;                // 验证
        ReadProgramHeader() &amp;amp;&amp;amp;              // 读取Program header
        ReserveAddressSpace() &amp;amp;&amp;amp;            // 根据Program header计算so需要的内存size并分配相应的空间
        LoadSegments() &amp;amp;&amp;amp;                   // 将so按照segment为单位装载到内存
        FindPhdr();                     // on 装载到内存的so中找到program header, 方便以后链接过程use
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;首先是&lt;code&gt;ReadElfHeader&lt;/code&gt;()函数, 发现其是直接调用&lt;code&gt;read&lt;/code&gt;函数读取到header中的.
&lt;code&gt;cpp
bool ElfReader::ReadElfHeader() {
ssize_t rc = TEMP_FAILURE_RETRY(read(fd_, &amp;amp;header_, sizeof(header_)));  // use read() function 直接将elfheader读取到header中
&lt;/code&gt;//////////////////////////////
return true;
}
```&lt;/li&gt;
&lt;li&gt;然后是&lt;code&gt;VerifyElfread&lt;/code&gt;()函数, 对Elfheader进行验证识别: 是否为32位，大小端，类型和版本.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;之后&lt;code&gt;ReadProgramHeader&lt;/code&gt;()函数(加载program header table从elf文件到一个只读的私有匿名的mmap-ed block中):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool ElfReader::ReadProgramHeader() {
phdr_num_ = header_.e_phnum;                                        
//  将program header on内存中中单独映射一份, use于解析时临时use, on so装载到内存后, 便会释放这块内存, 转而使use装载后的so中的program header

// Like the kernel, we only accept program header tables that
// are smaller than 64KiB.
if (phdr_num_ &amp;lt; 1 || phdr_num_ &amp;gt; 65536/sizeof(Elf32_Phdr)) {
    DL_ERR(&amp;quot;\&amp;quot;%s\&amp;quot; has invalid e_phnum: %d&amp;quot;, name_, phdr_num_);
    return false;
}

Elf32_Addr page_min = PAGE_START(header_.e_phoff);
Elf32_Addr page_max = PAGE_END(header_.e_phoff + (phdr_num_ * sizeof(Elf32_Phdr)));
Elf32_Addr page_offset = PAGE_OFFSET(header_.e_phoff);  

phdr_size_ = page_max - page_min;

void* mmap_result = mmap(NULL, phdr_size_, PROT_READ, MAP_PRIVATE, fd_, page_min);
    if (mmap_result == MAP_FAILED) {
    DL_ERR(&amp;quot;\&amp;quot;%s\&amp;quot; phdr mmap failed: %s&amp;quot;, name_, strerror(errno));
    return false;
}

phdr_mmap_ = mmap_result;
phdr_table_ = reinterpret_cast&amp;lt;Elf32_Phdr*&amp;gt;(reinterpret_cast&amp;lt;char*&amp;gt;(mmap_result) + page_offset);
return true;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;ReverveAddressSpace&lt;/code&gt;()函数(准备虚拟内存足够的大来存放Program header中的&lt;code&gt;Load&lt;/code&gt;段(两个Load段～～) 通过&lt;code&gt;mmap with PROT_NONE&lt;/code&gt; 实现&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool ElfReader::ReserveAddressSpace() {
    Elf32_Addr min_vaddr;
    load_size_ = phdr_table_get_load_size(phdr_table_, phdr_num_, &amp;amp;min_vaddr);  // 获取so on 内存中需要的空间load_size
    if (load_size_ == 0) {
          DL_ERR(&amp;quot;\&amp;quot;%s\&amp;quot; has no loadable segments&amp;quot;, name_);
              return false;
    }

    uint8_t* addr = reinterpret_cast&amp;lt;uint8_t*&amp;gt;(min_vaddr);
    void* start = mmap(addr, load_size_, PROT_NONE, mmap_flags, -1, 0);         // use mmap匿名映射, 预留出相应的空间
    int mmap_flags = MAP_PRIVATE | MAP_ANONYMOUS;
    if (start == MAP_FAILED) {
        DL_ERR(&amp;quot;couldn&#39;t reserve %d bytes of address space for \&amp;quot;%s\&amp;quot;&amp;quot;, load_size_, name_);
        return false;
    }

    load_start_ = start;
    load_bias_ = reinterpret_cast&amp;lt;uint8_t*&amp;gt;(start) - addr;              // so可以指定加载的基址, 但是so指定的加载基址可能不是页对齐的, 这种情况
    return true;                                                            // 会导致实际映射地址和指定的加载地址有一个偏差, 这个偏差便是load_bias
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;LoadSegments&lt;/code&gt;()函数(在进程地址空间中加载所有可加载的段(假设你已经预留了空间为这个library)):
```cpp
bool ElfReader::LoadSegments() {&lt;br /&gt;
for (size_t i = 0; i &amp;lt; phdr&lt;em&gt;num&lt;/em&gt;; ++i) {
const Elf32_Phdr* phdr = &amp;amp;phdr&lt;em&gt;table&lt;/em&gt;[i];   // 遍历program header table&lt;/p&gt;

&lt;p&gt;if (phdr-&amp;gt;p_type != PT_LOAD) {          // 加载所有p_type == PT_LOAD的段
    continue;
}&lt;/p&gt;

&lt;p&gt;``` 之后就是一些设置段地址，段偏移, 之后mmap的一些操作&lt;/p&gt;

&lt;p&gt;return true;
}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
 * `FindPhdr`()(返回program header table加载到内存中的地址, 因为之后还要执行.so的重定位).
现在回到我们`find_library_internal`()这里，在执行完load_library()之后, 还有一个重要的函数为 `soinfo_link_image`(soinfo* si):

```cpp
这个函数会完成.so的动态链接，其中包含我们加载的.so库的重定位过程:
 1. 定位动态section,将动态section的虚拟地址和项数和读写权限存在dynamic, dynamic_count, dynamic_flags中.
    size_t dynamic_count;
    Elf32_Word dynamic_flags;
    phdr_table_get_dynamic_section(phdr, phnum, base, &amp;amp;si-&amp;gt;dynamic,     // 定位dynamic section
                                       &amp;amp;dynamic_count, &amp;amp;dynamic_flags);     // 

 2. 解析Dynamic section
 3. 调用find_library, 返回所有依赖的.so的soinfo指针并存放在数组中.
 4. 重定位(处理plt_rel(延迟绑定)和rel):
    可以看到, 处理两个重定位表的函数都是soinfo_relocate函数.
    if (si-&amp;gt;plt_rel != NULL) {
        DEBUG(&amp;quot;[ relocating %s plt ]&amp;quot;, si-&amp;gt;name );
        if (soinfo_relocate(si, si-&amp;gt;plt_rel, si-&amp;gt;plt_rel_count, needed)) {
            return false;
        }
    }
    if (si-&amp;gt;rel != NULL) {
        DEBUG(&amp;quot;[ relocating %s ]&amp;quot;, si-&amp;gt;name );
        if (soinfo_relocate(si, si-&amp;gt;rel, si-&amp;gt;rel_count, needed)) {       
            return false;
        }
    }       
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在分析soinfo_relocate函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;












&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>分析Android的JNI编程时所使用的一些函数功能</title>
      <link>https://l0phtg.github.io/post/%E5%88%86%E6%9E%90android%E7%9A%84jni%E7%BC%96%E7%A8%8B%E6%97%B6%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Thu, 16 Mar 2017 03:07:59 +0000</pubDate>
      
      <guid>https://l0phtg.github.io/post/%E5%88%86%E6%9E%90android%E7%9A%84jni%E7%BC%96%E7%A8%8B%E6%97%B6%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD/</guid>
      
        <description>&lt;p&gt;分析&lt;strong&gt;jni调用时&lt;/strong&gt;的一些函数及其函数功能.&lt;/p&gt;

&lt;p&gt;如 GetEnv &amp;hellip;&lt;/p&gt;

&lt;p&gt;本文已长草.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;基本类型&#34;&gt;基本类型&lt;/h2&gt;

&lt;p&gt;&lt;jni.h&gt;文件存放的位置在\Android\sdk\ndk-bundle\platforms\android-24\arch-arm\usr\include\jni.h&lt;/p&gt;

&lt;p&gt;现在来看一下jni.h头文件中内容:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    class _jobject {};                                      typedef _jobject*       jobject;
    class _jclass : public _jobject {};                     typedef _jclass*        jclass;         
    class _jstring : public _jobject {};                    typedef _jstring*       jstring;
    class _jarray : public _jobject {};                     typedef _jarray*        jarray;
    class _jobjectArray : public _jarray {};                typedef _jobjectArray*  jobjectArray;
    class _jbooleanArray : public _jarray {};               typedef _jbooleanArray* jbooleanArray;
    class _jbyteArray : public _jarray {};                  typedef _jbyteArray*    jbyteArray;
    class _jcharArray : public _jarray {};                  typedef _jcharArray*    jcharArray;
    class _jshortArray : public _jarray {};                 typedef _jshortArray*   jshortArray;
    class _jintArray : public _jarray {};                   typedef _jintArray*     jintArray;
    class _jlongArray : public _jarray {};                  typedef _jlongArray*    jlongArray;
    class _jfloatArray : public _jarray {};                 typedef _jfloatArray*   jfloatArray;
    class _jdoubleArray : public _jarray {};                typedef _jdoubleArray*  jdoubleArray;
    class _jthrowable : public _jobject {};                 typedef _jthrowable*    jthrowable;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从右边的typedef可以看出,每一个Jni中的cpp类型都有一个Java中的类型与之相对应.&lt;/p&gt;

&lt;p&gt;这里我们重点分析经常看到的_JNIEnv,_JavaVM,JNIEnv,JavaVM&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct _JNIEnv;
struct _JavaVM;
typedef const struct JNINativeInterface* C_JNIEnv;

#if defined(__cplusplus)
typedef _JNIEnv JNIEnv;
typedef _JavaVM JavaVM;
#else
typedef const struct JNINativeInterface* JNIEnv;
typedef const struct JNIInvokeInterface* JavaVM;
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JNINativeInterface为Native层的接口函数指针表, Jni中的本地函数通过这些接口来调用java层的函数.
/_JNIEnv是一个object, 包含一个指向JNINativeInterface的指针变量function和一些接口函数.
JNIEnv在cpp中的定义为_JNIEnv, 在c中的定义为 struct JNINativeInterface*.
JNIEnv: 每一个线程中都有一个属于自己线程的env, 且只在创建自己的线程内有效, 不能跨线程传递.
下面分析JavaVM:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct _JavaVM {                                                               struct JNIInvokeInterface {                                                 
    const struct JNIInvokeInterface* functions;                                 void*       reserved0;
                                                                                void*       reserved1;
                                                                                void*       reserved2;
    #if defined(__cplusplus)                                                           
    jint DestroyJavaVM()                                                       
    { return functions-&amp;gt;DestroyJavaVM(this); }                                  jint        (*DestroyJavaVM)(JavaVM*);
    jint AttachCurrentThread(JNIEnv** p_env, void* thr_args)                    jint        (*AttachCurrentThread)(JavaVM*, JNIEnv**, void*);
    { return functions-&amp;gt;AttachCurrentThread(this, p_env, thr_args); }           jint        (*DetachCurrentThread)(JavaVM*);
    jint DetachCurrentThread()                                                  jint        (*GetEnv)(JavaVM*, void**, jint);
    { return functions-&amp;gt;DetachCurrentThread(this); }                            jint        (*AttachCurrentThreadAsDaemon)(JavaVM*, JNIEnv**, void*);
    jint GetEnv(void** env, jint version)                                      };
    { return functions-&amp;gt;GetEnv(this, env, version); }
    jint AttachCurrentThreadAsDaemon(JNIEnv** p_env, void* thr_args)
    { return functions-&amp;gt;AttachCurrentThreadAsDaemon(this, p_env, thr_args); }
    #endif /*__cplusplus*/
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaVM在cpp中定义为_JavaVM, 在c中定义为指向JNIInvokeInterface的指针.
JavaVM只有一个, 因为它是java虚拟机在Jni中的表示.&lt;/p&gt;

&lt;p&gt;在用ida加载.apk中.so文件时会发现识别出来的native函数是这样的:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    int __fastcall Java_com_njctf_mobile_easycrack_MainActivity_parseText(int a1, int a2, int a3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java层的函数调用是这样的:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public native String parseText(String arg1); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而这里的a1就是我们的env, a2就是jobject或者jclass, a3就是String arg1了.
我们在导入&lt;jni.h&gt;头文件和添加了Structures之后, 就可以对ida中的参数类型和参数名字进行修改了.&lt;/p&gt;

&lt;p&gt;修改之后的结果:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int __fastcall Java_com_njctf_mobile_easycrack_MainActivity_parseText(_JNIEnv *env, jobject *obj, jstring inputString);
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>第一篇博文-谈谈CVE-2014-7911</title>
      <link>https://l0phtg.github.io/post/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87-%E8%B0%88%E8%B0%88cve-2014-7911/</link>
      <pubDate>Wed, 01 Mar 2017 20:20:20 +0000</pubDate>
      
      <guid>https://l0phtg.github.io/post/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87-%E8%B0%88%E8%B0%88cve-2014-7911/</guid>
      
        <description>&lt;p&gt;分析一个反序列化漏洞, 以及漏洞的产生的利用过程.&lt;/p&gt;

&lt;p&gt;本文主要内容:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;漏洞成因&lt;/li&gt;
&lt;li&gt;漏洞利用的原理&lt;/li&gt;
&lt;li&gt;基础知识&lt;/li&gt;
&lt;li&gt;漏洞利用流程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;漏洞成因&#34;&gt;漏洞成因:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;`java.io.ObjectInputStream`类没有对接受的数据进行验证, 导致可以传入一个不可序列化的对象.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;利用的原理&#34;&gt;利用的原理:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;android.os.binderproxy对象时不可序列化的, 并且它涉及到一个native代码可以将mObject和mOrgue当作一个指针.
具体来说就是android.os.BinderProxy对象在gc时会调用一个native的`destory`()函数导致任意代码执行.
`native` 调用链`destroy()--&amp;gt; decStrong() --&amp;gt; refs-&amp;gt;mBase-&amp;gt;onLastStrongRef(id)`
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;基础知识&#34;&gt;基础知识&lt;/h2&gt;

&lt;h3 id=&#34;1-java反序列化分析&#34;&gt;1. Java反序列化分析&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;每个java object在序列化时都有一个序列号, 这是这种机制称为序列化的原因.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java.io.ObjectOutputStream可以对对象进行序列化, 它的writeObject()方法可以将序列化后写到一个目标输出流中.
java.io.ObjectInputStream可以对对象进行反序列化, 它的readObject()方法可以从目标输入流中读入序列化的对象并将其反序列化为原对象.
下面以实例来进行分析:
  我们这里定义了一个Employee类(内部有三个实例域和一个构造函数)(其他内部函数已经省略)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package hihihi;
import java.io.*;
import java.util.*;

public class Employee implements Serializable
{
    private String name;
    private double salary;
    private Date hireDay;

    public Employee(String n, double s, int year, int month, int day)
    {
        name = n;
        salary = s;
        GregorianCalendar calendar = new GregorianCalendar(year, month - 1, day);
        hireDay = calendar.getTime();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里是我们的测试程序,运行后会在该程序文件目录下产生一个TestEmployee.db的文件, 这个文件内部的数据即使我们序列化Employee类后产生的序列化数据:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import hihihi.*;
import java.io.*;
import java.util.Date;

public class Test {
    public static void main(String[] args) throws Exception {
        BinderProxy bT = new BinderProxy();
        Employee bE = new Employee(&amp;quot;hi&amp;quot;, 150, 2017, 3, 9);
        Date bD = new Date();
        // FileOutputStream fos= new FileOutputStream(&amp;quot;TestStream.db&amp;quot;);
        // ObjectOutputStream os = new ObjectOutputStream(fos); 
        // os.writeObject(bT);
        // os.close();

        FileOutputStream fosr = new FileOutputStream(&amp;quot;TestEmployee.db&amp;quot;);
        ObjectOutputStream osr = new ObjectOutputStream(fosr);
        osr.writeObject(bE);
        osr.close();    

        ObjectInputStream fisr = new ObjectInputStream(new FileInputStream(&amp;quot;TestEmployee.db&amp;quot;));
        Object newEmployee = fisr.readObject();
        fisr.close();
        System.out.println(newEmployee);    
        // FileOutputStream fosd = new FileOutputStream(&amp;quot;TestData.db&amp;quot;);
        // ObjectOutputStream osd = new ObjectOutputStream(fosd);
        // osd.writeObject(bD);
        // osd.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单说一下序列化后的数据:(参看&lt;code&gt;&amp;lt;&amp;lt;java核心技术(卷2)&amp;gt;&amp;gt;&lt;/code&gt;)
    每个文件的Magic Number 为:  &amp;lsquo;AC ED&amp;rsquo;
    后面紧跟对象序列化的版本号: Ex: &amp;lsquo;00 05&amp;rsquo;
    字符串对象被保存为: 74  2字节表示的字符串长度 字符
    当存储一个对象时:   72  2字节的类名长度    类名   8字节长的指纹(serial ID)   1字节长的标志  2字节长的数据域描述符的数量 数据域描述符  结束标志78 超类类型(没有的话, 为70)&lt;/p&gt;

&lt;h3 id=&#34;2-java和android的gc机制&#34;&gt;2. Java和Android的GC机制&lt;/h3&gt;

&lt;p&gt;Java对象的生命周期和垃圾回收:(从网上摘录.侵删)
1. 创建对象的方式:
   * 使用new语句创建对象;
   * 使用反射, 调用java.lang.Class或java.lang.reflect.Constructor的newInstance()实例方法;
   * 调用对象的clone()方法;
   * 使用反序列化手段, 调用java.io.ObjectInputStream对象的readObject()方法.
2. 垃圾回收:
   对象的可触及性:
   * 可触及状态: 当一个对象被创建后, 只要还有引用变量引用该对象, 那么它就始终处于可触及状态;
   * 可复活状态: 当程序不再有任何变量引用对象时, 它就进入可复活状态, 该状态的对象, 垃圾回收器会准备释放它的内存, 在释放前, 会调用它的finalize()方法, 这些finlize方法可能使对象重新转到可触及状态;
   * 不可触及状态: 当JVM执行完所有的可复活状态的finalize()方法之后, 假设这些方法都没有使对象转到可触及状态. 那么该对象就进入了不可触及状态. 只有对象处于不可触及状态时, 垃圾回收器才会真正回收它占用的内存.&lt;/p&gt;

&lt;h3 id=&#34;3-android的binder机制简介-网上有很多分析binder机制的文章-这里就直接给出一个简单的定义&#34;&gt;3. Android的Binder机制简介(网上有很多分析Binder机制的文章, 这里就直接给出一个简单的定义);&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;binder是Android提供的一种IPC通信机制，方便进程之间交换数据。binder的实现包括一个公共的顶层服务接口，同时实现了这个公共顶层接口的proxy代理端和service端。binder driver充当通信媒介。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-c-对象内存布局&#34;&gt;4. C++ 对象内存布局:&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;C++中, 对象的内存布局为先放父类, 然后放自己的成员, 如果有虚函数, 内存中会有一个放虚函数表的位置在最开始处.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-堆喷射&#34;&gt;5. 堆喷射:&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;原因(为什么要用到堆喷射技术): 控制的rip指针指向的地址是在一个范围内随机变化的, 而我们可以对rip指向的区域进行写操作.
方式: 通过构造特殊的内存布局, 使无论rip指向哪里, 它都会`最终`跳转到一个固定的地址处
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;6-rop&#34;&gt;6. ROP&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;在可以控制rip指针后, 我们可以在程序加载的.so中找到一些特定的gadget, 利用内存复写技术, 来控制最终执行system函数(也就是拿到了system权限)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;漏洞利用流程&#34;&gt;漏洞利用流程&lt;/h2&gt;

&lt;h3 id=&#34;1-触发gc机制&#34;&gt;1. 触发GC机制&lt;/h3&gt;

&lt;p&gt;BinderProxy的finalize方法调用了native的方法, 会将我们的mOruge处理为指针.&lt;/p&gt;

&lt;h3 id=&#34;2-分析native方法&#34;&gt;2. 分析native方法:&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;        ------------为了我们能够正确的控制指针指针我们期望的地址，而不会让system_server crash掉
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;destory在native层的调用逻辑:
    /Core/jni/android_util_Binder.cpp   static void android_os_BinderProxy_destroy(JNIEnv* env, jobject obj)
        -----&amp;gt; /libs/utils/RefBase.cpp    void RefBase::decStrong(const void* id) const
            -----&amp;gt; int32_t android_atomic_dec(volatile int32_t* addr)          /system/core/libcutils/atomic.c
            -----&amp;gt; /libs/utils/RefBase.cpp   void RefBase::onLastStrongRef(const void* /*id*/)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结合下面的代码分析:
传入的object对象即是我们恶意构造的对象, 通过GetIntField()可以获得该对象中的实例域mObject和mOrgue
  注意到它将实例域赋值到drl后, 掉了drl-&amp;gt;decStrong() 函数&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;drl可控, 即传入的this可控, drl为指向DeathRecipientList的指针
      在decStrong函数中
        * 首先 refs = mRefs,                        即让refs = *(mOruge + 4)
        * 调用refs-&amp;gt;removeStrongRef(id)             空实现
        * c = android_atomic_dec(&amp;amp;refs-&amp;gt;mStrong)    c = *(mOruge + 4) == 1
        * if (c == 1): then &amp;hellip;.    BLX r2          r2 = * (&lt;em&gt;(&lt;/em&gt;(*(mOrgue + 4) + 8)) + 12)
  这样就完成了对rip的控制, 通过在system_server内存空间的dalvik-heap中进行堆喷射和合理的布置gadget, 就可以完成到system权限的提升.
 (具体代码可参照retme的&lt;a href=&#34;https://github.com/retme7/CVE-2014-7911_poc&#34;&gt;https://github.com/retme7/CVE-2014-7911_poc&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;DecStrong的汇编代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;PUSH            {R4-R6,LR}
MOV             R5, R0
LDR             R4, [R0,#4]             r4   = *(r0 + 4)
MOV             R6, R1
MOV             R0, R4
BLX             android_atomic_dec
CMP             R0, #1
BNE             loc_D184
LDR             R0, [R4,#8]             r0   = *(r4 + 8)
MOV             R1, R6
LDR             R3, [R0]                r3   = *(r0)
LDR             R2, [R3,#0xC]           r2   = *(r3 + 0xc)
BLX             R2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;native执行代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;static void android_os_BinderProxy_destroy(JNIEnv* env, jobject obj)
{
    IBinder* b = (IBinder*)
    env-&amp;gt;GetIntField(obj, gBinderProxyOffsets.mObject);
    DeathRecipientList* drl = (DeathRecipientList*)
    env-&amp;gt;GetIntField(obj, gBinderProxyOffsets.mOrgue);

    LOGDEATH(&amp;quot;Destroying BinderProxy %p: binder=%p drl=%p\n&amp;quot;, obj, b, drl);
    env-&amp;gt;SetIntField(obj, gBinderProxyOffsets.mObject, 0);
    env-&amp;gt;SetIntField(obj, gBinderProxyOffsets.mOrgue, 0);
    drl-&amp;gt;decStrong((void*)javaObjectForIBinder);
    b-&amp;gt;decStrong((void*)javaObjectForIBinder);

    IPCThreadState::self()-&amp;gt;flushCommands();
}

void RefBase::decStrong(const void* id) const
{
    weakref_impl* const refs = mRefs;
    refs-&amp;gt;removeStrongRef(id);
    const int32_t c = android_atomic_dec(&amp;amp;refs-&amp;gt;mStrong);
    ...
    if (c == 1) {
        refs-&amp;gt;mBase-&amp;gt;onLastStrongRef(id);
        if ((refs-&amp;gt;mFlags&amp;amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) {
            delete this;
        }
    }
    refs-&amp;gt;decWeak(id);
}

void RefBase::onLastWeakRef(const void* /*id*/)
{
}
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
  </channel>
</rss>