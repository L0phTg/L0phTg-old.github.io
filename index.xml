<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>L0phTg&#39;s Blog</title>
    <link>https://l0phtg.github.io/</link>
    <description>Recent content on L0phTg&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>l0phtg</copyright>
    <lastBuildDate>Mon, 20 Aug 2018 21:38:52 +0800</lastBuildDate>
    
        <atom:link href="https://l0phtg.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://l0phtg.github.io/about/</link>
      <pubDate>Mon, 20 Aug 2018 21:38:52 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/about/</guid>
      
        <description>&lt;p&gt;某邮电大学大四学生.&lt;/p&gt;

&lt;p&gt;like: c/c++, 操作系统, 编译原理.&lt;/p&gt;

&lt;p&gt;从事方向: 移动安全.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Kaleidoscope: 前五章总结</title>
      <link>https://l0phtg.github.io/post/llvm/kaleidoscope-%E5%89%8D%E4%BA%94%E7%AB%A0%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 15 Apr 2019 17:58:13 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/llvm/kaleidoscope-%E5%89%8D%E4%BA%94%E7%AB%A0%E6%80%BB%E7%BB%93/</guid>
      
        <description>&lt;p&gt;对前五章做了一个总结, 侧重Codegen部分.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;kaleidoscope支持的语法&#34;&gt;Kaleidoscope支持的语法&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;表达式运算&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;4+5;
5-1;
5*10;
10/5;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;函数定义&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;def bar(a) foo(a, 4.0) + bar(31337);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;函数调用&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;cos(1.234);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;if/then/else&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;extern foo();
extern bar();
def baz(x) if x then foo() else bar();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;for&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;extern putchard(char);
def printstar(n)
  for i = 1, i &amp;lt; n, 1.0 in
    putchard(42);  # ascii 42 = &#39;*&#39;

# print 100 &#39;*&#39; characters
printstar(100);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;词法分析&#34;&gt;词法分析&lt;/h1&gt;

&lt;p&gt;词法分析很简单. 我这里简单画了下处理的流程图.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/docs-pic/llvm/Lexer And Parser.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;具体的分析请看: &lt;a href=&#34;https://l0phtg.github.io/post/kaleidoscope-tutorial-introduction-and-lexer/&#34;&gt;Lexer and Parse&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;抽象语法树&#34;&gt;抽象语法树&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/docs-pic/llvm/AST.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;生成抽象语法树-ast&#34;&gt;生成抽象语法树(AST)&lt;/h1&gt;

&lt;p&gt;这块比较简单. 简单介绍下:&lt;/p&gt;

&lt;h2 id=&#34;expr的-ast-生成&#34;&gt;Expr的(AST)生成&lt;/h2&gt;

&lt;p&gt;我们对所有的表达式进行集中处理.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// expression
///   ::= primary binoprhs
///
static std::unique_ptr&amp;lt;ExprAST&amp;gt; ParseExpression() {
  auto LHS = ParsePrimary();
  if (!LHS)
    return nullptr;

  return ParseBinOpRHS(0, std::move(LHS));
}

static std::unique_ptr&amp;lt;ExprAST&amp;gt; ParsePrimary() {
  switch (CurTok) {
  default:
    return LogError(&amp;quot;unknown token when expecting an expression&amp;quot;);
  case tok_identifier:
    return ParseIdentifierExpr();
  case tok_number:
    return ParseNumberExpr();
  case &#39;(&#39;:
    return ParseParenExpr();
  case tok_if:
    return ParseIfExpr();
  case tok_for:
    return ParseForExpr();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ParseIdentifierExpr&lt;/code&gt;,&lt;code&gt;ParseNumberExpr&lt;/code&gt;和&lt;code&gt;ParseParenExpr&lt;/code&gt;的实现请参考: &lt;a href=&#34;https://l0phtg.github.io/post/llvm/kaleidoscope-implementing-a-parser-and-ast/&#34;&gt; Implementing a Parser and AST&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ParseIfExpr&lt;/code&gt;和&lt;code&gt;ParseForExpr&lt;/code&gt;的实现请参考: &lt;a href=&#34;https://l0phtg.github.io/post/llvm/kaleidoscope-extending-the-language-control-flow/&#34;&gt;Extending the Language Control Flow&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;函数定义和申明的ast生成&#34;&gt;函数定义和申明的AST生成&lt;/h2&gt;

&lt;p&gt;请参考:&lt;a href=&#34;https://l0phtg.github.io/post/llvm/kaleidoscope-implementing-a-parser-and-ast/&#34;&gt; Implementing a Parser and AST&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;codegen-产生llvm-ir&#34;&gt;Codegen(产生LLVM IR)&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/docs-pic/llvm/Codegen.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;四个基本表达式的codegen&#34;&gt;四个基本表达式的codegen&lt;/h2&gt;

&lt;p&gt;请参考: &lt;a href=&#34;https://l0phtg.github.io/post/llvm/kaleidoscope-code-generation-to-llvm-ir/&#34;&gt;code generation to llvm ir&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;if-then-else&#34;&gt;if/then/else&lt;/h2&gt;

&lt;h3 id=&#34;kaleidoscpe-if-then-else&#34;&gt;Kaleidoscpe: if/then/else&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;extern foo();
extern bar();
def baz(x) if x then foo() else bar();  // 如果 x != 0, then foo, else bar;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;未经优化的llvm-ir&#34;&gt;未经优化的LLVM IR&lt;/h3&gt;

&lt;p&gt;根据我们上面编写的Kaleidoscope的代码, 可以生成下面的LLVM IR.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;declare double @foo()

declare double @bar()

define double @baz(double %x) {
entry:
  %ifcond = fcmp one double %x, 0.000000e+00
  br i1 %ifcond, label %then, label %else

then:       ; preds = %entry
  %calltmp = call double @foo()
  br label %ifcont

else:       ; preds = %entry
  %calltmp1 = call double @bar()
  br label %ifcont

ifcont:     ; preds = %else, %then
  %iftmp = phi double [ %calltmp, %then ], [ %calltmp1, %else ] ; 返回值
  ret double %iftmp
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;ir解析&#34;&gt;IR解析&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;IR指令&lt;/th&gt;
&lt;th&gt;例子&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$\bold{fcmp}$&lt;/td&gt;
&lt;td&gt;$\color{red}{fcmp}$ $one$ $double$ ${x}$,   $0.0e+00$&lt;/td&gt;
&lt;td&gt;比较指令, 相等则返回 0, 不相等返回 1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{call}$&lt;/td&gt;
&lt;td&gt;$\color{red}{call}$    $double$ $@ foo()$&lt;/td&gt;
&lt;td&gt;调用函数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{br}$&lt;/td&gt;
&lt;td&gt;$\color{red}{br}$       ${label }$  ${\%ifcont}$&lt;/td&gt;
&lt;td&gt;直接跳转&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{br}$&lt;/td&gt;
&lt;td&gt;$\color{red}{br}$       $i1$  $\%ifcond$,  $label$  $\%then$,   $label$   $\%else$&lt;/td&gt;
&lt;td&gt;条件跳转&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{phi}$&lt;/td&gt;
&lt;td&gt;$\color{red}{phi}$     ${double [\% calltmp, \%then] }$, ${[\%calltmp1, \%else]}$&lt;/td&gt;
&lt;td&gt;调用${phi}$ 函数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{ret}$&lt;/td&gt;
&lt;td&gt;$\color{red}{ret}$     $double$ $\% 0$&lt;/td&gt;
&lt;td&gt;函数返回&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Label&lt;/th&gt;
&lt;th&gt;means&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$\bold{entry}$&lt;/td&gt;
&lt;td&gt;函数入口&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{then}$&lt;/td&gt;
&lt;td&gt;条件分支then&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{else}$&lt;/td&gt;
&lt;td&gt;条件分支else&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{ifcont}$&lt;/td&gt;
&lt;td&gt;结束条件分支&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;if-then-else-s-cfg&#34;&gt;if/then/else&amp;rsquo;s CFG&lt;/h3&gt;

&lt;p&gt;使用&lt;code&gt;opt -analyze -view-cfg if.bc&lt;/code&gt;生成的CFG.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/docs-pic/llvm/if.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;if-then-else-s-dominator-判断哪里需要插入phi函数&#34;&gt;if/then/else&amp;rsquo;s dominator (判断哪里需要插入phi函数)&lt;/h4&gt;

&lt;p&gt;这里只是对插入$\phi$函数时机的一个分析. (不想了解的壳跳过).&lt;/p&gt;

&lt;p&gt;根据我前面翻译的文章: &lt;a href=&#34;https://l0phtg.github.io/post/dominatorgraph-theory/&#34;&gt;Dominator&lt;/a&gt;来分析我们&lt;code&gt;if/then/else&lt;/code&gt;的控制流.&lt;/p&gt;

&lt;p&gt;我们将:  &lt;code&gt;entry&lt;/code&gt; 视为节点 $\bold{1}$。    &lt;code&gt;then&lt;/code&gt;视为节点 $\bold{2}$。&lt;/p&gt;

&lt;p&gt;​         &lt;code&gt;else&lt;/code&gt; 视为节点 $\bold{3}$。      &lt;code&gt;ifcont&lt;/code&gt;视为节点 $\bold{4}$。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;$\bold{1}$&lt;/th&gt;
&lt;th&gt;$\color{black}{dom}$&lt;/th&gt;
&lt;th&gt;$\color{Gray}{1}$&lt;/th&gt;
&lt;th&gt;$\color{Red}{2}$&lt;/th&gt;
&lt;th&gt;$\color{Red}{3}$&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$\bold{2}$&lt;/td&gt;
&lt;td&gt;$\color{black}{dom}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$\color{Gray}{2}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{3}$&lt;/td&gt;
&lt;td&gt;$\color{black}{dom}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$\color{Gray}{3}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{4}$&lt;/td&gt;
&lt;td&gt;$\color{black}{dom}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$\color{Gray}{4}$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;节点&lt;/th&gt;
&lt;th&gt;支配分析&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$\bold{1}$&lt;/td&gt;
&lt;td&gt;支配: 1, 2, 3, 4.    严格支配: 2, 3, 4.     直接支配: 2, 3.    支配边界: set().&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{2}$&lt;/td&gt;
&lt;td&gt;支配: 2.                 严格支配: 无.           直接支配: 无.       支配边界: set(4).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{3}$&lt;/td&gt;
&lt;td&gt;支配: 3.                 严格支配: 无.           直接支配: 无.       支配边界: set(4).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{4}$&lt;/td&gt;
&lt;td&gt;支配: 4.                 严格支配: 无.           直接支配: 无.       支配边界: set().&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;根据&lt;a href=&#34;https://l0phtg.github.io/post/llvm/static-single-assignment/&#34;&gt;SSA&lt;/a&gt;理论, 我们可以在 $\bold{4}$ 节点处插入 $\bold{\phi}$ 函数.&lt;/p&gt;

&lt;h3 id=&#34;builder创建ir指令&#34;&gt;Builder创建IR指令&lt;/h3&gt;

&lt;p&gt;用Builder来产生每条指令的IR.&lt;/p&gt;

&lt;p&gt;下面是一些&lt;code&gt;if/then/else&lt;/code&gt;会涉及到的&lt;code&gt;Builder创建指令的操作&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&#34;创建cmp指令&#34;&gt;创建cmp指令&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;CondV = Builder.CreateFCmpONE(
      CondV, ConstantFP::get(TheContext, APFloat(0.0)), &amp;quot;ifcond&amp;quot;);

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;创建条件br指令&#34;&gt;创建条件br指令&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Builder.CreateCondBr(CondV, ThenBB, ElseBB);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;创建直接br指令&#34;&gt;创建直接br指令&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Builder.CreateBr(MergeBB);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;创建phi指令&#34;&gt;创建phi指令&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;  PHINode *PN =
    Builder.CreatePHI(Type::getDoubleTy(TheContext), 2, &amp;quot;iftmp&amp;quot;);

  PN-&amp;gt;addIncoming(ThenV, ThenBB);
  PN-&amp;gt;addIncoming(ElseV, ElseBB);
  return PN;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;创建block&#34;&gt;创建Block&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;构造block时直接在&amp;rdquo;TheFunction&amp;rdquo;后面添加该block.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;BasicBlock *ThenBB =
    BasicBlock::Create(TheContext, &amp;quot;then&amp;quot;, TheFunction);
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;单纯创建Block, 当未添加到函数中.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;   BasicBlock *ElseBB = BasicBlock::Create(TheContext, &amp;quot;else&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;irbuilder中插入block&#34;&gt;IRBuilder中插入Block&lt;/h4&gt;

&lt;p&gt;控制流的独特性之处在于,  它有自己的内部的作用域(block). 所以我们在编写codegen代码时, 会调用内部block的codegen. 而不会直接去处理它.(内部block的codegen是它自己处理的, 不归我们的 ifExpr.Codegen管)&lt;/p&gt;

&lt;p&gt;所以我们会这样做:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Builder.SetInsertPoint(ThenBB);          // 将builder此时的插入点设置为ThenBB.
Value *ThenV = Then-&amp;gt;codegen();          // 调用 then block的codegen
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;将未添加的block添加到函数中&#34;&gt;将未添加的Block添加到函数中&lt;/h4&gt;

&lt;p&gt;在&amp;rdquo;TheFunction&amp;rdquo;后面添加&amp;rdquo;merge block&amp;rdquo;, 因为在我们创建时, 只是单纯的创建的block, 还未添加到函数中.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;  TheFunction-&amp;gt;getBasicBlockList().push_back(MergeBB); // TheFunction中添加Block
  Builder.SetInsertPoint(MergeBB); // IRBuilder中插入BB
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;builder流程图&#34;&gt;Builder流程图&lt;/h3&gt;

&lt;p&gt;生成if/then/else 的IR可以分为四个部分生成:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;cond

&lt;ol&gt;
&lt;li&gt;创建cmp IR. 目的是根据条件判断返回bool值.&lt;/li&gt;
&lt;li&gt;创建&lt;strong&gt;条件&lt;/strong&gt;跳转IR. 目的是根据返回的bool值做分支跳转.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;then

&lt;ol&gt;
&lt;li&gt;then.codegen(). 目的是进行then block的codegen.&lt;/li&gt;
&lt;li&gt;创建&lt;strong&gt;直接&lt;/strong&gt;跳转IR.目的是跳转到ifcond处.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;else

&lt;ol&gt;
&lt;li&gt;else.codegen(). 目的是进行else block的codegen.&lt;/li&gt;
&lt;li&gt;创建&lt;strong&gt;直接跳转&lt;/strong&gt;IR,目的是跳转到ifcond处.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;ifcond(分支合并后):

&lt;ol&gt;
&lt;li&gt;创建phi函数调用IR. 目的是判断我们是从哪个分支跳转来的.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;, 这里不会涉及&lt;code&gt;ret&lt;/code&gt;指令的&lt;strong&gt;codegen&lt;/strong&gt; ,我们在&lt;code&gt;ifExprAST&lt;/code&gt;中最后做的仅仅是将$\bold{\phi}$函数的返回值返回.  &lt;code&gt;ret&lt;/code&gt;指令的&lt;strong&gt;codegen&lt;/strong&gt;应该在&lt;code&gt;函数&lt;/code&gt;的&lt;strong&gt;codegen&lt;/strong&gt;时做.&lt;/p&gt;

&lt;p&gt;(在上文例子中, &lt;code&gt;ret&lt;/code&gt;指令的&lt;strong&gt;codegen&lt;/strong&gt; 是&lt;strong&gt;baz&lt;/strong&gt;函数生成的)&lt;/p&gt;

&lt;div class=&#34;mermaid&#34;&gt;
graph TD
    Start(&#34;If Codegen&#34;)
    builderCreateCmp[&#34;Builder.CreateCmpOne&#34;]
    builderCreateCond[&#34;Builder.CreateCondBr&#34;]
    Start --&gt; builderCreateCmp
    builderCreateCmp --&gt; builderCreateCond
    
    subgraph Then
        builderSetInsertThenBB[&#34;Builder.SetInsertPoint(ThenBB);&#34;]
        ThenCodegen[&#34;Then-&gt;codegen();&#34;]
        builderCreateBr1[&#34;Builder.CreateBr&#34;]
        builderSetInsertThenBB --&gt; ThenCodegen
        ThenCodegen --&gt; builderCreateBr1
    end
    
    builderCreateCond --&gt; builderSetInsertThenBB
    
    subgraph Else
        builderSetInsertElseBB[&#34;Builder.SetInsertPoint(ElseBB);&#34;]
        ElseCodegen[&#34;Else-&gt;codegen();&#34;]
        builderCreateBr2[&#34;Builder.CreateBr&#34;]
        builderSetInsertElseBB --&gt; ElseCodegen
        ElseCodegen --&gt; builderCreateBr2
    end
    
    builderCreateBr1 --&gt; builderSetInsertElseBB
    
    subgraph Merge
        builderSetInsertIfcontBB[&#34;Builder.SetInsertPoint(MergeBB);&#34;]
        builderCreatePHI[&#34;Builder.CreatePHI&#34;]
        builderSetInsertIfcontBB --&gt; builderCreatePHI
    end
    
    builderCreateBr2 --&gt; builderSetInsertIfcontBB
    
    builderCreatePHI --&gt; End(&#34;End Codegen&#34;)
    
    style builderSetInsertThenBB fill:#ffcc66
    style builderSetInsertElseBB fill:#ffcc66
    style builderSetInsertIfcontBB fill:#ffcc66
    
    style ThenCodegen fill:#ff66cc
    style ElseCodegen fill:#ff66cc
    
    style Start fill:#ff9966
    style End fill:#ff9966
&lt;/div&gt;

&lt;h2 id=&#34;loop&#34;&gt;Loop&lt;/h2&gt;

&lt;h3 id=&#34;kaleidoscope-for&#34;&gt;Kaleidoscope: for&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;extern putchard(char);
def printstar(n)
  for i = 1, i &amp;lt; n, 1.0 in
    putchard(42);  # ascii 42 = &#39;*&#39;

# print 100 &#39;*&#39; characters
printstar(100);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;未经优化的llvm-ir-1&#34;&gt;未经优化的LLVM IR&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;declare double @putchard(double)

define double @printstar(double %n) {
entry:
  ; initial value = 1.0 (inlined into phi)
  br label %loop

loop:       ; preds = %loop, %entry
  %i = phi double [ 1.000000e+00, %entry ], [ %nextvar, %loop ]
  ; body
  %calltmp = call double @putchard(double 4.200000e+01)
  ; increment
  %nextvar = fadd double %i, 1.000000e+00

  ; termination test
  %cmptmp = fcmp ult double %i, %n
  %booltmp = uitofp i1 %cmptmp to double
  %loopcond = fcmp one double %booltmp, 0.000000e+00
  br i1 %loopcond, label %loop, label %afterloop

afterloop:      ; preds = %loop
  ; loop always returns 0.0
  ret double 0.000000e+00
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有三个&lt;code&gt;Label&lt;/code&gt;, 意味者三个&lt;code&gt;BasicBlock&lt;/code&gt;: &lt;strong&gt;entry&lt;/strong&gt;,  &lt;strong&gt;loop&lt;/strong&gt;,  &lt;strong&gt;afterloop&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;有四个主要的&lt;code&gt;Expression&lt;/code&gt;: &lt;strong&gt;Start&lt;/strong&gt;, &lt;strong&gt;Cond&lt;/strong&gt;, &lt;strong&gt;Body&lt;/strong&gt;, &lt;strong&gt;Increment&lt;/strong&gt; .  当然还有&lt;strong&gt;afterloop&lt;/strong&gt;, 它总是&lt;code&gt;ret 0.0&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;ir解析-1&#34;&gt;IR解析&lt;/h4&gt;

&lt;p&gt;与&lt;code&gt;if/then/else&lt;/code&gt;的&lt;strong&gt;IR&lt;/strong&gt;指令相比较, 发现多了一条$\bold{uitofp}$指令.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;IR指令&lt;/th&gt;
&lt;th&gt;例子&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$\bold{fcmp}$&lt;/td&gt;
&lt;td&gt;$\color{red}{fcmp}$ $one$ $double$ ${\%booltmp}$,   $0.0e+00$&lt;/td&gt;
&lt;td&gt;比较指令, 相等则返回 0, 不相等返回 1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{call}$&lt;/td&gt;
&lt;td&gt;$\color{red}{call}$    $double$ $@ putchard(double$   $ 4.2000e+01)$&lt;/td&gt;
&lt;td&gt;调用函数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{br}$&lt;/td&gt;
&lt;td&gt;$\color{red}{br}$       ${label }$  ${\%loop}$&lt;/td&gt;
&lt;td&gt;直接跳转&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{br}$&lt;/td&gt;
&lt;td&gt;$\color{red}{br}$       $i1$  $\%loopcond$  $label$  $\%loop$,  $label$  $\%afterloop$&lt;/td&gt;
&lt;td&gt;条件跳转&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{phi}$&lt;/td&gt;
&lt;td&gt;$\color{red}{phi}$     ${double [1.0e+0, \%entry] }$, ${[\%nextvar, \%loop]}$&lt;/td&gt;
&lt;td&gt;调用${phi}$ 函数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{uitofp}$&lt;/td&gt;
&lt;td&gt;$\color{red}{uitofp}$ $i1$    $\%cmptmp$   $to$   $double$&lt;/td&gt;
&lt;td&gt;将bool(&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;0&lt;/sub&gt;)转换为double(1.0/0.0)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{ret}$&lt;/td&gt;
&lt;td&gt;$\color{red}{ret}$     $double$ $\% 0$&lt;/td&gt;
&lt;td&gt;函数返回&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Label&lt;/th&gt;
&lt;th&gt;means&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$\bold{entry}$&lt;/td&gt;
&lt;td&gt;函数入口&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{loop}$&lt;/td&gt;
&lt;td&gt;loop循环入口&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{afterloop}$&lt;/td&gt;
&lt;td&gt;loop循环结束&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;for-s-cfg&#34;&gt;for&amp;rsquo;s CFG&lt;/h3&gt;

&lt;p&gt;使用&lt;code&gt;opt -analyze -view-cfg loop.bc&lt;/code&gt;生成的CFG.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/docs-pic/llvm/loop.png&#34; alt=&#34;loop&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;builder流程图-1&#34;&gt;Builder流程图&lt;/h3&gt;

&lt;div class=&#34;mermaid&#34;&gt;
graph TB

    Start(&#34;Loop Codegen&#34;) --&gt; StartCodegen[&#34;Start-&gt;codegen();&#34;]
    StartCodegen --&gt; builderCreateBr[&#34;Builder.CreateBr&#34;]
    subgraph Loop
        builderSetInsertLoopBB[&#34;Builder.SetInsertPoint(LoopBB)&#34;]    
        builderCreatePHI[&#34;Builder.CreatePHI&#34;]
        BodyCodegen[&#34;Body-&gt;codegen();&#34;]

        builderSetInsertLoopBB --&gt; builderCreatePHI
        builderCreatePHI --&gt; BodyCodegen
        BodyCodegen --&gt; ifStep{&#34;Step != NULL&#34;}
        ifStep --Y--&gt; StepCodegen[&#34;Step-&gt;codegen();&#34;]
        ifStep --N--&gt; SetStep[&#34;Set Step to 1.0&#34;]
        StepCodegen --&gt; builderCreateFAdd[&#34;Builder.CreateFAdd&#34;]
        SetStep --&gt; builderCreateFAdd

        builderCreateFAdd --&gt; EndCodegen[&#34;End-&gt;codegen();&#34;] 
        EndCodegen --&gt; builderCreateFCmp[&#34;Builder.CreateFCmpOne&#34;] 
        builderCreateFCmp --&gt; builderCreateCondBr[&#34;Builder.CreateCondBr&#34;]
    end 

    builderCreateBr --&gt; builderSetInsertLoopBB

    subgraph afterloop
        builderSetInsertAfterBB[&#34;Builder.SetInsertPoint(AfterBB)&#34;]
    end 
    
    builderCreateCondBr --&gt; builderSetInsertAfterBB
    
    builderSetInsertAfterBB --&gt; End[&#34;End Codegen&#34;]


    style builderSetInsertLoopBB fill:#ffcc66
    style builderSetInsertAfterBB fill:#ffcc66

    
    style StartCodegen fill:#ff66cc
    style BodyCodegen fill:#ff66cc
    style StepCodegen fill:#ff66cc
    style EndCodegen fill:#ff66cc
    
    style Start fill:#ff9966
    style End fill:#ff9966

&lt;/div&gt;

&lt;h1 id=&#34;jit和优化&#34;&gt;JIT和优化&lt;/h1&gt;

&lt;p&gt;参考: &lt;a href=&#34;https://l0phtg.github.io/post/llvm/kaleidoscope-adding-jit-and-optimizer-support/&#34;&gt;Adding JIT and Optimizer Support&lt;/a&gt;&lt;/p&gt;

&lt;div class=&#34;mermaid&#34;&gt;
graph TB

    subgraph call
        funcall(&#34;foo(1);&#34;)
    end

    subgraph expr
        nodeExpr(&#34;1+2;&#34;)
    end
    
    jitAddModule[&#34;JIT中 添加此Module&#34;]
    jitRemoveModule[&#34;JIT中 删除此Module&#34;]
    
    anoCodegen[&#34;执行 匿名函数Codegen&#34;]
    AnonymousCall[&#34;匿名函数包装&#34;]
    optimizeFunc[&#34;执行 Pass优化&#34;]
    nodeExpr --&gt; AnonymousCall
    funcall --&gt; AnonymousCall
    AnonymousCall --&gt; anoCodegen
    anoCodegen --&gt; jitAddModule
    jitAddModule --&gt; optimizeFunc
    optimizeFunc --&gt; exec[&#34;jit运行此表达式, 并计算值&#34;]
    exec --&gt; jitRemoveModule
    
    subgraph func definition
        nodeFoo(&#34;def foo(x) x+1;&#34;)
        funcCodegen[&#34;执行 函数定义Codegen&#34;]
        nodeFoo --&gt; funcCodegen
    end
    
    funcCodegen --&gt; jitAddFuncModule[&#34;jit中 添加此Module&#34;]
    jitAddFuncModule --&gt; initPassManager[&#34;执行 pass优化&#34;]


    subgraph extern
        nodeExtern(&#34;extern sin(x);&#34;)
        protoCodegen[&#34;执行 函数申明Codegen&#34;]
        nodeExtern --&gt; protoCodegen
    end
    
    style jitAddModule fill:#f9f
    style jitRemoveModule fill:#f9f
    style jitAddFuncModule fill:#f9f
    
    style optimizeFunc fill:#ccff66
    style initPassManager fill:#ccff66
    
    style exec fill:#ff3300
    
&lt;/div&gt;

&lt;h1 id=&#34;driver&#34;&gt;Driver&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// top ::= definition | external | expression | &#39;;&#39;
static void MainLoop() {
  while (true) {
    fprintf(stderr, &amp;quot;ready&amp;gt; &amp;quot;);
    switch (CurTok) {
    case tok_eof:
      return;
    case &#39;;&#39;: // ignore top-level semicolons.
      getNextToken();
      break;
    case tok_def:
      HandleDefinition();
      break;
    case tok_extern:
      HandleExtern();
      break;
    default:
      HandleTopLevelExpression();
      break;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>书签整理</title>
      <link>https://l0phtg.github.io/post/life/%E4%B9%A6%E7%AD%BE%E6%95%B4%E7%90%86/</link>
      <pubDate>Mon, 15 Apr 2019 10:13:04 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/life/%E4%B9%A6%E7%AD%BE%E6%95%B4%E7%90%86/</guid>
      
        <description>&lt;p&gt;昨晚闲得无聊, 整理了一下自己的chrome书签.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/life/bookmark-update.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Kaleidoscope: Extending the Language Control Flow</title>
      <link>https://l0phtg.github.io/post/llvm/kaleidoscope-extending-the-language-control-flow/</link>
      <pubDate>Sun, 14 Apr 2019 14:43:17 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/llvm/kaleidoscope-extending-the-language-control-flow/</guid>
      
        <description>&lt;p&gt;translate from: &lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl05.html&#34;&gt;http://llvm.org/docs/tutorial/LangImpl05.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文为Kaleidoscope添加条件判断控制流和循环控制流.&lt;/p&gt;

&lt;p&gt;注意: 本文假定你已经阅读过前面几篇文章, 所以在词法解析和AST生成就写的比较简单(当然了, 这部分内容本身阅读起来就比较轻松), 着重介绍控制流的Codegen部分.&lt;/p&gt;

&lt;p&gt;因为这个系列主要是翻译, 所以基本没有涉及自己的理解. &lt;strong&gt;之后我会单独写一篇文章, 来对Kaleidoscope的前五章做一个总结&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/docs-pic/llvm/loop.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;chapter-5-introduction&#34;&gt;Chapter 5 Introduction&lt;/h1&gt;

&lt;p&gt;Welcome to Chapter 5 of the &amp;ldquo;Implementing a language with LLVM &amp;rdquo; tutorial.&lt;/p&gt;

&lt;p&gt;第一章到第四章描述了Kaleidoscope的简单的实现并且支持了LLVM IR的生成, 然后是优化和JIT编译器.&lt;/p&gt;

&lt;p&gt;不幸地是, 正如你现在现在看到的, Kaleidoscope 是几乎无用的:&lt;/p&gt;

&lt;p&gt;​   除了调用和返回之外, 它没有其他控制流. 这意味着你在代码中没有条件分支, 从而限制了它的功能.&lt;/p&gt;

&lt;p&gt;在本期 构建编译器中, 我们将会扩展Kaleidoscope, 使它拥有 &lt;strong&gt;if/then/else表达式&lt;/strong&gt;和一个简单的 &lt;strong&gt;for 循环&lt;/strong&gt;.&lt;/p&gt;

&lt;h1 id=&#34;if-then-else&#34;&gt;if/Then/Else&lt;/h1&gt;

&lt;p&gt;扩展Kaleidoscope来支持if/then/else是相当直接的. 它基本上就是为&lt;strong&gt;词法分析器, 解析器, AST, LLVM Code emitter&lt;/strong&gt;增加新的概念.&lt;/p&gt;

&lt;p&gt;例子是很不错的, 因为它表明了&lt;code&gt;随着时间的推移, 根据新的概念来对语言进行扩展是多么的容易&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;在我们进行扩展之前, 让我们讨论一下我们到底想要做什么.&lt;/p&gt;

&lt;p&gt;基本的意思是我们想要能够写出这样的代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;def fib(x)
  if x &amp;lt; 3 then
    1
  else
    fib(x-1)+fib(x-2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Kaleidoscope中, 每个构造都是一个表达式: 没有语句. 因此, &lt;strong&gt;if/then/else&lt;/strong&gt; 表达式需要像其他表达式一样返回值. 由于我们正在使用一个普遍的功能形式, 我们会计算它的条件, 然后根据条件的解析方式返回 &lt;strong&gt;then&lt;/strong&gt;或&lt;strong&gt;else&lt;/strong&gt;值.&lt;/p&gt;

&lt;p&gt;if/then/else的表达式的语义是: &lt;code&gt;它能够将条件计算为一个bool等价的值&lt;/code&gt;: 0.0被认为是false, everything else被认为是true. 如果条件为true, 则计算并返回第一个子表达式值; 如果条件为false, 则计算并返回第二个表达式值. 由于Kaleidoscope 允许产生副作用, 所以将该行为确定下来是非常重要的.&lt;/p&gt;

&lt;p&gt;现在我们知道了我们想要做什么, 下面让我们一起了解它的组成部分.&lt;/p&gt;

&lt;h2 id=&#34;if-then-else的lexer扩展&#34;&gt;if/then/else的Lexer扩展&lt;/h2&gt;

&lt;p&gt;词法分析扩展是相当直接的. 首先我们&lt;strong&gt;为新的tokens增加新的enum值&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// control
tok_if = -6,
tok_then = -7,
tok_else = -8,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一旦我们有了它们 我们就意识到了在词法分析器中有了新的&lt;strong&gt;keywords(关键字)&lt;/strong&gt;. This is pretty simple stuff:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;...
if (IdentifierStr == &amp;quot;def&amp;quot;)
  return tok_def;
if (IdentifierStr == &amp;quot;extern&amp;quot;)
  return tok_extern;
if (IdentifierStr == &amp;quot;if&amp;quot;)
  return tok_if;
if (IdentifierStr == &amp;quot;then&amp;quot;)
  return tok_then;
if (IdentifierStr == &amp;quot;else&amp;quot;)
  return tok_else;
return tok_identifier;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;if-then-else的ast-扩展&#34;&gt;if/then/else的AST 扩展&lt;/h2&gt;

&lt;p&gt;if/then/else 属于表达式, 所以==IfExprAST==继承自==ExprAST==.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// IfExprAST - Expression class for if/then/else.
class IfExprAST : public ExprAST {
  std::unique_ptr&amp;lt;ExprAST&amp;gt; Cond, Then, Else;

public:
  IfExprAST(std::unique_ptr&amp;lt;ExprAST&amp;gt; Cond, std::unique_ptr&amp;lt;ExprAST&amp;gt; Then,
            std::unique_ptr&amp;lt;ExprAST&amp;gt; Else)
    : Cond(std::move(Cond)), Then(std::move(Then)), Else(std::move(Else)) {}

  Value *codegen() override;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;if-then-else的parser扩展&#34;&gt;if/then/else的parser扩展&lt;/h2&gt;

&lt;p&gt;现在我们有了词法分析的tokens和AST节点, 我们现在的解析逻辑就相当直接了.&lt;/p&gt;

&lt;p&gt;首先我们定义一个新的解析函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/// ifexpr ::= &#39;if&#39; expression &#39;then&#39; expression &#39;else&#39; expression
static std::unique_ptr&amp;lt;ExprAST&amp;gt; ParseIfExpr() {
  getNextToken();  // eat the if.

  // condition.
  auto Cond = ParseExpression();
  if (!Cond)
    return nullptr;

  if (CurTok != tok_then)
    return LogError(&amp;quot;expected then&amp;quot;);
  getNextToken();  // eat the then

  auto Then = ParseExpression();
  if (!Then)
    return nullptr;

  if (CurTok != tok_else)
    return LogError(&amp;quot;expected else&amp;quot;);

  getNextToken();

  auto Else = ParseExpression();
  if (!Else)
    return nullptr;

  return llvm::make_unique&amp;lt;IfExprAST&amp;gt;(std::move(Cond), std::move(Then),
                                      std::move(Else));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们将它与primay expression连接起来:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;static std::unique_ptr&amp;lt;ExprAST&amp;gt; ParsePrimary() {
  switch (CurTok) {
  default:
    return LogError(&amp;quot;unknown token when expecting an expression&amp;quot;);
  case tok_identifier:
    return ParseIdentifierExpr();
  case tok_number:
    return ParseNumberExpr();
  case &#39;(&#39;:
    return ParseParenExpr();
  case tok_if:
    return ParseIfExpr();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;if-then-else的llvm-ir&#34;&gt;if/then/else的LLVM IR&lt;/h2&gt;

&lt;p&gt;现在我们已经解析完成并且建立了抽象语法树, 最后的内容是增加==LLVM code generation support==. 这是 if/else/then的例子中最有趣的地方, &lt;strong&gt;因为它开始引入了新的概念&lt;/strong&gt;. 上面所有的代码都在以前的章节详细介绍过.&lt;/p&gt;

&lt;p&gt;为了产生我们想要得到的代码. 让我们看一个简单的例子. Consider:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;extern foo();
extern bar();
def baz(x) if x then foo() else bar();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果禁用优化, 你可以看到生成的IR是下面这样的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;declare double @foo()

declare double @bar()

define double @baz(double %x) {
entry:
  %ifcond = fcmp one double %x, 0.000000e+00
  br i1 %ifcond, label %then, label %else

then:       ; preds = %entry
  %calltmp = call double @foo()
  br label %ifcont

else:       ; preds = %entry
  %calltmp1 = call double @bar()
  br label %ifcont

ifcont:     ; preds = %else, %then
  %iftmp = phi double [ %calltmp, %then ], [ %calltmp1, %else ] ; 返回值
  ret double %iftmp
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了使流程图可视化:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;你能够使用LLVM &lt;strong&gt;opt&lt;/strong&gt; tool的一个漂亮的功能. 如果你将LLVM IR放到 &amp;ldquo;t.ll&amp;rdquo;中, 并且运行 &lt;code&gt;llvm-as &amp;lt; t.ll | opt -analyze -view-cfg&lt;/code&gt;, 一个window将会弹出, 并且你将会看到这幅图:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/docs-pic/llvm/if.png&#34; alt=&#34;if CFG&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;另一种方法: 可以通过调用 &lt;code&gt;F-&amp;gt;viewCFG()&lt;/code&gt; 或者&lt;code&gt;F-&amp;gt;viewCFGOnly()&lt;/code&gt;(where F is a &amp;ldquo;Function&amp;rdquo;)通过插入实际的调用到代码中并且重新编译, 可以得到我们想要的CFG图. 或者通过在编译器中调用他们. LLVM具有许多很友好的特性来可视化出各种各样的图形.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;回到我们的Codegen代码中, 它是相当简单地:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The entry block&lt;/strong&gt;: 计算条件表达式 (在我们的例子中是&amp;rdquo;x&amp;rdquo; ) 并且使用==fcmp one==指令将&lt;strong&gt;result&lt;/strong&gt;与&lt;strong&gt;0.0&lt;/strong&gt;相比较 ( &lt;strong&gt;one&lt;/strong&gt; 表示有序并且不相等). 基于该表达式的结果, 代码跳转到&lt;strong&gt;then block&lt;/strong&gt; 或者 &lt;strong&gt;else block&lt;/strong&gt;, which 包含 true/false cases的表达式.&lt;/p&gt;

&lt;p&gt;一旦 &lt;strong&gt;then/else block&lt;/strong&gt;执行完成了, 他们都返回到&lt;strong&gt;&amp;ldquo;ifcont&amp;rdquo; block&lt;/strong&gt;来执行 if/then/else 之后发生的代码. 在这种情况下, 唯一要做的事情就是返回到函数的调用者.&lt;/p&gt;

&lt;p&gt;现在我们的问题是: &lt;code&gt;代码是如何知道哪一个表达式要返回的呢?&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个问题的答案涉及重要的&lt;strong&gt;SSA 操作&lt;/strong&gt;: &lt;a href=&#34;https://en.wikipedia.org/wiki/Static_single_assignment_form&#34;&gt;the Phi operation&lt;/a&gt;(或者看我之前翻译的文章: &lt;a href=&#34;https://l0phtg.github.io/post/llvm/static-single-assignment/&#34;&gt;Staitc Single Assignment&lt;/a&gt;). 如果你不熟悉SSA, &lt;a href=&#34;https://en.wikipedia.org/wiki/Static_single_assignment_form&#34;&gt;the wikipedia article&lt;/a&gt;是一个很不错的入门并且你最喜欢的搜索引擎上各种其它的介绍.&lt;/p&gt;

&lt;p&gt;一个简单的对$phi$ 函数执行的介绍是: &lt;code&gt;可以确定我们是从哪一个表达式返回的&lt;/code&gt;. &lt;strong&gt;The phi operation&lt;/strong&gt;采用与输入控制块相对应的value.&lt;/p&gt;

&lt;p&gt;在这个例子中, 如果控制来自 &lt;strong&gt;&amp;ldquo;then&amp;rdquo; block&lt;/strong&gt;, 则它获得&lt;strong&gt;calltmp&lt;/strong&gt;的值.&lt;/p&gt;

&lt;p&gt;如果控制来自&lt;strong&gt;&amp;ldquo;else&amp;rdquo; block&lt;/strong&gt;, 它获得&lt;strong&gt;calltmp1&lt;/strong&gt;的值.&lt;/p&gt;

&lt;p&gt;此刻, 你可能已经开始思考了. &amp;ldquo;Oh no!&amp;rdquo; 这意味着我的简单优雅的前端必须开始生成SSA 才能使用LLVM. 幸运地是, 我们强烈建议不要在你的前端实现SSA构造算法除非你有一个非常好的理由这样做. 实际上,  对于你的命令行式编程语言来说,出现下面这两种情况时, 这表明此刻可能需要Phi nodes:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;代码涉及用户变量: x = 1; x = x + 1;&lt;/li&gt;
&lt;li&gt;Values可能隐式地在AST结构中, 例如在本例子中的Phi node.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在&lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl07.html&#34;&gt;第七章&lt;/a&gt;  (&amp;ldquo;多元变量&amp;rdquo;), 我们将讨论第一种情况. 现在, 请相信我你不需要SSA构造来处理这种情况.&lt;/p&gt;

&lt;p&gt;对于第二种情况, 你可以选择使用我们将为 #1描述的技术. 或者你能直接插入Phi 节点(如果方便的话).&lt;/p&gt;

&lt;p&gt;在我们这个例子中 产生 Phi code真的是简单的, 所以我们选择直接插入Phi节点.&lt;/p&gt;

&lt;p&gt;Okay. 我们已经了解了足够多, 让我们生成代码吧.&lt;/p&gt;

&lt;h2 id=&#34;if-then-else-的代码产生&#34;&gt;if/then/else 的代码产生&lt;/h2&gt;

&lt;p&gt;为了产生代码, 我们需要实现&lt;strong&gt;IfExpAST&lt;/strong&gt;的codegen方法.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Value *IfExprAST::codegen() {
  Value *CondV = Cond-&amp;gt;codegen();
  if (!CondV)
    return nullptr;

  // Convert condition to a bool by comparing non-equal to 0.0.
  // 转换条件到一个bool值. 
  CondV = Builder.CreateFCmpONE(
      CondV, ConstantFP::get(TheContext, APFloat(0.0)), &amp;quot;ifcond&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码很直接, 和我们之前看到的类似. 我们 emit the expression for the condition, 然后将值与0进行比较, 得到bool值.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Function *TheFunction = Builder.GetInsertBlock()-&amp;gt;getParent();

// Create blocks for the then and else cases.  Insert the &#39;then&#39; block at the
// end of the function.
// 创建then and else case的blocks. 
// 插入 &#39;then&#39; block在函数的最后

BasicBlock *ThenBB =
    BasicBlock::Create(TheContext, &amp;quot;then&amp;quot;, TheFunction);
BasicBlock *ElseBB = BasicBlock::Create(TheContext, &amp;quot;else&amp;quot;);
BasicBlock *MergeBB = BasicBlock::Create(TheContext, &amp;quot;ifcont&amp;quot;);

Builder.CreateCondBr(CondV, ThenBB, ElseBB);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个代码创建与 &lt;strong&gt;if/then/else&lt;/strong&gt;语句相关的&lt;strong&gt;basic block&lt;/strong&gt;, 并且直接对应于上例中的块.&lt;/p&gt;

&lt;p&gt;第一行获取当前正在构建的&lt;strong&gt;Function&lt;/strong&gt;对象: 它通过询问&lt;strong&gt;Builder&lt;/strong&gt;当前的&lt;strong&gt;BasicBlock&lt;/strong&gt;, 并询问当前&lt;strong&gt;Block的parent&lt;/strong&gt;, 来获取此信息.&lt;/p&gt;

&lt;p&gt;获得函数之后, 我们会创建三个Blocks. 注意: 它传递&amp;rdquo;TheFunction&lt;strong&gt;到&amp;rdquo;then&amp;rdquo;block的构造器中&lt;/strong&gt;. &lt;code&gt;这会导致构造函数会自动地在指定的函数中插入new block&lt;/code&gt;. &lt;strong&gt;其他的两个block被创建, 但是还没有被插入&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;一旦&lt;strong&gt;block&lt;/strong&gt;被创建, 我们就可以&lt;code&gt;emit the 在它们之间选择的条件分支&lt;/code&gt;. 注意, 创建新的&lt;strong&gt;block&lt;/strong&gt;不会隐式地影响&lt;strong&gt;IRBuilder&lt;/strong&gt;, 因此它仍然可以插入条件到进入的块中.  另外要注意, 它正在&lt;code&gt;创建到&amp;quot;then&amp;quot;block和&amp;quot;else&amp;quot;block的分支&lt;/code&gt;, 即使&amp;rdquo;else&amp;rdquo;block还未插入到函数中.&lt;/p&gt;

&lt;p&gt;This is all ok. 它是LLVM支持==forward references==的标准方法.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Emit then value.       
Builder.SetInsertPoint(ThenBB);

Value *ThenV = Then-&amp;gt;codegen();
if (!ThenV)
  return nullptr;

Builder.CreateBr(MergeBB);
// Codegen of &#39;Then&#39; can change the current block, update ThenBB for the PHI.
// &#39;Then&#39;的Codegen会改变目前的block, update ThenBB for the PHI.
ThenBB = Builder.GetInsertBlock();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在条件分支被插入之后, 我们move the builder来插入&amp;rdquo;then&amp;rdquo;block. 严格上来说, this call移动插入点到指定block的end. 然而, 由于 &amp;ldquo;then&amp;rdquo; block是空的, 所以它就会从block的开始进行插入.&lt;/p&gt;

&lt;p&gt;一旦插入点被设置了, 我们可以递归地从AST中codegen the &amp;ldquo;then&amp;rdquo;表达式. 为了完成&amp;rdquo;then&amp;rdquo;块, 我们为合并块创建了一个无条件分支.&lt;/p&gt;

&lt;p&gt;LLVM IR一个有趣的方面是&lt;strong&gt;它要求所有的BasicBlock都用控制流指令来中止(Ex: return and branch)&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;这意味着所有的控制流, including fall throughs, 必须在LLVM IR中被显示地指定. 如果违反此规则, 验证程序会报错.&lt;/p&gt;

&lt;p&gt;这里的最后一行相当&lt;strong&gt;微妙&lt;/strong&gt;, 但是是非常重要的. 基本问题就是当我们在&lt;strong&gt;merge block&lt;/strong&gt;中创建 Phi node时, 我们需要设置 &lt;strong&gt;block/value pairs&lt;/strong&gt; 来表明Phi是如何工作的. 重要的 , The Phi node 期待在CFG的块中每一个前节点都有一个entry.&lt;/p&gt;

&lt;p&gt;那么, 为什么在第 5 行, 我们设置ThenBB为获取当前块呢?  &amp;ldquo;Then&amp;rdquo;表达式实际上可能会改变当前的block.  例如, 它包含了一个嵌套的&amp;rdquo;if/then/else&amp;rdquo;表达式. 因为递归地调用codegen()会任意改变当前块的notion, 我们需要得到将要设置的Phi node代码的最新值.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// Emit else block. 
TheFunction-&amp;gt;getBasicBlockList().push_back(ElseBB);
Builder.SetInsertPoint(ElseBB);

Value *ElseV = Else-&amp;gt;codegen();
if (!ElseV)
  return nullptr;

Builder.CreateBr(MergeBB);
// codegen of &#39;Else&#39; can change the current block, update ElseBB for the PHI.
ElseBB = Builder.GetInsertBlock();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&amp;lsquo;else&amp;rsquo;&lt;/strong&gt;代码块的codegen与&lt;strong&gt;&amp;lsquo;then&amp;rsquo; block&lt;/strong&gt;的codegen基本相同. 唯一的显著差异是第一行: 它将&amp;rdquo;else&amp;rdquo;block 添加到函数中. 回想之前, 我们已经创建了&amp;rsquo;else&amp;rsquo;块, 但未添加到该函数中.&lt;/p&gt;

&lt;p&gt;现在&lt;strong&gt;then&lt;/strong&gt; 和 &lt;strong&gt;else&lt;/strong&gt; 代码块的IR都已经产生了, 我们现在可以完成我们的&lt;strong&gt;Merge&lt;/strong&gt;代码了.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;  // Emit merge block.
  TheFunction-&amp;gt;getBasicBlockList().push_back(MergeBB);
  Builder.SetInsertPoint(MergeBB);
  PHINode *PN =
    Builder.CreatePHI(Type::getDoubleTy(TheContext), 2, &amp;quot;iftmp&amp;quot;);

  PN-&amp;gt;addIncoming(ThenV, ThenBB);
  PN-&amp;gt;addIncoming(ElseV, ElseBB);
  return PN;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开始的两行是相似的: 第一行添加 &lt;strong&gt;&amp;ldquo;merge&amp;rdquo; block&lt;/strong&gt;到&lt;strong&gt;function object&lt;/strong&gt;中(之前merge block被创建之后, 还没有插入函数中). 第二行改变插入点位置, 所以新的codegen的代码会在&lt;strong&gt;Merge Block&lt;/strong&gt;中. 一旦做完这些之后, 我们需要创建PHI node并且给phi 节点设置一组值(block/value pairs).&lt;/p&gt;

&lt;p&gt;最后, CodeGen函数返回 phi nodes作为if/then/else表达式计算的值. 在我们上面的例子中, 返回值将会提供给顶级函数的代码中, 该函数将会创建返回指令.&lt;/p&gt;

&lt;p&gt;总的来说, 我们现在能够在Kaleidoscope中执行条件代码. 加入这项扩展之后, Kaleidoscope是一个相当完整的语言(因为它可以计算大量的数值函数).&lt;/p&gt;

&lt;p&gt;下一步我们将会添加另一个有用的表达式 that is familiar from non-functional languages.&lt;/p&gt;

&lt;h1 id=&#34;for-loop-expression&#34;&gt;&amp;lsquo;for&amp;rsquo; Loop Expression&lt;/h1&gt;

&lt;p&gt;现在我们知道了如何在语言中添加基本的控制流, 我们有了一些工具来添加更多强大的功能.&lt;/p&gt;

&lt;p&gt;让我们来做一些更有趣的, &lt;strong&gt;&amp;lsquo;for&amp;rsquo; expression&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;extern putchard(char);
def printstar(n)
  for i = 1, i &amp;lt; n, 1.0 in
    putchard(42);  # ascii 42 = &#39;*&#39;

# print 100 &#39;*&#39; characters
printstar(100);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在此例中, 这个表达式定义的一个新的变量(&amp;ldquo;i&amp;rdquo;), &lt;strong&gt;i&lt;/strong&gt; 从初始值开始迭代, 当条件( &lt;strong&gt;&amp;ldquo;i &amp;lt; n&amp;rdquo;&lt;/strong&gt; )为true时, 以步长(&lt;strong&gt;&amp;ldquo;1.0&amp;rdquo;&lt;/strong&gt;)开始增加.&lt;/p&gt;

&lt;p&gt;如果&lt;strong&gt;步长&lt;/strong&gt;被省略了, 默认设置它为1.0.&lt;/p&gt;

&lt;p&gt;当&lt;strong&gt;循环条件为true&lt;/strong&gt;时, 它会执行它的body expression. 因为我们没有什么要返回的, 所以我们定义&lt;strong&gt;the loop总是返回0.0&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;在未来当我们有&lt;strong&gt;可变变量&lt;/strong&gt;时, 它会变得更有用.&lt;/p&gt;

&lt;p&gt;像往常一样, 让我们开始讨论如何设计Kaleidoscope来支持 &lt;strong&gt;for循环&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&#34;lexer-extensions-for-the-for-loop&#34;&gt;Lexer Extensions for the &amp;lsquo;for&amp;rsquo; Loop&lt;/h2&gt;

&lt;p&gt;扩展词法分析器与 &lt;strong&gt;if/then/else&lt;/strong&gt;相似:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;... in enum Token ...
// control
tok_if = -6, tok_then = -7, tok_else = -8,
tok_for = -9, tok_in = -10

... in gettok ...
if (IdentifierStr == &amp;quot;def&amp;quot;)
  return tok_def;
if (IdentifierStr == &amp;quot;extern&amp;quot;)
  return tok_extern;
if (IdentifierStr == &amp;quot;if&amp;quot;)
  return tok_if;
if (IdentifierStr == &amp;quot;then&amp;quot;)
  return tok_then;
if (IdentifierStr == &amp;quot;else&amp;quot;)
  return tok_else;
if (IdentifierStr == &amp;quot;for&amp;quot;)
  return tok_for;
if (IdentifierStr == &amp;quot;in&amp;quot;)
  return tok_in;
return tok_identifier;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ast-extensions-for-the-for-loop&#34;&gt;AST Extensions for the &amp;lsquo;for&amp;rsquo; Loop&lt;/h2&gt;

&lt;p&gt;The AST node也很简单. 它基本上就是包含: &lt;strong&gt;节点中的变量名&lt;/strong&gt; 和 &lt;strong&gt;组成它的表达式&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// ForExprAST - Expression class for for/in.
class ForExprAST : public ExprAST {
  std::string VarName;  // 迭代器变量名称
  std::unique_ptr&amp;lt;ExprAST&amp;gt; Start, End, Step, Body;

public:
  ForExprAST(const std::string &amp;amp;VarName, std::unique_ptr&amp;lt;ExprAST&amp;gt; Start,
             std::unique_ptr&amp;lt;ExprAST&amp;gt; End, std::unique_ptr&amp;lt;ExprAST&amp;gt; Step,
             std::unique_ptr&amp;lt;ExprAST&amp;gt; Body)
    : VarName(VarName), Start(std::move(Start)), End(std::move(End)),
      Step(std::move(Step)), Body(std::move(Body)) {}

  Value *codegen() override;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;parser-extensions-for-the-for-loop&#34;&gt;Parser Extensions for the &amp;lsquo;for&amp;rsquo; Loop&lt;/h2&gt;

&lt;p&gt;解析器代码也是相当标准的.&lt;/p&gt;

&lt;p&gt;唯一有趣的事情是这里会处理可选的&lt;strong&gt;步长&lt;/strong&gt;. 解析器代码通过&lt;code&gt;检查第二个逗号是否存在来处理&lt;/code&gt;. &lt;code&gt;如果没有发现逗号, 我们会在AST节点中将步长设置为null&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/// forexpr ::= &#39;for&#39; identifier &#39;=&#39; expr &#39;,&#39; expr (&#39;,&#39; expr)? &#39;in&#39; expression
static std::unique_ptr&amp;lt;ExprAST&amp;gt; ParseForExpr() {
  getNextToken();  // eat the for.

  if (CurTok != tok_identifier)
    return LogError(&amp;quot;expected identifier after for&amp;quot;);

  std::string IdName = IdentifierStr;
  getNextToken();  // eat identifier.

  if (CurTok != &#39;=&#39;)
    return LogError(&amp;quot;expected &#39;=&#39; after for&amp;quot;);
  getNextToken();  // eat &#39;=&#39;.


  auto Start = ParseExpression();
  if (!Start)
    return nullptr;
  if (CurTok != &#39;,&#39;)
    return LogError(&amp;quot;expected &#39;,&#39; after for start value&amp;quot;);
  getNextToken();

  auto End = ParseExpression();
  if (!End)
    return nullptr;

  // The step value is optional.
  std::unique_ptr&amp;lt;ExprAST&amp;gt; Step;
  if (CurTok == &#39;,&#39;) {
    getNextToken();
    Step = ParseExpression();
    if (!Step)
      return nullptr;
  }

  if (CurTok != tok_in)
    return LogError(&amp;quot;expected &#39;in&#39; after for&amp;quot;);
  getNextToken();  // eat &#39;in&#39;.

  auto Body = ParseExpression();
  if (!Body)
    return nullptr;

  return llvm::make_unique&amp;lt;ForExprAST&amp;gt;(IdName, std::move(Start),
                                       std::move(End), std::move(Step),
                                       std::move(Body));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然了, 我们会将它作为主表达式的一部分.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;static std::unique_ptr&amp;lt;ExprAST&amp;gt; ParsePrimary() {
  switch (CurTok) {
  default:
    return LogError(&amp;quot;unknown token when expecting an expression&amp;quot;);
  case tok_identifier:
    return ParseIdentifierExpr();
  case tok_number:
    return ParseNumberExpr();
  case &#39;(&#39;:
    return ParseParenExpr();
  case tok_if:
    return ParseIfExpr();
  case tok_for:
    return ParseForExpr();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;llvm-ir-for-the-for-loop&#34;&gt;LLVM IR for the &amp;lsquo;for&amp;rsquo; loop&lt;/h2&gt;

&lt;p&gt;下一步, 我们现在需要为For循环产生IR. 根据上面的例子, 我们可以产生下面这样的IR(注意: 为了清楚起见, 我们在产生时关闭了优化):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;declare double @putchard(double)

define double @printstar(double %n) {
entry:
  ; initial value = 1.0 (inlined into phi)
  br label %loop

loop:       ; preds = %loop, %entry
  %i = phi double [ 1.000000e+00, %entry ], [ %nextvar, %loop ]
  ; body
  %calltmp = call double @putchard(double 4.200000e+01)
  ; increment
  %nextvar = fadd double %i, 1.000000e+00

  ; termination test
  %cmptmp = fcmp ult double %i, %n
  %booltmp = uitofp i1 %cmptmp to double
  %loopcond = fcmp one double %booltmp, 0.000000e+00
  br i1 %loopcond, label %loop, label %afterloop

afterloop:      ; preds = %loop
  ; loop always returns 0.0
  ret double 0.000000e+00
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该循环包含我们之前看到的相同的结构: &lt;strong&gt;a phi node&lt;/strong&gt;, &lt;strong&gt;several expressions&lt;/strong&gt;, and &lt;strong&gt;some basic blocks&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;CFG:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/docs-pic/llvm/loop.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;code-generation-for-the-for-loop&#34;&gt;Code Generation for the &amp;lsquo;for&amp;rsquo; Loop&lt;/h2&gt;

&lt;p&gt;codegen的第一部分是简单的, 我们只是输出&lt;strong&gt;循环的起始表达式&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Value *ForExprAST::codegen() {
  // Emit the start code first, without &#39;variable&#39; in scope.
  Value *StartVal = Start-&amp;gt;codegen();
  if (!StartVal)
    return nullptr;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在此之后, 下一步是为&lt;strong&gt;loop body&lt;/strong&gt;的启动设置&lt;strong&gt;LLVM basic block&lt;/strong&gt;. 在上面的例子中, 整个loop body是一个&lt;strong&gt;block&lt;/strong&gt;. 但是记住: &lt;code&gt;body node 本身可以包含多个blocks&lt;/code&gt;. (E.g: 它可以包含 if/then/else 或者 a for/in expression).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Make the new basic block for the loop header, inserting after current
// block.
// 为loop header make新的basic block, 在当前block之后插入
Function *TheFunction = Builder.GetInsertBlock()-&amp;gt;getParent();
BasicBlock *PreheaderBB = Builder.GetInsertBlock();
BasicBlock *LoopBB =
    BasicBlock::Create(TheContext, &amp;quot;loop&amp;quot;, TheFunction);

// Insert an explicit fall through from the current block to the LoopBB.
// 从当前块插入explicit fall through to the LoopBB
Builder.CreateBr(LoopBB);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码与我们在if/then/else中看到的代码相似. 因为之后我们将会需要它来创建一个Phi node, 所以我们保存了那个刚进入循环的块.&lt;/p&gt;

&lt;p&gt;在做完这些之后, 我们创建&lt;strong&gt;Loop Block&lt;/strong&gt;, 并且为两个块之前的连接创建一个无条件分支.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Start insertion in LoopBB.   开始插入
Builder.SetInsertPoint(LoopBB);

// Start the PHI node with an entry for Start. 

PHINode *Variable = Builder.CreatePHI(Type::getDoubleTy(TheContext),
                                      2, VarName.c_str());
Variable-&amp;gt;addIncoming(StartVal, PreheaderBB);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在 loop 的&lt;strong&gt;&amp;ldquo;preheader&amp;rdquo;&lt;/strong&gt;已经设置好了, 我们切换到为 loop body来emitting code.&lt;/p&gt;

&lt;p&gt;首先: 我们移动插入点, and &lt;strong&gt;为loop indunction 变量创建PHI node&lt;/strong&gt;. 由于我们已经知道起始值的传入值, 我们将它加入到PHI node 中.&lt;/p&gt;

&lt;p&gt;注意到Phi之后会最终获得备份的第二个值, 但是我们现在还不能set it up yet (因为它目前还不存在!)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Within the loop, the variable is defined equal to the PHI node.  If it
// shadows an existing variable, we have to restore it, so save it now.
Value *OldVal = NamedValues[VarName];
NamedValues[VarName] = Variable;

// Emit the body of the loop.  This, like any other expr, can change the
// current BB.  Note that we ignore the value computed by the body, but don&#39;t
// allow an error.
if (!Body-&amp;gt;codegen())
  return nullptr;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在代码开始变得有趣了,  我在符号表中为&lt;code&gt;for&lt;/code&gt; 循环引入了新的变量. 这意味着: 我们的符号表现在可以包含**函数参数 &lt;strong&gt;或者&lt;/strong&gt;循环变量&lt;strong&gt;. 为了处理这个问题, 在我们为循环体body 进行 codegen之前, 我们在符号表中添加&lt;/strong&gt;该循环变量的名称&lt;strong&gt;以及&lt;/strong&gt;它的当前值**.&lt;/p&gt;

&lt;p&gt;注意: &lt;code&gt;外部作用域可能会有相同的变量名称&lt;/code&gt;. 我们很容易会犯这个错误(就是如果已经存在varName, 我们会采取报错并且返回error这个措施).  &lt;strong&gt;但是我们选择了允许隐藏存在的变量&lt;/strong&gt;. 为了正确的实现该目标, 我们会保存之前存在的varName的值(当然了, 如果之前没有varName的话, 我们会设置它为null).&lt;/p&gt;

&lt;p&gt;一旦将循环变量加入到符号表中之后,  我们就可以&lt;strong&gt;递归地对Body进行Codegen&lt;/strong&gt;. 我们允许&lt;strong&gt;body使用循环变量&lt;/strong&gt;: 我们可以在符号表中找到循环变量, 来实现对它的引用.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Emit the step value.
Value *StepVal = nullptr;
if (Step) {
  StepVal = Step-&amp;gt;codegen();
  if (!StepVal)
    return nullptr;
} else {
  // If not specified, use 1.0.
  StepVal = ConstantFP::get(TheContext, APFloat(1.0));
}

Value *NextVar = Builder.CreateFAdd(Variable, StepVal, &amp;quot;nextvar&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在 the body is emitted,  我们计算迭代器的下一个值. (迭代器的下一个值= 迭代器当前的值+步长; 如果步长未被设置, 默认为 1.0)&lt;/p&gt;

&lt;p&gt;&amp;lsquo;&lt;strong&gt;NextValue&lt;/strong&gt;&amp;lsquo;将会是循环的下一次迭代的迭代器值.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Compute the end condition.
Value *EndCond = End-&amp;gt;codegen();
if (!EndCond)
  return nullptr;

// Convert condition to a bool by comparing non-equal to 0.0.
EndCond = Builder.CreateFCmpONE(
    EndCond, ConstantFP::get(TheContext, APFloat(0.0)), &amp;quot;loopcond&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后, 我们计算循环的退出值,  来决定是否退出循环. 这与 if/then/else 语句的条件值计算是一样的.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Create the &amp;quot;after loop&amp;quot; block and insert it.
BasicBlock *LoopEndBB = Builder.GetInsertBlock();
BasicBlock *AfterBB =
    BasicBlock::Create(TheContext, &amp;quot;afterloop&amp;quot;, TheFunction);

// Insert the conditional branch into the end of LoopEndBB.
Builder.CreateCondBr(EndCond, LoopBB, AfterBB);

// Any new code will be inserted in AfterBB.
Builder.SetInsertPoint(AfterBB);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;随着循环体的代码完成, 我们现在只需要为它完成控制流程. 该代码保存&lt;strong&gt;end block&lt;/strong&gt;(for the phi node), 然后为Loop exit(&amp;ldquo;afterloop&amp;rdquo;)创建 block. 基于退出条件的值, 它创建了一个条件分支来&lt;strong&gt;来在再一次执行循环和退出循环之前选择&lt;/strong&gt;. 任何之后创建的指令都会在 &lt;strong&gt;afterloop block&lt;/strong&gt; 中,  所以我们设置了Builder的插入位置.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  // Add a new entry to the PHI node for the backedge.
  Variable-&amp;gt;addIncoming(NextVar, LoopEndBB);

  // Restore the unshadowed variable.
  if (OldVal)
    NamedValues[VarName] = OldVal;
  else
    NamedValues.erase(VarName);

  // for expr always returns 0.0.
  return Constant::getNullValue(Type::getDoubleTy(TheContext));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后的代码处理各种cleanups: 现在我们有了 &lt;strong&gt;&amp;ldquo;NextVar&amp;rdquo; 值&lt;/strong&gt;, 我们可以将&lt;strong&gt;NextVar/LoopEndBB&lt;/strong&gt;添加到 Loop PHI node中. 在这之后, 我们从符号表中移除循环变量. 所以 for 循环完成之后, 它就不在作用域中了. 最后, for 循环的代码产生总是返回 0.0, 这就是我们从 ForExprAST::codegen()中返回的内容.&lt;/p&gt;

&lt;p&gt;现在我们总结本教程中 &amp;ldquo;adding control flow to Kaleidoscope&amp;rdquo; 这章.&lt;/p&gt;

&lt;p&gt;在本章, 我们增加了两个控制流结构, 通过实现我们了解到了 LLVM IR 的几个方面 (这些对于编译器前端实现者来说是很重要的).&lt;/p&gt;

&lt;p&gt;在下一章, 我们将会变得更疯狂并且我们会为我们的Kaleidoscope添加用户自定义的运算符.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Kaleidoscope: Adding JIT and Optimizer Support</title>
      <link>https://l0phtg.github.io/post/llvm/kaleidoscope-adding-jit-and-optimizer-support/</link>
      <pubDate>Sat, 13 Apr 2019 15:02:51 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/llvm/kaleidoscope-adding-jit-and-optimizer-support/</guid>
      
        <description>&lt;p&gt;translate from: &lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl04.html&#34;&gt;http://llvm.org/docs/tutorial/LangImpl04.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文介绍使用LLVM Pass对产生的LLVM IR进行优化, 以及为我们的Kaleidoscope添加JIT.&lt;/p&gt;

&lt;div class=&#34;mermaid&#34;&gt;
graph TB

    subgraph call
        funcall(&#34;foo(1);&#34;)
    end

    subgraph expr
        nodeExpr(&#34;1+2;&#34;)
    end
    
    jitAddModule[&#34;JIT中 添加此Module&#34;]
    jitRemoveModule[&#34;JIT中 删除此Module&#34;]
    
    anoCodegen[&#34;执行 匿名函数Codegen&#34;]
    AnonymousCall[&#34;匿名函数包装&#34;]
    optimizeFunc[&#34;执行 Pass优化&#34;]
    nodeExpr --&gt; AnonymousCall
    funcall --&gt; AnonymousCall
    AnonymousCall --&gt; anoCodegen
    anoCodegen --&gt; jitAddModule
    jitAddModule --&gt; optimizeFunc
    optimizeFunc --&gt; exec[&#34;JIT 运行此表达式, 并计算值&#34;]
    exec --&gt; jitRemoveModule
    
    subgraph func definition
        nodeFoo(&#34;def foo(x) x+1;&#34;)
        funcCodegen[&#34;执行 函数定义Codegen&#34;]
        nodeFoo --&gt; funcCodegen
    end
    
    funcCodegen --&gt; jitAddFuncModule[&#34;JIT中 添加此Module&#34;]
    jitAddFuncModule --&gt; initPassManager[&#34;执行 Pass优化&#34;]


    subgraph extern
        nodeExtern(&#34;extern sin(x);&#34;)
        protoCodegen[&#34;执行 函数申明Codegen&#34;]
        nodeExtern --&gt; protoCodegen
    end
    
    style jitAddModule fill:#f9f
    style jitRemoveModule fill:#f9f
    style jitAddFuncModule fill:#f9f
    
    style optimizeFunc fill:#ccff66
    style initPassManager fill:#ccff66
    
    style exec fill:#ff3300
    

&lt;/div&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;本章主要介绍了两个部分:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用Pass对LLVM IR进行优化.&lt;/li&gt;
&lt;li&gt;利用JIT. 处理顶级表达式和函数调用. 使他们 eveluate a value.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了实现这个目的, 我们需要实现这几个功能:&lt;/p&gt;

&lt;p&gt;a. 创建PassManager来对Pass进行管理.&lt;/p&gt;

&lt;p&gt;b. 为了可以通过FunctionPassManager来对顶级表达式做优化, 我们将每个顶级表达式都视为一个匿名函数. 并将每一个匿名函数作为一个module单独在JIT中处理, 计算完后在JIT中移除该module.&lt;/p&gt;

&lt;p&gt;c. 为了不在jit处理顶级函数调用表达式时移除我们定义的函数. 我们将每个定义的函数都放在一个单独的jit module中.&lt;/p&gt;

&lt;h1 id=&#34;chapter-4-介绍&#34;&gt;Chapter 4 介绍&lt;/h1&gt;

&lt;p&gt;Welcome to Chapter 4 of the &amp;ldquo;Implementing an language with LLVM&amp;rdquo; tutorial. Chapter 1-3 描述了一个简单语言的实现并且为产生LLVM IR添加了支持.&lt;/p&gt;

&lt;p&gt;本章描述两个新的技术: &lt;strong&gt;添加优化支持 to your language&lt;/strong&gt;, 和 &lt;strong&gt;添加JIT编译支持&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;这些新增的内容将会展示如何为Kaleidoscope提供更nice, efficient code.&lt;/p&gt;

&lt;h1 id=&#34;trivial-constant-folding&#34;&gt;Trivial Constant Folding&lt;/h1&gt;

&lt;p&gt;我们在第三章的展示是优雅的, 并且很容易扩展. 不幸地是, 它不能产生优秀的代码. The IR Builder, 当编译代码的时候, 它确实给了我们很明显的优化.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;ready&amp;gt; def test(x) 1+2+x;
Read function definition:
define double @test(double %x) {
entry:
        %addtmp = fadd double 3.000000e+00, %x
        ret double %addtmp
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码不是根据字面的AST直接转换的.&lt;/p&gt;

&lt;p&gt;如果按照输入的表达式字面值进行生成 IR, 应该是下面这样.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;ready&amp;gt; def test(x) 1+2+x;
Read function definition:
define double @test(double %x) {
entry:
        %addtmp = fadd double 2.000000e+00, 1.000000e+00
        %addtmp1 = fadd double %addtmp, %x
        ret double %addtmp1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;常量折叠&lt;/strong&gt;, 正如我们上面看到的. 这是一个非常普遍的和非常重要的优化: 以至于许多语言的实现者在其AST表示中就已经实现了常量折叠.&lt;/p&gt;

&lt;p&gt;在LLVM中, 你&lt;code&gt;不需要在AST中支持常量折叠&lt;/code&gt;. 由于所有build LLVM IR的调用都是通过LLVM IRBuilder, 当你调用它的时候, &lt;code&gt;Builder会自动检查是否可以进行常量折叠&lt;/code&gt;. 如果可以进行常量折叠, 它会直接进行操作并且返回一个常量而不是一条指令.&lt;/p&gt;

&lt;p&gt;Well, that was easy. 在实践中, 当产生像上面这样的代码的时候,  我们推荐使用&lt;strong&gt;IRBuilder&lt;/strong&gt;. 它的使用没有语法开销(你不需要在任何地方执行常量检查, 这将会使你的编译器很丑陋). 并且它在一些情况下, 会大大减少LLVM IR的数量.(特别是对于有大量&lt;strong&gt;宏的预处理&lt;/strong&gt;or &lt;strong&gt;很多常量的使用&lt;/strong&gt;)&lt;/p&gt;

&lt;p&gt;在另一方面, IRBuilder被以下事实所限制 that 它在构建代码时将所有的分析与代码内联.&lt;/p&gt;

&lt;p&gt;如果你执行一个稍微复杂的例子:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ready&amp;gt; def test(x) (1+2+x)*(x+(1+2));
ready&amp;gt; Read function definition:
define double @test(double %x) {
entry:
        %addtmp = fadd double 3.000000e+00, %x
        %addtmp1 = fadd double %x, 3.000000e+00
        %multmp = fmul double %addtmp, %addtmp1
        ret double %multmp
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在该情况下, LHS和RHS 是相同的值.&lt;/p&gt;

&lt;p&gt;我们其实是希望产生下面这样的 IR:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tmp = x + 3;       
result = tmp * tmp; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来代替 执行&amp;rdquo;&lt;strong&gt;x+3&lt;/strong&gt;&amp;ldquo;两次.&lt;/p&gt;

&lt;p&gt;不幸地是, 没有大量的本地分析能够检测并纠正这一点. 这需要两个转换:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;表达式的重新转换(to make the add&amp;rsquo;s lexically identical).&lt;/li&gt;
&lt;li&gt;公共的子表达式删除(CES) 来 删除冗余的添加指令.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;幸运的是, &lt;code&gt;LLVM 提供大量的优化来供你使用,所有的优化以&amp;quot;passes&amp;quot;的形式存在&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;llvm-optimization-passes&#34;&gt;LLVM Optimization Passes&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;Due to the transition to the new PassManager infrastructure this tutorial is based on llvm::legacy::FunctionPassManager which can be found in LegacyPassManager.h. For the purpose of the this tutorial the above should be used until the pass manager transition is complete.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;LLVM 提供了很多优化passes, 它可以做执行很多不同类型的操作并具有不同的权衡. 不像其他的系统一样, LLVM并不认为一组优化可以对所有语言和所有的情景适用. LLVM允许编译器实现者决定要使用什么样的优化, 按怎样的顺序, 或者在什么情景下.&lt;/p&gt;

&lt;p&gt;作为一个具体的例子, LLVM 支持 &amp;ldquo;&lt;strong&gt;whole module passes&lt;/strong&gt;&amp;rdquo;, which它看起来像很大的代码 (经常是整个文件, but 如果运行在链接时, 这可能是整个项目中的重要的一部分). 它也支持并包含&amp;rdquo;pre-function&amp;rdquo; passes which 一次操作一个函数, without looking at other function.&lt;/p&gt;

&lt;p&gt;想要了解更多关于pass的信息以及他们是怎么样运行的. see &lt;a href=&#34;http://llvm.org/docs/WritingAnLLVMPass.html&#34;&gt;Write An LLVM PASS&lt;/a&gt;文档和&lt;a href=&#34;http://llvm.org/docs/Passes.html&#34;&gt;List of LLVM Passes&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;对于Kaleidoscope来说, 我们目前正在动态生成函数, 一次一个. 当用户输入它们时. We aren&amp;rsquo;t shooting for the ultimate optimization experience in this setting, 但是我们也更想更快的抓住简单快捷的东西. 因此, 当用户输入时, 我们将会选择为每个函数都进行优化. 如果我们想要做一个&amp;rdquo;static Kaleidoscope compiler&amp;rdquo;, 我们将正常使用我们现在有的代码, 除了把优化推迟到整个文件被解析之后.&lt;/p&gt;

&lt;p&gt;为了让每个函数都进行优化, 我们需要设置一个&lt;strong&gt;&lt;a href=&#34;http://llvm.org/docs/WritingAnLLVMPass.html#what-passmanager-doesr&#34;&gt;FunctionPassManager&lt;/a&gt;&lt;/strong&gt;来hold and organize 我们想要运行的LLVM 优化. 一旦我们有了这个, 我们就可以添加一组优化来执行. 对于每个我们想要优化的模块, 我们都需要一个&lt;strong&gt;FunctionPassManager&lt;/strong&gt;, 所以我们将会写一个函数来创建并且初始化我们的&lt;strong&gt;module&lt;/strong&gt;和&lt;strong&gt;pass manager&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void InitializeModuleAndPassManager(void) {
  // Open a new module. 打开一个新的module
  TheModule = llvm::make_unique&amp;lt;Module&amp;gt;(&amp;quot;my cool jit&amp;quot;, TheContext);

  // Create a new pass manager attached to it. 创建一个新的pass manager并且关联到我们的module中
  TheFPM = llvm::make_unique&amp;lt;FunctionPassManager&amp;gt;(TheModule.get());

  // Do simple &amp;quot;peephole&amp;quot; optimizations and bit-twiddling optzns.
  TheFPM-&amp;gt;add(createInstructionCombiningPass());
  // Reassociate expressions.	重新关联表达式
  TheFPM-&amp;gt;add(createReassociatePass());
  // Eliminate Common SubExpressions.	消除公共的子表达式
  TheFPM-&amp;gt;add(createGVNPass());
  // Simplify the control flow graph (deleting unreachable blocks, etc). 简化控制流(例如: 删除到达不了的blocks)
  TheFPM-&amp;gt;add(createCFGSimplificationPass());

  TheFPM-&amp;gt;doInitialization();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该代码初始化全局module &lt;strong&gt;TheModule&lt;/strong&gt;, 和函数pass manager &lt;strong&gt;TheFPM&lt;/strong&gt;(which attached to TheModule). 一旦pass manager 被 set up, 我们使用一系列&amp;rdquo;&lt;strong&gt;add&lt;/strong&gt;&amp;ldquo;调用来加入 &lt;strong&gt;一堆LLVM passes&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;在这个例子中, 我们选择增加四个优化passes. 我们这里选择的pass是一组相当标准的&amp;rdquo;&lt;strong&gt;cleanup&lt;/strong&gt;&amp;rdquo; 优化 (对大多数代码都是适用的). 我不会深挖它们的实现, 请相信我, they are a good starting place :)&lt;/p&gt;

&lt;p&gt;一旦PassManager被 set up, 我们就需要使用它.    在我们的新函数被构造之后(in FunctionAST::codegen()), 在 returned to the client之前, we do this by running it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;if (Value *RetVal = Body-&amp;gt;codegen()) {
  // Finish off the function.
  Builder.CreateRet(RetVal);

  // Validate the generated code, checking for consistency.
  verifyFunction(*TheFunction);

  // Optimize the function.
  TheFPM-&amp;gt;run(*TheFunction);

  return TheFunction;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正如你看到的, 这是相当直接的. The &lt;strong&gt;FunctionPassManager&lt;/strong&gt;优化并更新LLVM Funtion* in place, 改进他们的body.&lt;/p&gt;

&lt;p&gt;有了这个, 我们可以再次尝试我们的test:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;ready&amp;gt; def test(x) (1+2+x)*(x+(1+2));
ready&amp;gt; Read function definition:
define double @test(double %x) {
entry:
        %addtmp = fadd double %x, 3.000000e+00
        %multmp = fmul double %addtmp, %addtmp
        ret double %multmp
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正如我们期待的,  我们现在得到了不错的, 优化后的代码, 这个函数的每次运行都只有一个浮点add指令.&lt;/p&gt;

&lt;p&gt;LLVM 提供了大量的优化, 可以被用在当前的情况下. &lt;code&gt;Some [pass文档](http://llvm.org/docs/Passes.html)可以获得&lt;/code&gt;, 但是那不是全部.  另一个不错的想法是: &lt;code&gt;可以阅读clang启动时运行的pass&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;The **opt** 允许你从命令行来对pass进行测试&lt;/code&gt;, 所以你可以看看它到底做了些什么.&lt;/p&gt;

&lt;p&gt;现在我们的前端代码已经很NB了, let&amp;rsquo;s talk about executing it!&lt;/p&gt;

&lt;h1 id=&#34;adding-a-jit-compiler&#34;&gt;Adding a JIT Compiler&lt;/h1&gt;

&lt;p&gt;LLVM IR中提供的代码可以应用各种工具. 例如, 你可以对它进行优化(as we did above), 你能dump it out in 文本或者二进制格式, 你可以编译代码到 assembly file(.s) for some target, 或者你能够JIT compiler it.&lt;/p&gt;

&lt;p&gt;LLVM IR表示的好处是: 它是在编译器中, 许多不同部分的&amp;rdquo;common currency&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;在本节, &lt;strong&gt;我们将会为我们的解释器添加JIT支持&lt;/strong&gt;. 添加JIT基本思想是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我们想要现在这样用户输入函数体, 但是就要立刻计算他们输入的顶级表达式. 例如, 如果他们输入 &amp;ldquo;1+2&amp;rdquo;,  我们应该 &lt;strong&gt;立即让他输出&lt;/strong&gt; 3.&lt;/li&gt;
&lt;li&gt;如果他们定义了一个函数, 他们应该能够被&lt;strong&gt;从命令行上被调用&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了做这个, 我们首先要准备环境来为本机目标创建代码并申明和初始化JIT. 这可以通过调用 &lt;code&gt;InitializeNativeTarget*&lt;/code&gt; 函数来做, 并且添加一个JIT的全局变量, 并在main中初始化:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;static std::unique_ptr&amp;lt;KaleidoscopeJIT&amp;gt; TheJIT;
...
int main() {
  InitializeNativeTarget();
  InitializeNativeTargetAsmPrinter();
  InitializeNativeTargetAsmParser();

  // Install standard binary operators.
  // 1 is lowest precedence.
  BinopPrecedence[&#39;&amp;lt;&#39;] = 10;
  BinopPrecedence[&#39;+&#39;] = 20;
  BinopPrecedence[&#39;-&#39;] = 20;
  BinopPrecedence[&#39;*&#39;] = 40; // highest.

  // Prime the first token.
  fprintf(stderr, &amp;quot;ready&amp;gt; &amp;quot;);
  getNextToken();

  TheJIT = llvm::make_unique&amp;lt;KaleidoscopeJIT&amp;gt;();

  // Run the main &amp;quot;interpreter loop&amp;quot; now.
  MainLoop();

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们还需要为JIT设置data layout(数据布局):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void InitializeModuleAndPassManager(void) {
  // Open a new module.
  TheModule = llvm::make_unique&amp;lt;Module&amp;gt;(&amp;quot;my cool jit&amp;quot;, TheContext);
  TheModule-&amp;gt;setDataLayout(TheJIT-&amp;gt;getTargetMachine().createDataLayout());

  // Create a new pass manager attached to it.
  TheFPM = llvm::make_unique&amp;lt;FunctionPassManager&amp;gt;(TheModule.get());
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kaleidoscope JIT类是一个专门为这个tutorial构建的simple JIT, 可以在 &lt;code&gt;llvm-src/examples/Kaleidoscope/include/Kaleidoscope.h&lt;/code&gt;这里找到. 在之后的章节, 我们将会看到它是怎么样工作的并且给它扩展一些新特性, 但是现在我们假设它是直接给定的.&lt;/p&gt;

&lt;p&gt;它的API 是非常简单的:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;addModule&lt;/strong&gt; 会在JIT中增加一个LLVM IR module, 使其功能是可以执行的;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;removeModule&lt;/strong&gt;会移除一个module, 释放在这个模块中与之相关联的代码;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;findSymbol&lt;/strong&gt;允许我们查找编译代码的指针.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们可以改变我们的解析顶级表达式的代码, 在其中添加对这几个简单API的调用.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;static void HandleTopLevelExpression() {
  // Evaluate a top-level expression into an anonymous function. 将顶级表达式计算为匿名函数
  if (auto FnAST = ParseTopLevelExpr()) {
    if (FnAST-&amp;gt;codegen()) {

      // JIT the module containing the anonymous expression, keeping a handle so
      // we can free it later.
      auto H = TheJIT-&amp;gt;addModule(std::move(TheModule));
      InitializeModuleAndPassManager();

      // Search the JIT for the __anon_expr symbol.
      auto ExprSymbol = TheJIT-&amp;gt;findSymbol(&amp;quot;__anon_expr&amp;quot;);
      assert(ExprSymbol &amp;amp;&amp;amp; &amp;quot;Function not found&amp;quot;);

      // Get the symbol&#39;s address and cast it to the right type (takes no
      // arguments, returns a double) so we can call it as a native function.
      // 得到symbol的地址, 并且将它转换为正确的类型(无参数, 返回值为double类型)
      double (*FP)() = (double (*)())(intptr_t)ExprSymbol.getAddress();
      fprintf(stderr, &amp;quot;Evaluated to %f\n&amp;quot;, FP());

      // Delete the anonymous expression module from the JIT.
      TheJIT-&amp;gt;removeModule(H);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果&lt;strong&gt;parsing&lt;/strong&gt; and &lt;strong&gt;codegen&lt;/strong&gt; 成功, 下一步是将包含顶级表达式的module添加到JIT. 我们通过调用&lt;strong&gt;addModule&lt;/strong&gt;来 do this, 调用addModule会触发对此module中的所有函数进行codegen,  并且返回一个handle(在之后删除此module时会用到). 一旦module已经被加到JIT中, 它不再被修改,  所以现在我们可以调用&lt;strong&gt;InitializeModuleAndPassManager()&lt;/strong&gt;来打开一个module, 以便于hold subsequent code (后续的代码).&lt;/p&gt;

&lt;p&gt;一旦我们将模块添加到JIT中, 我们需要获得指向最终生成代码的指针. 我们通过调用JIT&amp;rsquo;s &lt;strong&gt;findSymbol&lt;/strong&gt;方法来做这个, and 传递顶级表达式的名称: &lt;strong&gt;__anon_expr&lt;/strong&gt;. 由于我们刚刚添加了这个函数, 所以我们确定findSymbol一定会返回结果.&lt;/p&gt;

&lt;p&gt;下一步, 我们通过调用&lt;strong&gt;getAddress()&lt;/strong&gt;on the symbol来获取&lt;strong&gt;__anoy_expr&lt;/strong&gt;函数的内存地址. 回想一下, 我们将顶级表达式编译为一个 self-contained LLVM function(不带参数, 并且返回double). 因为 LLVM JIT 编译器匹配本地平台的ABI, 这意味着你可以将结果指针强制转换为该类型的函数指针并调用它. This means, JIT编译的代码和静态链接到应用程序的本地机器码没有区别.&lt;/p&gt;

&lt;p&gt;最终, 由于我们不支持 re-evaluation 顶级表达式, 当我们完成时, 我们从JIT中移除该module来释放相关的内存.&lt;/p&gt;

&lt;p&gt;回忆一下 , 我们之前创建的几行代码(&lt;strong&gt;InitializeModuleAndPassManager&lt;/strong&gt;)  is still open and waiting for new code to be added.(????)&lt;/p&gt;

&lt;p&gt;With just these two changes, let&amp;rsquo;s see Kaleidoscope works how!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;ready&amp;gt; 4+5;
Read top-level expression:
define double @0() {
entry:
  ret double 9.000000e+00
}

Evaluated to 9.000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这看起来基本是有效的, The dump of the function展示了&amp;rdquo;没有参数并总是返回double类型&amp;rdquo;, we synthesize for 每一个输入的顶级表达式.&lt;/p&gt;

&lt;p&gt;这展示了最基本的功能, 但是我们还可以如何做更多呢?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;ready&amp;gt; def testfunc(x y) x + y*2;
Read function definition:
define double @testfunc(double %x, double %y) {
entry:
  %multmp = fmul double %y, 2.000000e+00
  %addtmp = fadd double %multmp, %x
  ret double %addtmp
}

ready&amp;gt; testfunc(4, 10);		#注意: 由于此刻testfunc的函数定义与testfunc的函数调用的匿名表达式在同一个module, 所以此刻调用testfunc之后会删除testfunc的函数定义.
Read top-level expression:
define double @1() {
entry:
  %calltmp = call double @testfunc(double 4.000000e+00, double 1.000000e+01)
  ret double %calltmp
}

Evaluated to 24.000000

ready&amp;gt; testfunc(5, 10);
ready&amp;gt; LLVM ERROR: Program used external function &#39;testfunc&#39; which could not be resolved!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数定义和调用都正常工作了, 但是最后一行出现了一点问题. 该调用看起来是有效的, so what happened?&lt;/p&gt;

&lt;p&gt;正如你从API看到的那样, module是JIT分配的单元, and &lt;strong&gt;testfunc&lt;/strong&gt;是相同的module中的一部分(它包含匿名表达式). 当我们从JIT中移除module以便于释放匿名表达式的内存时, 我们&lt;strong&gt;删除了testfunc的定义&lt;/strong&gt;. 然后, 当我们试图调用第二次调用testfunc时, JIT找不到该函数的定义.&lt;/p&gt;

&lt;p&gt;最简单的fix this的方法是: &lt;code&gt;将匿名表达式放在与函数定义不同的module中&lt;/code&gt;. 只要每个被调用的函数都有一个原型, JIT很乐意解决跨模块边界的函数调用, 并在调用之前添加到JIT中. 通过把匿名表达式放到不同的module下, 我们可以删除它并且不影响其他的函数.&lt;/p&gt;

&lt;p&gt;事实上, 我们将更进一步, 将每个函数放到它自己的module中. 这样做可以允许我们利用KaileidoscopeJIT的有用的属性 that (will 使我们的环境更REPL-like: 函数能够被多次添加到JIT中)(与每个函数一定有一个定义的模块不同).&lt;/p&gt;

&lt;p&gt;当你在KaleidoscopeJIT中查找符号时, 它将返回最新的定义:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;ready&amp;gt; def foo(x) x + 1;
Read function definition:
define double @foo(double %x) {
entry:
  %addtmp = fadd double %x, 1.000000e+00
  ret double %addtmp
}

ready&amp;gt; foo(2);
Evaluated to 3.000000

ready&amp;gt; def foo(x) x + 2;
define double @foo(double %x) {
entry:
  %addtmp = fadd double %x, 2.000000e+00
  ret double %addtmp
}

ready&amp;gt; foo(2);
Evaluated to 4.000000

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了让每个函数都存在自己的模块中, 我们需要一个方法来re-generate以前的函数声明到每个我们打开的新模块中:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt; static std::unique_ptr&amp;lt;KaleidoscopeJIT&amp;gt; TheJIT;

...

Function *getFunction(std::string Name) {
  // First, see if the function has already been added to the current module.
  // 首先, 观察是否函数已经被添加到当前module中.
  if (auto *F = TheModule-&amp;gt;getFunction(Name))
    return F;

  // If not, check whether we can codegen the declaration from some existing
  // prototype.
  // if not, 检查是否我们可以codegen
  auto FI = FunctionProtos.find(Name);
  if (FI != FunctionProtos.end())
    return FI-&amp;gt;second-&amp;gt;codegen();

  // If no existing prototype exists, return null.
  return nullptr;
}
...

Value *CallExprAST::codegen() {
  // Look up the name in the global module table.
  Function *CalleeF = getFunction(Callee);

...

Function *FunctionAST::codegen() {
  // Transfer ownership of the prototype to the FunctionProtos map, but keep a
  // reference to it for use below.
  auto &amp;amp;P = *Proto;
  FunctionProtos[Proto-&amp;gt;getName()] = std::move(Proto);
  Function *TheFunction = getFunction(P.getName());
  if (!TheFunction)
    return nullptr;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了实现这个目的, 我们首先会添加一个新的全局变量: &lt;strong&gt;FunctionProtos&lt;/strong&gt;,  它包含每个函数的最新声明.  我们将添加一个方便的方法, &lt;strong&gt;getFunction()&lt;/strong&gt;, 来替换对&lt;strong&gt;TheModule-&amp;gt;getFunction()&lt;/strong&gt;的调用. 我们的便利的方法在TheModule中搜索现有的存在的函数声明, 如果找不到函数声明, 则回退到从FunctionProtos生成一个新的声明.  In &lt;strong&gt;CallExprAST::codegen()&lt;/strong&gt; 我们 just 需要替换对TheModule-&amp;gt;getFunction()的调用. 在&lt;strong&gt;FunctionAST::codegen()&lt;/strong&gt;中, 我们首先需要更新&lt;strong&gt;FunctionProtos map&lt;/strong&gt;, 然后调用 &lt;strong&gt;getFunction()&lt;/strong&gt;. 通过这样做, 我们总是可以在当前module中获得任何以前声明的函数的函数声明.&lt;/p&gt;

&lt;p&gt;我们也需要更新 &lt;strong&gt;HandleDefinition&lt;/strong&gt; and &lt;strong&gt;HandleExtern&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt; static void HandleDefinition() {
  if (auto FnAST = ParseDefinition()) {
    if (auto *FnIR = FnAST-&amp;gt;codegen()) {
      fprintf(stderr, &amp;quot;Read function definition:&amp;quot;);
      FnIR-&amp;gt;print(errs());
      fprintf(stderr, &amp;quot;\n&amp;quot;);
      TheJIT-&amp;gt;addModule(std::move(TheModule));
      InitializeModuleAndPassManager();
    }
  } else {
    // Skip token for error recovery.
     getNextToken();
  }
}

static void HandleExtern() {
  if (auto ProtoAST = ParseExtern()) {
    if (auto *FnIR = ProtoAST-&amp;gt;codegen()) {
      fprintf(stderr, &amp;quot;Read extern: &amp;quot;);
      FnIR-&amp;gt;print(errs());
      fprintf(stderr, &amp;quot;\n&amp;quot;);
      FunctionProtos[ProtoAST-&amp;gt;getName()] = std::move(ProtoAST);
    }
  } else {
    // Skip token for error recovery.
    getNextToken();
  }
}
 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在HandleDefinition中, 我们添加了两行代码来将定义的函数传递给JIT, 并打开一个new module. In HandleExtern, 我们只需要添加一行来增加函数原型到&lt;strong&gt;FunctionProtos&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;在做了这些改变之后, 让我们再次尝试我的REPL (这次我删除了匿名函数的dump, you should get the idea by now :):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;ready&amp;gt; def foo(x) x + 1;
ready&amp;gt; foo(2);
Evaluated to 3.000000

ready&amp;gt; def foo(x) x + 2;
ready&amp;gt; foo(2);
Evaluated to 4.000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即使这些功能很简单, 我们也可以得到surprisingly powerful capbilities - check this out:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;ready&amp;gt; extern sin(x);
Read extern:
declare double @sin(double)

ready&amp;gt; extern cos(x);
Read extern:
declare double @cos(double)

ready&amp;gt; sin(1.0);
Read top-level expression:
define double @2() {
entry:
  ret double 0x3FEAED548F090CEE
}

Evaluated to 0.841471

ready&amp;gt; def foo(x) sin(x)*sin(x) + cos(x)*cos(x);
Read function definition:
define double @foo(double %x) {
entry:
  %calltmp = call double @sin(double %x)
  %multmp = fmul double %calltmp, %calltmp
  %calltmp2 = call double @cos(double %x)
  %multmp4 = fmul double %calltmp2, %calltmp2
  %addtmp = fadd double %multmp, %multmp4
  ret double %addtmp
}

ready&amp;gt; foo(4.0);
Read top-level expression:
define double @3() {
entry:
  %calltmp = call double @foo(double 4.000000e+00)
  ret double %calltmp
}

Evaluated to 1.000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;whoa, JIT是怎么知道 &lt;strong&gt;sin&lt;/strong&gt;和 &lt;strong&gt;cos&lt;/strong&gt;的呢?&lt;/p&gt;

&lt;p&gt;答案是相当简单的: The kaleidoscopeJIT 有一个直接的符号解析规则, 用于查找当前给定模块中不可用的符号:  首先它搜索添加到JIT中的所有模块, 从最新的到以前的为了找到最新的定义. 如果JIT中找不到定义, 它将会在自身进程上运行 &amp;ldquo;dlsym(sin)&amp;rdquo;. 由于 &amp;ldquo;&lt;strong&gt;sin&lt;/strong&gt;&amp;ldquo;是在JIT的地址空间中定义的, 它只是简单的patches up calls 在模块中, 以直接调用到libm版本的sin.&lt;/p&gt;

&lt;p&gt;但是在某些情况下,  这甚至会做更多: 正如 &lt;strong&gt;sin&lt;/strong&gt;和 &lt;strong&gt;cos&lt;/strong&gt; 是标准的数学函数, 当我们使用 &lt;strong&gt;sin(1.0)&lt;/strong&gt;进行常量调用时, the constant folder会直接计算调用的结果.&lt;/p&gt;

&lt;p&gt;在未来, 我们将会看到如何调整符号解析规则以启用各种有用的特性,  &lt;strong&gt;from security (限制JIT代码可以使用的符号集合), to基于符号名称的动态代码执行, and even lazy complication&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;符号解析规则的一个好处是: 我们可以通过写任意的c++代码来扩展语言.&lt;/p&gt;

&lt;p&gt;For example, if we add:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#ifdef _WIN32
#define DLLEXPORT __declspec(dllexport)
#else
#define DLLEXPORT
#endif

/// putchard - putchar that takes a double and returns 0.
extern &amp;quot;C&amp;quot; DLLEXPORT double putchard(double X) {
  fputc((char)X, stderr);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意: 对于 windows, 我们实际上需要导出函数, 因为dynamic symbol loader将会使用&lt;strong&gt;GetProcAddress&lt;/strong&gt;来寻找symbol.&lt;/p&gt;

&lt;p&gt;现在我们可以通过输入: &amp;ldquo;extern putchard(x); putchard(20);&amp;rdquo; 产生简单的输出到控制台上. 类似的代码可以被用来实现 I/O, 控制台输入, 和其他许多Kaleidoscope的特性.&lt;/p&gt;

&lt;p&gt;这就是JIT和优化器的教程.&lt;/p&gt;

&lt;p&gt;此时, 我们能够编译一个非图灵完备的编程语言, 优化并且JIT编译它 in a user-driver way.&lt;/p&gt;

&lt;p&gt;接下来我们会研究使用控制流构造来扩展语言, 解决一些有趣的LLVM IR问题.&lt;/p&gt;

&lt;h1 id=&#34;full-code-list&#34;&gt;Full Code List&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl04.html#adding-a-jit-compiler&#34;&gt;http://llvm.org/docs/tutorial/LangImpl04.html#adding-a-jit-compiler&lt;/a&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Kaleidoscope: Code Generation to LLVM IR</title>
      <link>https://l0phtg.github.io/post/llvm/kaleidoscope-code-generation-to-llvm-ir/</link>
      <pubDate>Fri, 12 Apr 2019 16:55:05 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/llvm/kaleidoscope-code-generation-to-llvm-ir/</guid>
      
        <description>&lt;p&gt;translate from: &lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl03.html&#34;&gt;http://llvm.org/docs/tutorial/LangImpl03.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;介绍四个基本表达式和函数申明与定义的Codegen.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/docs-pic/llvm/Codegen.png&#34; alt=&#34;codegen .png&#34; /&gt;
&lt;/p&gt;

&lt;h1 id=&#34;3-1-chapter-3-introduction&#34;&gt;3.1 Chapter 3 Introduction&lt;/h1&gt;

&lt;p&gt;本章将会向你介绍如何转换为AST. built in Chapter2, into LLVM IR. 这将会教给你a little bit about LLVM是如何做这个的. 以及展示它的实用性. 构建一个词法分析器和解析器要比生成LLVM IR代码的工作多得多.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;please note&lt;/strong&gt;: 本章和之后的代码是基于LLVM 3.7 and later. LLVM 3.6 和之前的版本将不会工作for this code. 也要注意, 你需要一个匹配你的LLVM Release版本的tutorial.&lt;/p&gt;

&lt;h1 id=&#34;3-2-code-generation-setup&#34;&gt;3.2 Code Generation Setup&lt;/h1&gt;

&lt;p&gt;为了产生LLVM IR, 我们想要一些简单的setup来start. 首先我们定义virtual code generation(codegen)方法在每一个AST类中.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// ExprAST - Base class for all expression nodes.
class ExprAST {
public:
  virtual ~ExprAST() {}
  virtual Value *codegen() = 0;
};

/// NumberExprAST - Expression class for numeric literals like &amp;quot;1.0&amp;quot;.
class NumberExprAST : public ExprAST {
  double Val;

public:
  NumberExprAST(double Val) : Val(Val) {}
  virtual Value *codegen();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;codegen()表示为AST节点依赖它们来产生IR , 并且他们都返回一个&lt;strong&gt;Value&lt;/strong&gt;对象(被用来表示&amp;rdquo;Static Single Assigment(SSA) register&amp;rdquo; or &amp;ldquo;SSA value&amp;rdquo;in LLVM).&lt;/p&gt;

&lt;p&gt;SSA值的最独特的方面是当相关指令执行时, 他们的值被计算. 并且在指令再次执行之前, 它不会获得新值. 换句话说, 没有方法来改变SSA值. 为了了解更多关于SSA的信息, please read up on &lt;a href=&#34;https://l0phtg.github.io/post/llvm/static-single-assignment/&#34;&gt;Static Single Assignment&lt;/a&gt; - 一旦你理解了它, the concepts are really quite natural.&lt;/p&gt;

&lt;p&gt;请注意, 不是将虚方法添加到ExprAST的类层次结构中, 使用访问者模式或者其他方式对此进行建模也是有意义的.&lt;/p&gt;

&lt;p&gt;Again, 本教程将不再讨论良好的软件工程实践: 出于我们的目的, 添加虚拟方法是最简单的.&lt;/p&gt;

&lt;p&gt;我们想要的第二件事情, 是像我们在编写解析器时那样, 当发生错误时报告error. (例如, 对一个未声明参数的使用).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;static LLVMContext TheContext;
static IRBuilder&amp;lt;&amp;gt; Builder(TheContext);
static std::unique_ptr&amp;lt;Module&amp;gt; TheModule;
static std::map&amp;lt;std::string, Value *&amp;gt; NamedValues;

Value *LogErrorV(const char *Str) {
  LogError(Str);
  return nullptr;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在代码产生阶段, 静态变量将会被使用. TheContext 是一个掌握了大量的核心LLVM data 结构不透明的对象, 例如the type and 常量value tables. 我们不必关注它的细节, 我们仅仅需要一个简单的实例, 直接将它传到我们需要的API中即可.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;Builder object&lt;/strong&gt; 帮助我们使产生IR这件事变得很容易. &lt;strong&gt;IRBuilder&lt;/strong&gt;类的实例模板来&lt;strong&gt;跟踪当前插入指令的位置&lt;/strong&gt;并且&lt;strong&gt;提供创建新指令的方法&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TheModule&lt;/strong&gt; 是一个LLVM construct(包含函数和全局变量). In many ways, 它是一个LLVM IR用于包含代码的顶级结构.它将会掌控我们产生的IR的内存 (这就是为什么 codegen() method返回一个&lt;strong&gt;raw value&lt;/strong&gt;*, 而不是&lt;strong&gt;unique_ptr&lt;Value&gt;&lt;/strong&gt;).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The NamedValues map&lt;/strong&gt; 会跟踪&lt;strong&gt;当前作用域&lt;/strong&gt;中&lt;strong&gt;定义的值&lt;/strong&gt;以及它们的LLVM表示形式. (换句话说, 它是代码的符号表). &lt;code&gt;在 Kaleidoscope的形式中, 能被引用的唯一的things 是函数参数. 因此, 当为函数体进行Codegen时, 函数参数将会存在于该map中&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;有了这些基础知识, 我们可以开始讨论如何为每个表达式 generate code. 注意: this 假定已经设置了Builder来生成代码. 现在, 我们假设已经完成了, 我们将会just 用它来emit code.&lt;/p&gt;

&lt;h1 id=&#34;3-3-expression-code-generation&#34;&gt;3.3 Expression Code Generation&lt;/h1&gt;

&lt;p&gt;为每一个表达式产生LLVM code是非常直接的.&lt;/p&gt;

&lt;h2 id=&#34;numexpr&#34;&gt;numExpr&lt;/h2&gt;

&lt;p&gt;First we&amp;rsquo;ll do &lt;strong&gt;numberic literals&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Value *NumberExprAST::codegen() {
  return ConstantFP::get(TheContext, APFloat(Val));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在LLVM IR中, 数字常量用&lt;strong&gt;ConstantFP&lt;/strong&gt;类来表示, (在内部保存APFloat的值)(
APFloat 具有保存任意精度的浮点常数的能力). 这段代码基本就是创建并返回了一个&lt;strong&gt;ConstantFP&lt;/strong&gt;. 注意 在LLVM IR中, 常量都是唯一的, 并且被共享. 出于这个原因, The &lt;strong&gt;API use the &amp;ldquo;foo::(..)&amp;ldquo;而不是 &amp;ldquo;new foo(&amp;hellip;)&amp;rdquo; or &amp;ldquo;foo::Create(..)&amp;rdquo;&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&#34;variableexpr&#34;&gt;VariableExpr&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Value *VariableExprAST::codegen() {
  // Look this variable up in the function.
  Value *V = NamedValues[Name];
  if (!V)
    LogErrorV(&amp;quot;Unknown variable name&amp;quot;);
  return V;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用LLVM对变量的引用也非常简单. 在我们simple Kaleidoscope中, 我们假定变量已经被emitted somewhere 并且它的值是可用的. 实际上,  In the namedValues map 的唯一的值是函数参数. 此代码只是检查指定的name是否在map中. (如果没有, 未知变量将会被引用) 并且返回value for it. 在未来的章节, we&amp;rsquo;ll 将会在符号表和局部变量中增加&lt;strong&gt;Loop Induction variables&lt;/strong&gt; (可以阅读第5章: 对 Loop 进行 codegen的部分).&lt;/p&gt;

&lt;h2 id=&#34;binaryexprast&#34;&gt;BinaryExprAST&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Value *BinaryExprAST::codegen() {
  Value *L = LHS-&amp;gt;codegen();
  Value *R = RHS-&amp;gt;codegen();
  if (!L || !R)
    return nullptr;

  switch (Op) {
  case &#39;+&#39;:
    return Builder.CreateFAdd(L, R, &amp;quot;addtmp&amp;quot;);
  case &#39;-&#39;:
    return Builder.CreateFSub(L, R, &amp;quot;subtmp&amp;quot;);
  case &#39;*&#39;:
    return Builder.CreateFMul(L, R, &amp;quot;multmp&amp;quot;);
  case &#39;&amp;lt;&#39;:
    L = Builder.CreateFCmpULT(L, R, &amp;quot;cmptmp&amp;quot;);
    // Convert bool 0/1 to double 0.0 or 1.0
    return Builder.CreateUIToFP(L, Type::getDoubleTy(TheContext),
                                &amp;quot;booltmp&amp;quot;);
  default:
    return LogErrorV(&amp;quot;invalid binary operator&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二元操作符开始变得有趣.&lt;/p&gt;

&lt;p&gt;这里的基本思想: &lt;code&gt;我们递归地为表达式的左侧emit code, 然后是右侧, 然后我们计算二进制表达式的结果. 在这个代码中, 我们做一个简单的switch on the opcode来创建正确的LLVM 指令&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;在上面的例子中, LLVM Builder类开始显示其值. &lt;strong&gt;IRBuilder知道在哪里插入新创建的指令, 你所做的就是要指定什么指令将会被创建&lt;/strong&gt; (例如, 使用 &lt;strong&gt;CreateFAdd&lt;/strong&gt;), which &lt;strong&gt;使用哪些操作数(L and R here)&lt;/strong&gt; 并且optionally &lt;strong&gt;为生成的指令提供一个名字&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;关于LLVM, 一个不错的事情是名称就像一个提示.  例如, 如果上面的代码emit 多条 &amp;ldquo;addtmp&amp;rdquo; &lt;strong&gt;变量&lt;/strong&gt;, LLVM将自动地为每个变量提供一个递增的, 独特的数字suffix(后缀). 指令的本地值名称purely可选择的, but 它的名称应该要更方便我们阅读.&lt;/p&gt;

&lt;p&gt;LLVM 指令是被严格的规则所限制: For Example, &lt;strong&gt;一个指令的左边和右边的操作符一定要有相同的类型&lt;/strong&gt;, 并且add的&lt;strong&gt;结果类型一定要匹配操作数类型&lt;/strong&gt;. 因为in Kaleidoscope所有的值都是doubles, this makes for very simple code for add, sub, mul.&lt;/p&gt;

&lt;p&gt;在另一方面, LLVM 指定 &lt;strong&gt;fcmp&lt;/strong&gt; 指令总是返回一个 &amp;ldquo;i1&amp;rdquo; 值( 1 比特整型). 问题是 Kaleidoscope希望值是&lt;strong&gt;0.0&lt;/strong&gt;或者&lt;strong&gt;1.0&lt;/strong&gt;. 为了获得这些语义, 我们将&lt;strong&gt;fcmp指令&lt;/strong&gt;与&lt;strong&gt;uitofp指令&lt;/strong&gt;(unsigned integer to float point)结合起来. 该指令通过将它的输入整数转换为浮点值by 将输入视为无符号值. 相反, 如果我们使用&lt;strong&gt;sitofp指令&lt;/strong&gt;, The kaleidoscope &amp;lsquo;&amp;lt;&amp;rsquo; 操作符将会返回&lt;strong&gt;0.0&lt;/strong&gt;和&lt;strong&gt;-1.0&lt;/strong&gt;, 具体依赖于输入值.&lt;/p&gt;

&lt;h2 id=&#34;callexprast&#34;&gt;CallExprAST&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Value *CallExprAST::codegen() {
  // Look up the name in the global module table. 在全局module table中寻找name
  Function *CalleeF = TheModule-&amp;gt;getFunction(Callee);
  if (!CalleeF)
    return LogErrorV(&amp;quot;Unknown function referenced&amp;quot;);

  // If argument mismatch error.
  if (CalleeF-&amp;gt;arg_size() != Args.size())
    return LogErrorV(&amp;quot;Incorrect # arguments passed&amp;quot;);

  std::vector&amp;lt;Value *&amp;gt; ArgsV;
  for (unsigned i = 0, e = Args.size(); i != e; ++i) {
    ArgsV.push_back(Args[i]-&amp;gt;codegen());
    if (!ArgsV.back())
      return nullptr;
  }

  return Builder.CreateCall(CalleeF, ArgsV, &amp;quot;calltmp&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用LLVM来产生函数调用的codegen是相当简单直接的.&lt;/p&gt;

&lt;p&gt;上面的代码最开始会在LLVM Module&amp;rsquo;s 符号表中 寻找函数的名称. 回想一下, LLVM Module是一个可以包含我们正在执行的JIT函数的容器. 通过给每一个函数指定与用户指定的相同的名称, 我们可以使用LLVM 符号表来解析我们的函数名称.&lt;/p&gt;

&lt;p&gt;一旦我们有函数要调用, 我们递归地codegen(编码)每一个我们要传入的参数, 并且创建一个LLVM调用指令. 注意, LLVM默认使用本地的c调用规定, 允许这些调用来调用标准库函数(like &amp;ldquo;sin&amp;rdquo; and &amp;ldquo;cos&amp;rdquo;)是轻松的, 不需要任何额外的工作.&lt;/p&gt;

&lt;p&gt;这包含了我们对四个基本表达式(in Kaileidoscope)的处理. 当然, 你可以随意添加更多. 例如, 通过浏览 &lt;a href=&#34;http://llvm.org/docs/LangRef.html&#34;&gt;LLVM Language reference&lt;/a&gt;. 你将会找到其他一些有趣的指令, 并且将他们加到我们的框架中是非常简单的.&lt;/p&gt;

&lt;h1 id=&#34;3-4-function-code-generation&#34;&gt;3.4 Function Code Generation&lt;/h1&gt;

&lt;p&gt;函数申明和函数定义的代码生成要处理大量的细节, which 这使得它们的代码生成不如expression 的代码生成 漂亮, but 这允许我们说明一些重要的点.&lt;/p&gt;

&lt;h2 id=&#34;prototypeast&#34;&gt;PrototypeAST&lt;/h2&gt;

&lt;p&gt;首先, 我们先讨论函数申明的代码产生: 他们可以用于函数体, 也可以用于外部函数申明.&lt;/p&gt;

&lt;p&gt;The code starts with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Function *PrototypeAST::codegen() {
  // Make the function type:  double(double,double) etc.
  std::vector&amp;lt;Type*&amp;gt; Doubles(Args.size(),
                             Type::getDoubleTy(TheContext));
  FunctionType *FT =
    FunctionType::get(Type::getDoubleTy(TheContext), Doubles, false);

  Function *F =
    Function::Create(FT, Function::ExternalLinkage, Name, TheModule.get());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码将大量的功能集成到几行. First注意, 这个函数返回了一个&amp;rdquo;&lt;strong&gt;Function&lt;/strong&gt;&amp;ldquo;而不是&amp;rdquo;&lt;strong&gt;Value&lt;/strong&gt;&amp;rdquo;. 因为&amp;rdquo;prototype&amp;rdquo;是在讨论函数的外部接口(而不是表达式计算的值), 当codegen时, 返回LLVM Function是有意义的.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FunctionType::get&lt;/strong&gt;的调用创建&lt;strong&gt;FunctionType&lt;/strong&gt;(that 被用于给定的声明). 由于Kaleidoscope中所有的函数参数都是double类型的, 第一行创建了一个&amp;rdquo;N个double类型的vector&amp;rdquo;. 然后使用&lt;strong&gt;FunctionType::get&lt;/strong&gt;创建了接收N个double类型参数的函数. 返回一个double作为结果,(那不是可变参数(false表示这一点)). 注意 LLVM中类型是和常量一样唯一的, 所以你不用&amp;rdquo;new a type&amp;rdquo;, you &amp;ldquo;get&amp;rdquo; it.&lt;/p&gt;

&lt;p&gt;上面的最后一行实际上创建了与Prototype相对应的IR函数. 这表明了要使用的类型, 链接, 名称, 以及要插入的模块. &amp;ldquo;external linkage&amp;rdquo;意味着该函数可能在当前模块之外定义. and or 它能够被模块外面的函数所调用. 传入的名称是用户指定的名称: 由于指定了&amp;rdquo;TheModule&amp;rdquo;, 因此该名称在&amp;rdquo;TheModule&amp;rdquo;符号表中被注册.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Set names for all arguments. 设置所有参数的名称
unsigned Idx = 0;
for (auto &amp;amp;Arg : F-&amp;gt;args())
  Arg.setName(Args[Idx++]);

return F;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后, 我们根据Prototype中的名称设置每个函数参数的名称. 这一步并不是严格需要的, 但是保持名称的一致是IR的可读性更强, 并允许后面的代码直接引用其名称的参数, 而不需要在PrototypeAST中查找他们.&lt;/p&gt;

&lt;h2 id=&#34;functionast&#34;&gt;FunctionAST&lt;/h2&gt;

&lt;p&gt;我们有一个没有函数体的function prototype.  这是LLVM IR表示函数申明的方式. 对于在Kaileidoscope中的extern表达式来说, 这正是我们想要表达的. 然而对于函数定义来说,我们需要codegen并且attach a 函数体:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Function *FunctionAST::codegen() {
    // First, check for an existing function from a previous &#39;extern&#39; declaration.
  Function *TheFunction = TheModule-&amp;gt;getFunction(Proto-&amp;gt;getName());

  if (!TheFunction)
    TheFunction = Proto-&amp;gt;codegen();

  if (!TheFunction)
    return nullptr;

  if (!TheFunction-&amp;gt;empty())
    return (Function*)LogErrorV(&amp;quot;Function cannot be redefined.&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于函数定义来说, 我们首先在TheModule的符号表中搜索此函数的现有版本.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一种case是:using &amp;ldquo;extern&amp;rdquo; 语句时, 符号表就被创建了. 如果 Module::getFunction 返回 null, 则意味着不存在先前的版本, 所以我们就需要根据申明来进行Prototype Codegen.&lt;/li&gt;
&lt;li&gt;在另一种case中, 我们想要在我们开始之前, assert函数是empty(i.e. 还没有函数体)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Create a new basic block to start insertion into.  创建一个新的basic block 来插入.
BasicBlock *BB = BasicBlock::Create(TheContext, &amp;quot;entry&amp;quot;, TheFunction);
Builder.SetInsertPoint(BB);

// Record the function arguments in the NamedValues map. 在NamedValue mao中记录函数参数.
NamedValues.clear();
for (auto &amp;amp;Arg : TheFunction-&amp;gt;args())
  NamedValues[Arg.getName()] = &amp;amp;Arg;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们可以开始建立Builder了:&lt;/p&gt;

&lt;p&gt;第一行创建了一个&lt;strong&gt;new basic block(named &amp;ldquo;entry&amp;rdquo;)&lt;/strong&gt;, 被直接插入到函数中. 第二行告诉我们新的指令应该被插在&lt;strong&gt;new basic block&lt;/strong&gt;的末尾. 在LLVM中&lt;code&gt;Basic Block&lt;/code&gt;(define the &lt;strong&gt;Control Flow Graph&lt;/strong&gt;)是函数中重要的一部分. 因为我们没有任何控制流, 所以此时我们的函数只包含一个Block. &lt;strong&gt;we&amp;rsquo;ll fix this in Chapter 5&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;现在我们添加函数参数到&lt;strong&gt;NamedValues map&lt;/strong&gt;中(当然了, 首先它会被清空) 以便于它们可以被VariableExprAST节点所获取.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;if (Value *RetVal = Body-&amp;gt;codegen()) {
  // Finish off the function.
  Builder.CreateRet(RetVal);

  // Validate the generated code, checking for consistency.
  verifyFunction(*TheFunction);

  return TheFunction;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;一旦在&lt;strong&gt;设置了插入点&lt;/strong&gt;, 并且填充了&lt;strong&gt;NamedValues&lt;/strong&gt;之后, 我们调用codegen() 方法作为function的 root 表达式.&lt;/li&gt;
&lt;li&gt;如果没有error发生, &lt;strong&gt;this emits code&lt;/strong&gt;计算表达式到 &lt;strong&gt;entry block&lt;/strong&gt; 并返回计算出的值.&lt;/li&gt;
&lt;li&gt;假设没有error, 我们然后创建&lt;strong&gt;an LLVM ret instruction&lt;/strong&gt; (表示函数完成).&lt;/li&gt;
&lt;li&gt;一旦函数被构建后, 我们就会调用&lt;strong&gt;verifyFunction&lt;/strong&gt;(which provided by LLVM). 该函数对产生的IR做大量的一致性检测, 来确定是否我们的编译代码都是正确的. 使用它是相当重要地, 它能够捕获大量的bugs. 一旦一个函数完成并验证后, 我们就会返回它.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;  // Error reading body, remove function.
  TheFunction-&amp;gt;eraseFromParent();
  return nullptr;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后剩下的唯一一件事情就是处理error case. 简单起见, 我们仅仅通过使用&lt;strong&gt;earseFromParent&lt;/strong&gt;方法来删除我们Codegen的函数. 这允许用户重新定义他们之前输入错误的函数: 如果我们不删除它,  它将会继续保存在符号表中, 并且它还有body, 阻止我们之后定义.&lt;/p&gt;

&lt;p&gt;这代码有一个bug, 如果&lt;strong&gt;FunctionAST::codegen()&lt;/strong&gt;方法发现了一个存在的IR Function. 它不会根据自己的申明来验证其签名. 这意味着: 一个更早的&lt;code&gt;extern&lt;/code&gt;申明将会优先于函数定义的签名, 这可能导致codegen失败. 例如, 如果函数参数的名称不同.(what means ? 以后再研究)&lt;/p&gt;

&lt;p&gt;有很多方法可以解决这个问题, see what you can come up with! Here is a testcase:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;extern foo(a);     # ok, defines foo.
def foo(b) b;      # Error: Unknown variable name. (decl using &#39;a&#39; takes precedence).
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;3-5-driver-changes-and-closing-thoughts&#34;&gt;3.5 Driver Changes and Closing Thoughts&lt;/h1&gt;

&lt;p&gt;到目前为止, 除了我们可以查看漂亮的LLVM调用之外, LLVM的Codegen并没有给我们带来太多的帮助. The sample code 将对codegen的调用插入到 &amp;ldquo;HandleDefinition&amp;rdquo;, &amp;ldquo;HandleExtern&amp;rdquo;等函数中, 然后dump out the LLVM IR.&lt;/p&gt;

&lt;p&gt;这里有一个简单的方法来查看LLVM IR. Ex:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;ready&amp;gt; 4+5;
Read top-level expression:
define double @0() {
entry:
  ret double 9.000000e+00
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意 解析器是如何将顶级表达式转换为我们的anonymous函数. 当我们在下一章添加JIT Support时, 这会很便利.&lt;/p&gt;

&lt;p&gt;另外, 代码是literally transcribed, 除了IRBuilder会进行简单的常量折叠外, 不会执行任何优化. 下一章, 我们将会添加一些隐式地优化.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;ready&amp;gt; def foo(a b) a*a + 2*a*b + b*b;
Read function definition:
define double @foo(double %a, double %b) {
entry:
  %multmp = fmul double %a, %a
  %multmp1 = fmul double 2.000000e+00, %a
  %multmp2 = fmul double %multmp1, %b
  %addtmp = fadd double %multmp, %multmp2
  %multmp3 = fmul double %b, %b
  %addtmp4 = fadd double %addtmp, %multmp3
  ret double %addtmp4
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里展示了一些简单的表达式运算.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;ready&amp;gt; def bar(a) foo(a, 4.0) + bar(31337);
Read function definition:
define double @bar(double %a) {
entry:
  %calltmp = call double @foo(double %a, double 4.000000e+00)
  %calltmp1 = call double @bar(double 3.133700e+04)
  %addtmp = fadd double %calltmp, %calltmp1
  ret double %addtmp
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里展示了一些函数调用.&lt;/p&gt;

&lt;p&gt;Note 如果你调用它的话, 这个函数将会花大量时间来执行.&lt;/p&gt;

&lt;p&gt;在未来, 我们将会添加一些条件控制流来使递归变得可以使用.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;ready&amp;gt; extern cos(x);
Read extern:
declare double @cos(double)

ready&amp;gt; cos(1.234);
Read top-level expression:
define double @1() {
entry:
  %calltmp = call double @cos(double 1.234000e+00)
  ret double %calltmp
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里展示了一个extern for libm &amp;ldquo;cos&amp;rdquo; 函数, and call to it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;ready&amp;gt; ^D
; ModuleID = &#39;my cool jit&#39;

define double @0() {
entry:
  %addtmp = fadd double 4.000000e+00, 5.000000e+00
  ret double %addtmp
}

define double @foo(double %a, double %b) {
entry:
  %multmp = fmul double %a, %a
  %multmp1 = fmul double 2.000000e+00, %a
  %multmp2 = fmul double %multmp1, %b
  %addtmp = fadd double %multmp, %multmp2
  %multmp3 = fmul double %b, %b
  %addtmp4 = fadd double %addtmp, %multmp3
  ret double %addtmp4
}

define double @bar(double %a) {
entry:
  %calltmp = call double @foo(double %a, double 4.000000e+00)
  %calltmp1 = call double @bar(double 3.133700e+04)
  %addtmp = fadd double %calltmp, %calltmp1
  ret double %addtmp
}

declare double @cos(double)

define double @1() {
entry:
  %calltmp = call double @cos(double 1.234000e+00)
  ret double %calltmp
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当你退出demo时(在 linux 上通过CTRL+D,or  windows上通过CTRL+Z来发送EOF), 它将会显示该module产生的所有IR.&lt;/p&gt;

&lt;p&gt;这就是Kaleidoscope tutorial 第三章的内容.&lt;/p&gt;

&lt;p&gt;接下来, 我们会展示如何添加JIT Codegen和优化器支持, 以便于我们之后可以开始运行代码.&lt;/p&gt;

&lt;h1 id=&#34;3-6-full-code-listing&#34;&gt;3.6 Full Code Listing&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl03.html&#34;&gt;http://llvm.org/docs/tutorial/LangImpl03.html&lt;/a&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Kaleidoscope: Implementing a Parser and AST</title>
      <link>https://l0phtg.github.io/post/llvm/kaleidoscope-implementing-a-parser-and-ast/</link>
      <pubDate>Thu, 11 Apr 2019 15:41:17 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/llvm/kaleidoscope-implementing-a-parser-and-ast/</guid>
      
        <description>&lt;p&gt;translate from: &lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl02.html&#34;&gt;http://llvm.org/docs/tutorial/LangImpl02.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/docs-pic/dots/uml/ExprAst-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;介绍AST(抽象语法树)和Parser.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;2-1-introduction&#34;&gt;2.1 Introduction&lt;/h1&gt;

&lt;p&gt;本章介绍如何使用&lt;strong&gt;Lexer&lt;/strong&gt;, 来build一个完整的&lt;strong&gt;parser&lt;/strong&gt; for our Kaleidoscope language. 一旦我们有了parser, 我们将会定义并且build 一个 AST.&lt;/p&gt;

&lt;h1 id=&#34;2-2-ast&#34;&gt;2.2 AST&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/llvm/chapter2-AST.png&#34; alt=&#34;Chapter2 AST&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;2-3-parser-basic&#34;&gt;2.3 Parser Basic&lt;/h1&gt;

&lt;p&gt;现在我们有了AST, 我们需要定义parser code来build it. 这里的想法是我们要解析类似于&amp;rdquo;&lt;strong&gt;x+y&lt;/strong&gt;&amp;rdquo;(由词法分析器会返回3个Token)到AST中, 可以通过下面的代码产生:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto LHS = llvm::make_unique&amp;lt;VariableExprAST&amp;gt;(&amp;quot;x&amp;quot;);
auto RHS = llvm::make_unique&amp;lt;VariableExprAST&amp;gt;(&amp;quot;y&amp;quot;);
auto Result = std::make_unique&amp;lt;BinaryExprAST&amp;gt;(&#39;+&#39;, std::move(LHS),
                                              std::move(RHS));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Log&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// LogError* - These are little helper functions for error handling.
std::unique_ptr&amp;lt;ExprAST&amp;gt; LogError(const char *Str) {
  fprintf(stderr, &amp;quot;LogError: %s\n&amp;quot;, Str);
  return nullptr;
}
std::unique_ptr&amp;lt;PrototypeAST&amp;gt; LogErrorP(const char *Str) {
  LogError(Str);
  return nullptr;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;2-4-basic-expression-parsing&#34;&gt;2.4 Basic Expression Parsing&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;ParseNumberExpr&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// numberexpr ::= number
static std::unique_ptr&amp;lt;ExprAST&amp;gt; ParseNumberExpr() {
  auto Result = llvm::make_unique&amp;lt;NumberExprAST&amp;gt;(NumVal);
  getNextToken(); // consume the number
  return std::move(Result);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;ParseParenExpr&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;这里有一些有趣的点. 最主要的一点是 this routine eats all of the tokens that correspond to the production. 并且将next token返回到词法缓冲区中. (这不是一定要要求的), 这是一个实现递归下降parser的相当标准的写法.&lt;/p&gt;

&lt;p&gt;a better example, 括号运算符的parser defined like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// parenexpr ::= &#39;(&#39; expression &#39;)&#39;
static std::unique_ptr&amp;lt;ExprAST&amp;gt; ParseParenExpr() {  
  getNextToken(); // eat (.
  auto V = ParseExpression();
  if (!V)
    return nullptr;

  if (CurTok != &#39;)&#39;)
    return LogError(&amp;quot;expected &#39;)&#39;&amp;quot;);
  getNextToken(); // eat ).
  return V;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该函数说明了大量关于parser的有趣的事情:&lt;/p&gt;

&lt;p&gt;1) 展示了我们可以怎么样使用&lt;strong&gt;LogError&lt;/strong&gt;. 当被调用的时候, 该函数期待current token是 &amp;lsquo;&lt;strong&gt;(&lt;/strong&gt;&amp;rsquo;, 然后之后开始解析subexpression, (可能没有&amp;rsquo;)&amp;rsquo; waiting), 如果用户输入&amp;rdquo;(4 x&amp;rdquo; 代替 &amp;ldquo;(4)&amp;rdquo;, the parser应该弹一个error. 因为error发生了, parser需要一种方法来表明error发生时, 程序会做什么.在我们的解析器中, 当&lt;strong&gt;error&lt;/strong&gt;发生时, 我们会返回&lt;strong&gt;null&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;2) 另一个有趣的点是&lt;strong&gt;该函数使用了递归来调用ParserExpression&lt;/strong&gt;(我们不久将会看到&lt;strong&gt;ParserExpression&lt;/strong&gt;中调用了&lt;strong&gt;ParserParentExpr&lt;/strong&gt;). 这是一种处理递归语法的相当不错的方法. 并且它保证每个过程都十分simple. 注意, &lt;strong&gt;括号并不会引起AST node的构造&lt;/strong&gt;. 当我们这样做的时候, 括号最重要的角色就是&lt;strong&gt;知道parser来提供grouping&lt;/strong&gt;. 一旦parser成功构造了AST, 括号就不再被需要的.&lt;/p&gt;

&lt;p&gt;下面的例子是处理变量引用和函数调用:&lt;/p&gt;

&lt;p&gt;变量后面跟括号, 代表函数调用. 如果不是, 代码变量为identifier.&lt;/p&gt;

&lt;h1 id=&#34;2-5-binary-expression-parsing&#34;&gt;2.5 Binary Expression Parsing&lt;/h1&gt;

&lt;p&gt;二元表达式很难解析, 因为它们通常是模棱两可的. 例如, 当给 the string &amp;ldquo;x+y*z&amp;rdquo;, the parser可以选择&amp;rdquo;(x+y)*z&amp;rdquo;, 也可以选择&amp;rdquo;x+(y&lt;em&gt;z)&amp;ldquo;, 根据数学的定义, 我们的理解后面的是正确的. 因为 &amp;ldquo;&lt;/em&gt;&amp;ldquo;的优先级比&amp;rdquo;+&amp;ldquo;更高.&lt;/p&gt;

&lt;p&gt;有很多种方法来处理它, 但是一种优雅的和有效的方法是&lt;strong&gt;Operator-Precedence-Parsing&lt;/strong&gt;. 这种解析技术使用优先级来指导二元操作符递归处理. To start with, we need a table of precedences:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// BinopPrecedence - This holds the precedence for each binary operator that is
/// defined.
static std::map&amp;lt;char, int&amp;gt; BinopPrecedence;

/// GetTokPrecedence - Get the precedence of the pending binary operator token.
static int GetTokPrecedence() {
  if (!isascii(CurTok))
    return -1;

  // Make sure it&#39;s a declared binop.
  int TokPrec = BinopPrecedence[CurTok];
  if (TokPrec &amp;lt;= 0) return -1;
  return TokPrec;
}

int main() {
  // Install standard binary operators.
  // 1 is lowest precedence.
  BinopPrecedence[&#39;&amp;lt;&#39;] = 10;
  BinopPrecedence[&#39;+&#39;] = 20;
  BinopPrecedence[&#39;-&#39;] = 20;
  BinopPrecedence[&#39;*&#39;] = 40;  // highest.
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于Kaleidoscope基本的形式来说, 我们只支持4种二元操作符(很明显你可以扩展它, our brave and interpid reader). The &lt;strong&gt;GetTokPrecedence&lt;/strong&gt;返回目前token的优先级, 如果&lt;strong&gt;不是二元操作符的话, 返回 -1&lt;/strong&gt;. 通过一个map来增加一些操作符是一种不错的方法. 并且这很容易比较优先级.&lt;/p&gt;

&lt;p&gt;有了上面的定义, 我们就可以解析二元操作符了. 运算符优先级解析的基本思想是:&lt;strong&gt;将具有可能不明确的二元运算符的表达式分成多个&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Ex: 表达式&amp;rdquo;&lt;strong&gt;a+b+(c+d)*e*f+g&lt;/strong&gt;. operator precedence 将该表达式视为一个primary expressions流 separated by binary operators. 它将会先解析&lt;strong&gt;a&lt;/strong&gt;, 然后[+, b] [+, (c+d)] [&lt;em&gt;, e] [&lt;/em&gt;, f] and [+, g]. 注意括号也是primary expressions. 二元表达式不用担心它的subexpressions like (c+d) at all .&lt;/p&gt;

&lt;p&gt;To start, an expression is a primary expression. 可能后面跟着[binop, primaryexpr].&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// expression
///   ::= primary binoprhs
///
static std::unique_ptr&amp;lt;ExprAST&amp;gt; ParseExpression() {
  auto LHS = ParsePrimary();
  if (!LHS)
    return nullptr;

  return ParseBinOpRHS(0, std::move(LHS));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;ParseBinOpRHS&lt;/strong&gt;是一个函数来解析一系列的&lt;strong&gt;pairs&lt;/strong&gt;. 它需要一个优先级和指向表达式的指针.&lt;/p&gt;

&lt;p&gt;注意 that &amp;ldquo;&lt;strong&gt;x&lt;/strong&gt;&amp;rdquo; 是一个完全有效的表达式, 例如: &amp;ldquo;binoprhs&amp;rdquo; 可以是空的. 在这种情况下, it returns the expression that is passed into it. 在我们上面的例子中, 代码传递表达式&amp;rdquo;a&amp;rdquo;到ParseBinOpRHS 并且当前的token是 &amp;ldquo;+&amp;rdquo;;&lt;/p&gt;

&lt;p&gt;传递给ParseBinOpRHS的优先级值表示函数被允许eat 的 the minimal operator precedence.
例如, 如果目前的pair stream is [+, x] and ParseBinOpRHS被传递的优先级是40, 它将不会消耗任何tokens(因为&amp;rsquo;+&amp;lsquo;的优先级是20). 根据这种思想, ParseBinOpRHS starts with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// binoprhs
///   ::= (&#39;+&#39; primary)*
static std::unique_ptr&amp;lt;ExprAST&amp;gt; ParseBinOpRHS(int ExprPrec,
                                              std::unique_ptr&amp;lt;ExprAST&amp;gt; LHS) {
  // If this is a binop, find its precedence.
  while (1) {
    int TokPrec = GetTokPrecedence();

    // If this is a binop that binds at least as tightly as the current binop,
    // consume it, otherwise we are done.
    if (TokPrec &amp;lt; ExprPrec)
      return LHS;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该代码获得当前token的优先级, 并且检查它是否是too low. 因为我们定义无效的tokens的优先级是-1, 所以这隐式地可以知道(当run out of binary operators时, pair-stream就结束了).如果this check succeed, 我们知道token是一个二元表达式并且它将被included in this expression:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;    // Okay, we know this is a binop.
    int BinOp = CurTok;
    getNextToken();  // eat binop
    
    // Parse the primary expression after the binary operator.
    auto RHS = ParsePrimary();
    if (!RHS)
      return nullptr;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As such, this code eats(and remembers) 二元表达式 and 解析primary expression that follows. This build up the whole pair, the first of which is [+, b] for the running example.&lt;/p&gt;

&lt;p&gt;现在我们解析表达式的左边和一组RHS sequence, 我们不得不决定which way the expression associates. 特别地, 我们 have &amp;ldquo;(a+b)&amp;rdquo; binop unparsed or &amp;ldquo;a+(b binop unparsed&amp;rdquo;. 为了确定这个, 我们look ahead at &amp;ldquo;binop&amp;rdquo; to 确定它的优先级并且将它与BinOp&amp;rsquo;s 优先级比较(which is &amp;lsquo;+&amp;rsquo; in this case):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// If BinOp binds less tightly with RHS than the operator after RHS, let
// the pending operator take RHS as its LHS.
int NextPrec = GetTokPrecedence();
if (TokPrec &amp;lt; NextPrec) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果binop在&amp;rdquo;RHS&amp;rdquo;右侧的优先级低于或者等于我们当前运算符的优先级. in our example, 目前的操作符是&amp;rdquo;+&amp;rdquo; 并且下一个操作符是&amp;rdquo;+&amp;ldquo;, 我们明白他们有相同的优先级. in this case 我们将会创建node for &amp;ldquo;a+b&amp;rdquo;, and then continue parsing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;      ... if body omitted ...
    }

    // Merge LHS/RHS.
    LHS = llvm::make_unique&amp;lt;BinaryExprAST&amp;gt;(BinOp, std::move(LHS),
                                           std::move(RHS));
  }  // loop around to the top of the while loop.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在我们的例子中. 这将把 &amp;ldquo;a + b&amp;rdquo; into &amp;ldquo;(a + b)&amp;ldquo;并且来执行下一次循环的迭代. with &amp;ldquo;+&amp;rdquo; as the current token. 上面的代码将被eat, remember, and parse (&amp;ldquo;c + d&amp;rdquo;) as the primary expression, which makes the 目前的pair equal to [+, (c + d)]. 它将会评估上面的&amp;rdquo;if&amp;rdquo;条件, 并将&amp;rdquo;&lt;em&gt;&amp;ldquo;作为右侧的binop. 在该case中, 优先级 of &amp;ldquo;&lt;/em&gt;&amp;rdquo; 是比+的优先级更高, 因此if条件将会被输入.&lt;/p&gt;

&lt;p&gt;关键的问题是: if条件如何解析右边的全部? In particular, 为了在我们的例子中正确的build AST. 它需要将&amp;rdquo;(c + d)*e*f&amp;rdquo;作为RHS表达式变量. 执行该操作的代码相当简单.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;    // If BinOp binds less tightly with RHS than the operator after RHS, let
    // the pending operator take RHS as its LHS.
    int NextPrec = GetTokPrecedence();
    if (TokPrec &amp;lt; NextPrec) {
      RHS = ParseBinOpRHS(TokPrec+1, std::move(RHS));
      if (!RHS)
        return nullptr;
    }
    // Merge LHS/RHS.
    LHS = llvm::make_unique&amp;lt;BinaryExprAST&amp;gt;(BinOp, std::move(LHS),
                                           std::move(RHS));
  }  // loop around to the top of the while loop.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这一点上, 我们知道我们主要的RHS的二元运算符优于我们当前正在解析的binop. 因此, 我们知道任何运算符都优先于&amp;rdquo;+&amp;ldquo;的序列应该一起解析并作为&amp;rdquo;RHS&amp;rdquo;返回.&lt;/p&gt;

&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;

&lt;p&gt;递归构造.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;a+b*c*(d+e) + f&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;第一次循环:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!--1. [0, a] 和 [+, b]; [0, a] 为LHS; 0 &amp;lt; +,  [1+, b] 继续ParseBinOpRHS--&amp;gt;
&amp;lt;!--2. [+, b] 和 [*, c]; [+, b] 为LHS; + &amp;lt; *,  [*, c] 继续ParseBinOpRHS--&amp;gt;
&amp;lt;!--3. [*, c] 和 [(), d+e]; [*, c]为LHS     --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;mermaid&#34;&gt;
graph TB
    1((a)) 
    2((b))
    3((c))
    4((d))
    5((e))
    
    7((+))
    8((*))
    9((*))
    10((+))
    
    7 --&gt; 1
    
    8 --&gt; 2
    8 --&gt; 3
    9 --&gt; 8
    9 --&gt; 10
    10 --&gt; 4
    10 --&gt; 5
    
    7 --&gt; 9
&lt;/div&gt;

&lt;p&gt;第二次循环&lt;/p&gt;

&lt;div class=&#34;mermaid&#34;&gt;
graph TB
    1((a)) 
    2((b))
    3((c))
    4((d))
    5((e))
    6((f))
    7((+))
    8((*))
    9((*))
    10((+))
    11((+))
    
    7 --&gt; 1
    
    8 --&gt; 2
    8 --&gt; 3
    9 --&gt; 8
    9 --&gt; 10
    10 --&gt; 4
    10 --&gt; 5
    
    7 --&gt; 9
    
    subgraph TB
    11 --&gt; 7
    11 --&gt; 6
    end
&lt;/div&gt;

&lt;h1 id=&#34;2-6-parse-the-rest&#34;&gt;2.6 Parse the Rest&lt;/h1&gt;

&lt;p&gt;下一件事情是解析函数申明. in Kaleidoscope, &lt;code&gt;extern&lt;/code&gt;函数申明以及函数体定义. 代码是相当直接的, not very interesting(once you&amp;rsquo;re survived expressions):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// prototype
///   ::= id &#39;(&#39; id* &#39;)&#39;
static std::unique_ptr&amp;lt;PrototypeAST&amp;gt; ParsePrototype() {
  if (CurTok != tok_identifier)
    return LogErrorP(&amp;quot;Expected function name in prototype&amp;quot;);

  std::string FnName = IdentifierStr;
  getNextToken();

  if (CurTok != &#39;(&#39;)
    return LogErrorP(&amp;quot;Expected &#39;(&#39; in prototype&amp;quot;);

  // Read the list of argument names.
  std::vector&amp;lt;std::string&amp;gt; ArgNames;
  while (getNextToken() == tok_identifier)
    ArgNames.push_back(IdentifierStr);
  if (CurTok != &#39;)&#39;)
    return LogErrorP(&amp;quot;Expected &#39;)&#39; in prototype&amp;quot;);

  // success.
  getNextToken();  // eat &#39;)&#39;.

  return llvm::make_unique&amp;lt;PrototypeAST&amp;gt;(FnName, std::move(ArgNames));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然了, 函数定义是相当简单的, just &lt;strong&gt;一个申明&lt;/strong&gt;加&lt;strong&gt;一个表达式&lt;/strong&gt;来实现函数体.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// definition ::= &#39;def&#39; prototype expression
static std::unique_ptr&amp;lt;FunctionAST&amp;gt; ParseDefinition() {
  getNextToken();  // eat def.
  auto Proto = ParsePrototype();
  if (!Proto) return nullptr;

  if (auto E = ParseExpression())
    return llvm::make_unique&amp;lt;FunctionAST&amp;gt;(std::move(Proto), std::move(E));
  return nullptr;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，我们支持&lt;code&gt;extern&lt;/code&gt;来声明&lt;code&gt;sin&lt;/code&gt;和&lt;code&gt;cos&lt;/code&gt;之类的函数，以及支持用户函数的前向声明。这些&lt;code&gt;extern&lt;/code&gt;只是没有身体的原型:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// external ::= &#39;extern&#39; prototype
static std::unique_ptr&amp;lt;PrototypeAST&amp;gt; ParseExtern() {
  getNextToken();  // eat extern.
  return ParsePrototype();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后, 我们让用户输入任意顶级表达式并evaluate them. 我们将会处理this by defining anonymous nullary(zero argument) functions for them:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// toplevelexpr ::= expression
static std::unique_ptr&amp;lt;FunctionAST&amp;gt; ParseTopLevelExpr() {
  if (auto E = ParseExpression()) {
    // Make an anonymous proto.
    auto Proto = llvm::make_unique&amp;lt;PrototypeAST&amp;gt;(&amp;quot;&amp;quot;, std::vector&amp;lt;std::string&amp;gt;());
    return llvm::make_unique&amp;lt;FunctionAST&amp;gt;(std::move(Proto), std::move(E));
  }
  return nullptr;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们have all the pieces, let&amp;rsquo;s build a little driver that will let us actually execute this code we&amp;rsquo;ve built!&lt;/p&gt;

&lt;h1 id=&#34;2-7-the-driver&#34;&gt;2.7 The Driver&lt;/h1&gt;

&lt;p&gt;The Driver仅仅是通过调用所有的解析pieces.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// top ::= definition | external | expression | &#39;;&#39;
static void MainLoop() {
  while (1) {
    fprintf(stderr, &amp;quot;ready&amp;gt; &amp;quot;);
    switch (CurTok) {
    case tok_eof:
      return;
    case &#39;;&#39;: // ignore top-level semicolons.
      getNextToken();
      break;
    case tok_def:
      HandleDefinition();
      break;
    case tok_extern:
      HandleExtern();
      break;
    default:
      HandleTopLevelExpression();
      break;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一件有趣的事情是:  我们忽略了顶级&amp;rdquo;;&amp;ldquo;.&lt;/p&gt;

&lt;h1 id=&#34;2-8-conclusions&#34;&gt;2.8 Conclusions&lt;/h1&gt;

&lt;p&gt;通过这仅仅400行的代码, 我们定义了我们的最小的语言, 包含一个词法分析器, 解析器, 和AST builder.&lt;/p&gt;

&lt;p&gt;这是一个简单的交互例子:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./a.out
ready&amp;gt; def foo(x y) x+foo(y, 4.0);
Parsed a function definition.
ready&amp;gt; def foo(x y) x+y y;
Parsed a function definition.
Parsed a top-level expr
ready&amp;gt; def foo(x y) x+y );
Parsed a function definition.
Error: unknown token when expecting an expression
ready&amp;gt; extern sin(a);
ready&amp;gt; Parsed an extern
ready&amp;gt; ^D
$
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;2-9-full-code-listing&#34;&gt;2.9 Full Code Listing&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl02.html#the-abstract-syntax-tree-ast&#34;&gt;http://llvm.org/docs/tutorial/LangImpl02.html#the-abstract-syntax-tree-ast&lt;/a&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Kaleidoscope: Tutorial Introduction and Lexer</title>
      <link>https://l0phtg.github.io/post/kaleidoscope-tutorial-introduction-and-lexer/</link>
      <pubDate>Wed, 10 Apr 2019 10:17:08 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/kaleidoscope-tutorial-introduction-and-lexer/</guid>
      
        <description>&lt;p&gt;translate from &lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl01.html&#34;&gt;http://llvm.org/docs/tutorial/LangImpl01.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本tutorial将会介绍一个简单语言的实现.
&lt;/p&gt;

&lt;h1 id=&#34;1-1-tutorial-introduction&#34;&gt;1.1 Tutorial Introduction&lt;/h1&gt;

&lt;h1 id=&#34;1-2-the-basic-language&#34;&gt;1.2 The Basic Language&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;Kaleidoscope&lt;/code&gt;是一个过程语言. 它允许你定义函数, 使用条件分支, math, etc.&lt;/p&gt;

&lt;p&gt;在本tutorial中,  我们将会扩展Kaleidoscope来支持&lt;strong&gt;if/then/else 判断&lt;/strong&gt;, &lt;strong&gt;for循环&lt;/strong&gt;, &lt;strong&gt;用户自定义operators&lt;/strong&gt;, &lt;strong&gt;用一个简单的命令行接口的JIT 编译&lt;/strong&gt; , etc.&lt;/p&gt;

&lt;p&gt;因为我们都想要把事情做的简单. 所以in Kaleidoscope中, 唯一的数据类型是&lt;strong&gt;64-bit floating point type&lt;/strong&gt;. 因此, 所有的values都隐式地&lt;strong&gt;double&lt;/strong&gt;类型.&lt;/p&gt;

&lt;p&gt;下面是使用Kaleidoscope来计算Fibonacci numbers的一个simple example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//Compute the x&#39;th fibonacci number.
def fib(x)
    if x &amp;lt; 3 then 
        1
    else
        fib(x-1) + fib(x-2)

# This expression will compute the 40th number        
fib(40)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们也允许Kaleidoscope来调用标准库函数. 这意味着, 你可以在函数前面加关键字&amp;rdquo;&lt;strong&gt;extern&lt;/strong&gt;&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;For Example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;extern sin(arg);
extern cos(arg);
extern atan2(arg2, arg2);

atan2(sin(.4), cos(42))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第6章包含更有趣的例子, 我们使用Kaleidoscope写了一个小型应用 display a Mandelbrot Set at various levels of magnification.&lt;/p&gt;

&lt;p&gt;下面让我们探究Kaleidoscope的实现吧!!!.&lt;/p&gt;

&lt;h1 id=&#34;1-3-lexer&#34;&gt;1.3 Lexer&lt;/h1&gt;

&lt;p&gt;Token类型:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// The lexer returns tokens [0-255] if it is an unknown character, otherwise one
// of these for known things.
enum Token {
  tok_eof = -1,

  // commands
  tok_def = -2,
  tok_extern = -3,

  // primary
  tok_identifier = -4,
  tok_number = -5,
};

static std::string IdentifierStr; // Filled in if tok_identifier
static double NumVal;             // Filled in if tok_number
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从标准输入中返回next token&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// gettok - Return the next token from standard input.
static int gettok() {
  static int LastChar = &#39; &#39;;

  // Skip any whitespace.
  while (isspace(LastChar))
    LastChar = getchar();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;判断token是否为标识符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;if (isalpha(LastChar)) { // identifier: [a-zA-Z][a-zA-Z0-9]*
  IdentifierStr = LastChar;
  while (isalnum((LastChar = getchar())))
    IdentifierStr += LastChar;

  if (IdentifierStr == &amp;quot;def&amp;quot;)
    return tok_def;
  if (IdentifierStr == &amp;quot;extern&amp;quot;)
    return tok_extern;
  return tok_identifier;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;判断token是否为数字&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;if (isdigit(LastChar) || LastChar == &#39;.&#39;) {   // Number: [0-9.]+
  std::string NumStr;
  do {
    NumStr += LastChar;
    LastChar = getchar();
  } while (isdigit(LastChar) || LastChar == &#39;.&#39;);

  NumVal = strtod(NumStr.c_str(), 0);
  return tok_number;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;判断是否为注释&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;if (LastChar == &#39;#&#39;) {
  // Comment until end of line.
  do
    LastChar = getchar();
  while (LastChar != EOF &amp;amp;&amp;amp; LastChar != &#39;\n&#39; &amp;amp;&amp;amp; LastChar != &#39;\r&#39;);

  if (LastChar != EOF)
    return gettok();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是否文件末尾&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Check for end of file.  Don&#39;t eat the EOF.
if (LastChar == EOF)
      return tok_eof;

// Otherwise, just return the character as its ascii value.
int ThisChar = LastChar;
LastChar = getchar();
return ThisChar;
}
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>Static Single Assignment</title>
      <link>https://l0phtg.github.io/post/llvm/static-single-assignment/</link>
      <pubDate>Tue, 09 Apr 2019 21:54:49 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/llvm/static-single-assignment/</guid>
      
        <description>&lt;p&gt;translate from: &lt;a href=&#34;https://en.wikipedia.org/wiki/Static_single_assignment_form&#34;&gt;https://en.wikipedia.org/wiki/Static_single_assignment_form&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;单一变量赋值
&lt;img src=&#34;https://l0phtg.github.io/llvm/SSA_example1.2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;每个变量只被赋值一次.&lt;/p&gt;

&lt;p&gt;在编译器设计中, &lt;strong&gt;static single assigment form&lt;/strong&gt; (经常被称为&lt;strong&gt;SSA form&lt;/strong&gt; 或者 简化为 &lt;strong&gt;SSA&lt;/strong&gt;) 是IR的属性. 这要求每个变量只被assigment一次, 并且变量要在使用前定义. 原始IR中的已经存在的变量被划分为多个版本, 新的变量在文本中被显示为原始变量名称加下标的, 以便于每一个定义都有他们自己的版本.&lt;/p&gt;

&lt;h1 id=&#34;benefits&#34;&gt;Benefits&lt;/h1&gt;

&lt;p&gt;SSA的主要用途: 来自于它通过简化变量的属性来同时简化和改进各种编译器优化的结果.&lt;/p&gt;

&lt;p&gt;例如, 考虑这段代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;y := 1
y := 2
x := y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以一眼就看到第一行代码是不必要的, 第三行使用的y的值来自于第二行y的赋值. 一个程序必须执行 &lt;strong&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Reaching_definition&#34;&gt;reaching definition analysis&lt;/a&gt;&lt;/strong&gt; to 决定这个. 但是如果一个程序是SSA形式, 这些都是直接的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;y1 := 1
y2 := 2
x1 := y2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过SSA的包含使用, &lt;a href=&#34;https://en.wikipedia.org/wiki/Optimizing_compiler&#34;&gt;编译器优化&lt;/a&gt;
算法增强了很多:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Constant propagation 常量传播&lt;/li&gt;
&lt;li&gt;Value range propagation&lt;/li&gt;
&lt;li&gt;Sparse conditional constant propagation&lt;/li&gt;
&lt;li&gt;Dead code elimination&lt;/li&gt;
&lt;li&gt;Global value numbering          全局值编号&lt;/li&gt;
&lt;li&gt;Partial redundancy elimination  部分冗余代码消除&lt;/li&gt;
&lt;li&gt;Strength reduction&lt;/li&gt;
&lt;li&gt;Register allocation&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;converting-to-ssa&#34;&gt;Converting to SSA&lt;/h1&gt;

&lt;p&gt;将普通代码转换为SSA形式主要是通过&lt;strong&gt;使用新变量替换每个赋值的目标&lt;/strong&gt;.
and replacing each use of a variable with the &amp;ldquo;version&amp;rdquo; of the variable reaching that point.&lt;/p&gt;

&lt;p&gt;例如, consider the following &lt;a href=&#34;https://en.wikipedia.org/wiki/Control-flow_graph&#34;&gt;control flow graph&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/llvm/SSA_example1.1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;更改 &amp;ldquo;x -&amp;gt; x - 3&amp;rdquo; 左侧的名称, 并将之后对x的使用更改为新名称将使程序保持不变. 这可以通过在ssa中创建两个新的变量: x1 and x2 来利用, 每个变量只被分配一次. 同样, 给所有其他的变量也赋予不一样的下标.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/llvm/ssa-example1.2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;每一个使用都是很清楚的, 除了&lt;strong&gt;one case: 在底部block中,$\bold{y}$的使用应该是$\bold{y_1}$还是$\bold{y_2}$呢?&lt;/strong&gt; 取决于控制流的path.&lt;/p&gt;

&lt;p&gt;为了解决这个问题&lt;/p&gt;

&lt;p&gt;在最后的块中插入了一个特殊语句$\bold{\phi(phi)} $  函数. 这个表达式将会产生$\bold{y}$的新的定义, 通过选择$\bold{ y_1}$或者$\bold{y_2}$(取决于过去的控制流).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/llvm/ssa-example1.3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在, 最后一个块可以轻松使用$\bold{y_3}$ , 并且可以获得正确的值. 一个$\bold{\phi}$ 函数 for $\bold{x}$ 是不必要的: 因为只有一个$\bold{x}$ 的版本. （换句话说: $\bold{\phi(x_2, x_2) = x_2}$ 是不必要的.&lt;/p&gt;

&lt;p&gt;给定任意一个控制流图, 很难说出&lt;strong&gt;哪里需要插入 $\bold{\phi}$函数, and for which variables&lt;/strong&gt; .&lt;/p&gt;

&lt;p&gt;这个普遍的问题有一个有效的解决方案: &lt;strong&gt;dominance frontiers(支配边界)&lt;/strong&gt; . (see below)&lt;/p&gt;

&lt;p&gt;在大多数机器上: $\bold{\phi}$函数都没有被实现作为一个机器操作.&lt;/p&gt;

&lt;p&gt;编译器只需在存储器(或者相同的寄存器)中即可轻松地实现$\bold{\phi}$ 函数.  (存储器或寄存器作为一个$\bold{\phi}$函数输入的任何操作的目的地).  然而, 当simultaneous operations are speculatively producing inputs to a $\bold{\phi}$ 函数(就像很多机器上发生的那样), 该方法就不起作用了.&lt;/p&gt;

&lt;p&gt;通常, 大多数机器都有一个选择指令被用于该情况中, 这可以被我们的编译器用于实现$\bold{\phi}$函数.&lt;/p&gt;

&lt;p&gt;根据 Kenny Zadeck , $\bold{\phi}$ 函数最初被称为phony functions. 正式的名字是在学术paper上第一次发表时引入的.&lt;/p&gt;

&lt;h2 id=&#34;computing-minimal-ssa-using-dominance-frontiers-使用dominance边界计算最小的ssa&#34;&gt;computing minimal SSA using dominance frontiers(使用dominance边界计算最小的SSA)&lt;/h2&gt;

&lt;p&gt;首先, 我们需要了解&lt;strong&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Dominator_(graph_theory)&#34;&gt;dominator&lt;/a&gt;&lt;/strong&gt;的概念: 如果&lt;strong&gt;不先经过节点 A 就到不了节点 B&lt;/strong&gt;, 我们就称节点 A 在控制流中严格支配节点 B. 这很有用, 因为如果我们已经到达节点 B , 就证明 A 中的代码也都正在工作. 如果 &lt;strong&gt;A 严格支配 B&lt;/strong&gt; 或者 A = B, 我们就说 A dominates B ( 或者 B is dominated by A)&lt;/p&gt;

&lt;p&gt;现在, 我们可以定义 the &lt;strong&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Dominator_(graph_theory)&#34;&gt;dominance frontier&lt;/a&gt;&lt;/strong&gt; : 如果节点 A 不严格支配节点 B, 但是支配了一些 B的前面节点(predecessor), 就称为节点 B 在节点 A 的*dominace frontier*中. ( 可能节点 A 是 节点 B 的直接前节点. 然后, 因为任何节点都 &lt;em&gt;dominates&lt;/em&gt; 它自身, 并且节点 A &lt;em&gt;dominates&lt;/em&gt; 它自身, 所以节点 B 是处于节点 A的支配边界).&lt;/p&gt;

&lt;p&gt;从 A 的角度看, 那是在其他控制路径上不经过A的 最早出现的节点.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Dominance frontiers&lt;/em&gt; 可以精准地确定我们需要$\bold{\phi}$ 函数的地方:  如果节点A定义了某个变量, then that definition and that definition alone (or redefinitions) will reach every node A dominates. 只有当我们离开这些节点并进入&lt;em&gt;dominance frontiers&lt;/em&gt; 时,我们必须考虑其他流是否引入了相同变量的另外一个定义.此外, 控制流图中不需要处理其他 $\bold{\phi}$ 函数, 我们可以做到 no less.&lt;/p&gt;

&lt;p&gt;一个算法可以用来计算&lt;em&gt;dominance frontier set&lt;/em&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for each node b
   dominance_frontier(b) := {}
for each node b
    if the number of immediate predecessors of b ≥ 2
        for each p in immediate predecessors of b
            runner := p
            while runner ≠ idom(b)
                dominance_frontier(runner) := dominance_frontier(runner) ∪ { b }
                runner := idom(runner)
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>Dominator(graph Theory)</title>
      <link>https://l0phtg.github.io/post/dominatorgraph-theory/</link>
      <pubDate>Sat, 06 Apr 2019 18:00:53 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/dominatorgraph-theory/</guid>
      
        <description>&lt;p&gt;translate from : &lt;a href=&#34;https://en.wikipedia.org/wiki/Dominator_(graph_theory)&#34;&gt;https://en.wikipedia.org/wiki/Dominator_(graph_theory)&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;最近在学习SSA(Static Single Assignment)时, 遇到了${dominance frontier}$的概念, 所以google之, 简单翻译了一下wikipedia上对Dominator内容的介绍.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;dominator-graph-theory&#34;&gt;Dominator (graph theory)&lt;/h1&gt;

&lt;p&gt;在计算机科学中, 在控制流图中, 如果从入口点到节点 $\bold{n}$ 的每条路径都经过节点 $\bold{d}$, 则称节点 $\bold{d}$ dominates 节点 $\bold{n}$&lt;/p&gt;

&lt;p&gt;被写作 $\bold{d}$ dom $\bold{n}$ (or $\bold{d} \gg \bold {n}$).&lt;/p&gt;

&lt;p&gt;另外我们定义, 每个节点都 dominates 它自身.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/llvm/300px-Dominator_control_flow_graph.svg.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这里有一些相关的概念:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;节点 $\bold{d}$ &lt;em&gt;strictly dominates&lt;/em&gt; (严格支配) 节点 $\bold {n} $ : $\bold{d}$ dominates $\bold{n}$ 并且 $\bold{d} $ 与 $\bold{n}$ 不相等.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;节点 $\bold{n}$ 的 &lt;em&gt;immediate dominator&lt;/em&gt; (直接支配者) or &lt;strong&gt;idom&lt;/strong&gt; : 一个节点严格支配 $\bold{n}$ 但是不严格支配其他严格支配$\bold{n}$ 的节点. 除了入口点之外, 每一个节点都有一个直接支配者.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;节点 $\bold{d}$ 的 &lt;em&gt;dominance frontier&lt;/em&gt; :  所有节点$\bold{n}$ 的集合, 使得 $\bold{d}$ 支配 $\bold{n}$ 的 immediate predecessor. 但是 $\bold{d} $ 不严格支配节点 $\bold{n}$ . 这是一组 $\bold{d&amp;rsquo;s}$ dominance 停止的节点集合.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一个 &lt;em&gt;dominator tree&lt;/em&gt; : 一颗树, 这棵树每个节点的子节点是它直接支配的节点. 因为直接支配者是独一无二的, 所以它是一棵树. 开始节点是树的根节点.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;$\color{black}{dom}$&lt;/th&gt;
&lt;th&gt;$\color{Gray}{1}$&lt;/th&gt;
&lt;th&gt;$\color{Red}{2}$&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;$\color{black}{dom}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$\color{Gray}{2}$&lt;/td&gt;
&lt;td&gt;$\color{Red}{3}$&lt;/td&gt;
&lt;td&gt;$\color{Red}{4}$&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;$\color{Red}{6}$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;$\color{black}{dom}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$\color{Gray}{3}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;$\color{black}{dom}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$\color{Gray}{4}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;$\color{black}{dom}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$\color{Gray}{5}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;$\color{black}{dom}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$\color{Gray}{6}$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;与 domination关系相对应&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$灰色的节点\color{Gray}{灰色的节点}$ 是 非严格 dominated&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$红色的节点\color{Red}{红色的节点}$ 是 直接 dominated&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;dominator tree:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/llvm/300px-Dominator_tree.svg.png&#34; alt=&#34;dominator tree&#34; /&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>如果你冲动删除了python</title>
      <link>https://l0phtg.github.io/post/%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%86%B2%E5%8A%A8%E5%88%A0%E9%99%A4%E4%BA%86python/</link>
      <pubDate>Tue, 02 Apr 2019 21:12:17 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%86%B2%E5%8A%A8%E5%88%A0%E9%99%A4%E4%BA%86python/</guid>
      
        <description>&lt;p&gt;在你经历了痛苦的pip安装, 各种报错之后. 一气之前, 你决定卸载python, 重新安装. 那么, 既然要卸载, 就要卸载的彻底!&lt;/p&gt;

&lt;p&gt;所以你输入了下面的几行命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#hahaha
$sudo apt remove python
$sudo apt remove python3
$sudo apt remove pip
$sudo apt remove pip3
#一定删除的不彻底, 我要彻底删除
$sudo apt autoremove -f 
看到要删除600+M, 毅然决然的按了 y.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;Bingo 然后你看到了我这篇文章.
&lt;/p&gt;

&lt;h1 id=&#34;一-基础知识&#34;&gt;一、基础知识&lt;/h1&gt;

&lt;h2 id=&#34;1-重新安装python和pip&#34;&gt;1. 重新安装python和pip&lt;/h2&gt;

&lt;h3 id=&#34;1-1-安装python&#34;&gt;1.1 安装python&lt;/h3&gt;

&lt;p&gt;由于ubuntu16.04默认安装的python版本是 &lt;strong&gt;python2.7&lt;/strong&gt;  和 &lt;strong&gt;python3.5&lt;/strong&gt; .&lt;/p&gt;

&lt;p&gt;所以&lt;strong&gt;为了满足系统的需要&lt;/strong&gt;, 我们&lt;strong&gt;需要重新安装python2.7 和 python3.5&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;安装方式很简单:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#安装python2.7和python3.5
$sudo apt install python  # 默认安装的python2.7
$sudo apt install python3 # 默认安装的python3.5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除此之外, 我们还需要安装一些&lt;strong&gt;python的dev库&lt;/strong&gt; ,  因为系统和很多软件运行时都依赖它(这也是我们删除python 并 autoremove后, 发现系统gg的一部分原因)&lt;/p&gt;

&lt;p&gt;安装方式同样很简单:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#安装dev库
$sudo apt install libpython2.7 libpython2.7-dev
$sudo apt install libpython3.5 libpython3.5-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: 虽然系统的apt源不直接提供python3.6以及更高版本的python程序. 但是&lt;strong&gt;提供了python全版本的libdev库&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;所以, 如果你想要安装&lt;strong&gt;libpython3.6&lt;/strong&gt;的话, 也是可以的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#安装python3.6的dev库
$sudo apt install libpython3.6 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是如果想要安装&lt;strong&gt;python3.6&lt;/strong&gt;及以上的包, 该怎么办呢?&lt;/p&gt;

&lt;p&gt;方法有很多, 这里推荐&lt;strong&gt;源安装的方式&lt;/strong&gt; :&lt;/p&gt;

&lt;p&gt;可以参考(&lt;a href=&#34;https://linuxize.com/post/how-to-install-python-3-7-on-ubuntu-18-04/&#34;&gt;https://linuxize.com/post/how-to-install-python-3-7-on-ubuntu-18-04/&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;具体操作:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 安装python3.6 above
$sudo apt update
$sudo apt install software-properties-common

$sudo add-apt-repository ppa:deadsnakes/ppa   #加入python源, 并按[enter]确认

$sudo apt update      # 之后重新更新我们的源库

# 现在就可以安装python的其他版本了
$sudo apt install python3.6       # 例如你想安装python3.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/life/python-install.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;1-2-安装pip&#34;&gt;1.2 安装pip&lt;/h3&gt;

&lt;p&gt;安装pip, 这里只推荐一种方式:&lt;/p&gt;

&lt;p&gt;参照官方安装文档: &lt;a href=&#34;https://pip.pypa.io/en/stable/installing/&#34;&gt;https://pip.pypa.io/en/stable/installing/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首先, 下载&lt;strong&gt;get-pip.py&lt;/strong&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#使用curl命令(如果未安装, 先{sudo apt install curl}) 来下载get-pip.py  
$curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py # 下载get-pip.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后, 安装&lt;strong&gt;你需要的pip版本&lt;/strong&gt; , (注意: 这里有&lt;strong&gt;全局安装&lt;/strong&gt;和&lt;strong&gt;user安装&lt;/strong&gt; 两种方式) :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#安装pip3.6
$ sudo python3.6 get-pip.py    # 全局安装

$ python3.6 get-pip.py --user  # user安装
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-pip使用&#34;&gt;2. pip使用&lt;/h2&gt;

&lt;h3 id=&#34;2-1-全局安装package和user安装package&#34;&gt;2.1 全局安装package和user安装package&lt;/h3&gt;

&lt;p&gt;我们在使用pip 安装 &lt;strong&gt;package&lt;/strong&gt; 时, 有两种选择:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;全局安装&lt;/strong&gt; package, 对所有系统用户生效&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; 
$sudo pip2.7 install {package}   # python2.7使用pip2.7安装package 
$sudo pip3.5 install {package}   # python3.5使用pip3.5安装package 
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;user安装&lt;/strong&gt; package, 只对user(当前用户生效)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#
$pip2.7 install --user {package} 
$pip3.5 install --user {package}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相信&lt;strong&gt;sudo&lt;/strong&gt;和&lt;strong&gt;&amp;ndash;user&lt;/strong&gt;大家一眼就可以看到.&lt;/p&gt;

&lt;p&gt;那么除了这两个地方的不同, 还有哪些不同值得我们了解的呢?&lt;/p&gt;

&lt;h3 id=&#34;2-2-两种安装package方式的不同&#34;&gt;2.2 两种安装package方式的不同&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;dist-packages&lt;/strong&gt; : 这是我们package安装后的存放目录.&lt;/p&gt;

&lt;p&gt;肯定地, &lt;strong&gt;全局安装&lt;/strong&gt;和 &lt;strong&gt;user安装&lt;/strong&gt; 的&lt;strong&gt;package存放路径是不同的&lt;/strong&gt; .&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;全局安装&lt;/strong&gt;时的&lt;strong&gt;package存放路径&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 
$sudo pip3.6 --version
pip 19.0.3 from /usr/local/lib/python3.6/dist-packages/pip (python 3.6)
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;user安装&lt;/strong&gt;时的&lt;strong&gt;package存放路径&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#
$ pwd             # 查看当前绝对路径
/home/l0phtg

$ pip3.6 install --user neovim  # 注意这里显示的路径是相对路径
Requirement already satisfied: neovim in ./.local/lib/python3.6/site-packages (0.3.1)
Requirement already satisfied: pynvim&amp;gt;=0.3.1 in ./.local/lib/python3.6/site-packages (from neovim) (0.3.2)
Requirement already satisfied: msgpack&amp;gt;=0.5.0 in ./.local/lib/python3.6/site-packages (from pynvim&amp;gt;=0.3.1-&amp;gt;neovim) (0.6.1)
Requirement already satisfied: greenlet in ./.local/lib/python3.6/site-packages (from pynvim&amp;gt;=0.3.1-&amp;gt;neovim) (0.4.15)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即&lt;strong&gt;user安装python3.6的package时&lt;/strong&gt;, package 默认存放在了 &lt;strong&gt;~/.local/lib/python3.6/site-packages&lt;/strong&gt; .路径下.&lt;/p&gt;

&lt;h1 id=&#34;二-安装被你意外删掉的库&#34;&gt;二、 安装被你意外删掉的库&lt;/h1&gt;

&lt;p&gt;在安装了前面所需的python2.7, python3.5, pip2.7, pip3.5, libpython2.7,  libpython2.7-dev, libpython3.5, libpython3.5-dev 之后, 你需要安装ubuntu系统的一些库.&lt;/p&gt;

&lt;p&gt;ubuntu系统所需的库为&lt;strong&gt;ubuntu-minimal, ubuntu-standard, ubuntu-desktop&lt;/strong&gt; .&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$sudo apt install ubuntu-minimal ubuntu-standard ubuntu-desktop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时, 系统就已经可以&lt;strong&gt;正常启动, 并正常进入和显示桌面&lt;/strong&gt; 了.&lt;/p&gt;

&lt;p&gt;最后,  因为你的操作, 可能导致&lt;strong&gt;一些三方应用不能启动&lt;/strong&gt; , 这时你只能自行重装了.&lt;/p&gt;

&lt;p&gt;我这里已经知道的影响到的三方软件为: Chrome浏览器, wps.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>本科应届生安全岗面试总结</title>
      <link>https://l0phtg.github.io/post/%E6%9C%AC%E7%A7%91%E5%BA%94%E5%B1%8A%E7%94%9F%E5%AE%89%E5%85%A8%E5%B2%97%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 02 Apr 2019 11:24:31 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/%E6%9C%AC%E7%A7%91%E5%BA%94%E5%B1%8A%E7%94%9F%E5%AE%89%E5%85%A8%E5%B2%97%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</guid>
      
        <description>&lt;p&gt;很久没有更新博客了, 主要原因是因为现在笔记都记在了有道云笔记中. 并且 很多篇文章都只写了一半, 也不想发出来.&lt;/p&gt;

&lt;p&gt;近期时间充裕, 应该会保持每周一更, 将以前写的或者近期学到的知识总结一下发在博客里.&lt;/p&gt;

&lt;p&gt;本篇文章是19年春节写的, 主要记录了自己在18年的几次面试记录, 和大学期间的一些学习经历.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;个人简介&#34;&gt;个人简介&lt;/h1&gt;

&lt;p&gt;L0phTg&lt;/p&gt;

&lt;p&gt;学习方向: 二进制, 移动安全.&lt;/p&gt;

&lt;p&gt;专业: 信息安全.&lt;/p&gt;

&lt;h2 id=&#34;学习经历&#34;&gt;学习经历&lt;/h2&gt;

&lt;h3 id=&#34;大一&#34;&gt;大一&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;在未加入实验室之前, 我处于&amp;rdquo;野生, 放养&amp;rdquo;的状态
(就是没有目的的学习, 乱七八糟买了很多计算机类的书, 应该大多数人都经历过这个阶段, 其实在这个阶段就是要多了解熟悉各个计算机专业方向, 所以也没有必要一直苦恼, 分清主次, 打好基础就对了.)&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;大一主要学习了一段时间c/c++,( 此处推荐  &lt;code&gt;&amp;lt;&amp;lt; c语言程序设计现代方法&amp;gt;&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;&amp;lt; c++Primer&amp;gt;&amp;gt;&lt;/code&gt; ). 由于当时看到很多人推荐 &lt;code&gt;&amp;lt;&amp;lt;深入理解计算机系统&amp;gt;&amp;gt;&lt;/code&gt;, 所以耐不住诱惑, 就买了一本来看, 我的汇编知识最初就是在这本书上看到的.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当然其实大一虽然没有过多接触信息安全领域的专业知识, 但是由于一直在微博, 知乎关注着很多安全届大佬, 对安全领域也有了基本的概念与印象, 知道安全基本分为web和二进制等之类, 也了解到安全届有heige和tk两位妇科圣手, 这些多少都给无聊的大学生活增添了许多乐趣.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;关于安全学习的方向其实确定起来不是那么容易的, 最初了解到的是余弦、heige，所以多少想从事web安全领域. 但是在最终确定学习方向的时候, 还是考虑了自己的实际情况, 自身学习路线与兴趣爱好.  在大一暑假, 总结了一下自己大一看过的书有关于c/c++的, 汇编的, 和w32的, 以及阅读了 &lt;code&gt;&amp;lt;&amp;lt;加密与解密&amp;gt;&amp;gt;&lt;/code&gt;, 而且熟悉了linux下的基本操作. 至于web方向的试探, 只是停留在w3c上看过一点h5. 所以, 理所当然的就决定了之后走二进制这条路线.(方向领域的确定还是要根据自己实际情况考虑, 如果不考研, 且决定大三要找工作的话)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;移动安全领域入门, 是在大二, 至于是发生了什么导致自己想要向android安全靠拢的, 保密.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;大二&#34;&gt;大二&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;大二在历经艰辛进入实验室后, 生活就比较顺风顺水了, 就抱着一本 &lt;code&gt;&amp;lt;&amp;lt; android软件安全与逆向分析&amp;gt;&amp;gt;&lt;/code&gt;看了一个学期, 大二上就是这么过的.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;大二下主要是接触了一些android逆向与脱壳, 跟着f8left的视频, 自己尝试着去调试.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;大二暑期尝试去绿盟实习, 无奈面试失败. (失败+1)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;大三&#34;&gt;大三&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;大三由于面临着找工作这个大难题, 所以想着做些什么能够让自己的简历有亮眼之处. 所以就想着写些项目.
所以大三上和寒假就一直在coding. 主要写了两个项目: 一个ptrace相关, 一个arm相关.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;大三下就是春招， 阿里腾讯面试失败. (失败+2)  (面试失败对自己的打击是很大的, 所以失败后自己也在反思总结, 然后期待之后的公司面试能够顺利通过, 具体面试体验等看下一部分)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;之后面试小米. (成功+1) 面试小米成功之后, 就直接去了小米实习, 几个月的实习生活中, 学习到了很多. (具体看之后的实习经历)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;大四&#34;&gt;大四&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;大四秋招.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;我的面试经历其实并不顺畅, 但是之后的内容不会写的太具体, 只写一些主要的, 希望对大家有所帮助.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;拿到offer之后. 追剧, 玩游戏, 看直播&amp;hellip;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;面试准备&#34;&gt;面试准备&lt;/h1&gt;

&lt;p&gt;其实面试的准备内容是根据自己的面试岗位变化的. 例如游戏安全偏c/c++, app安全可能会涉及java. 但是自己擅长的一定要多做准备. 可以根据每次面试自己的发挥, 以及面试官的提问重点, 来针对性的复习和学习.&lt;/p&gt;

&lt;p&gt;移动安全岗位问到的相关内容包括(简历上写的基本都可能会问到):
c/c++,
java,
smali,
android逆向,
简单数据结构和算法,
简单加密算法, 分组加密的模式
hook等.&lt;/p&gt;

&lt;h1 id=&#34;面试经历&#34;&gt;面试经历&lt;/h1&gt;

&lt;h2 id=&#34;春招&#34;&gt;春招&lt;/h2&gt;

&lt;p&gt;春招印象最深的是腾讯的几次面试:&lt;/p&gt;

&lt;p&gt;第一次面的是tx游戏安全, 由于自己当时对hook没有了解, 并且在最后回答c++方向的问题时, 表现不好, 所以gg. ( 但是这次面试失败后, 就疯狂恶补了hook方向的内容. 这也使得自己在秋招面试一些公司时, 得以不在hook方向被打出gg)&lt;/p&gt;

&lt;p&gt;还有一次也是tx的另一个二进制部门, 面试失败的原因, 我归结为自己没有对一些安全知识做过总结. 所以在面试时, 发挥不好. (经常性的总结自己学过的知识, 是挺重要的. 这次面试失败之后, 就开了个有道云笔记会员, 硬广一波, 主要优势 跨平台. hhhhaaa.)&lt;/p&gt;

&lt;p&gt;小米面试, 是我春招的结尾, 一周面了三面技术面, 体验最好.
一面组长面, 对我写的一个项目问了有40min, 注意, 一个项目, 问到我怀疑人生. 二面: 智力面? 问了几个算法, 回答的一般, 但还是挺过去了. 终面(boss面): 自己在经历过春招的几场面试失败后, 对android安全做了一些系统的总结. 所以boss在问到对android安全的认识和了解的时候, 以及linker模块的时候,  把自己系统总结过的表达出来, 就通过面试了.&lt;/p&gt;

&lt;h2 id=&#34;秋招&#34;&gt;秋招&lt;/h2&gt;

&lt;p&gt;在经历过春招之后, 秋招相对来说轻松一些. 因为自己相对来说有了更多的经验, 也基本不会惨死在基础知识上(但还是有), 就算参加有些公司的面试, 即使失败了, 也没有那么多的抱怨和后悔.&lt;/p&gt;

&lt;h2 id=&#34;实习经历&#34;&gt;实习经历&lt;/h2&gt;

&lt;p&gt;实习时间(2018-4-15~~2018-8.30).&lt;/p&gt;

&lt;p&gt;实习单位: 小米MIUI系统组.&lt;/p&gt;

&lt;p&gt;在小米实习的日子, 是非常开心快乐的, 我也慢慢地从一个路人变成了一个米粉. 在实习期间, 学习到了很多:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;刷机.&lt;/li&gt;
&lt;li&gt;gdb调试android系统和应用.&lt;/li&gt;
&lt;li&gt;对android底层的art虚拟机有了一定的了解.&lt;/li&gt;
&lt;li&gt;method hook.&lt;/li&gt;
&lt;li&gt;总结了很多android加固方法.&lt;/li&gt;
&lt;li&gt;实现了一个加固demo.&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>我的zsh和vim配置</title>
      <link>https://l0phtg.github.io/post/%E6%88%91%E7%9A%84zsh%E5%92%8Cvim%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Wed, 24 Oct 2018 00:14:31 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/%E6%88%91%E7%9A%84zsh%E5%92%8Cvim%E9%85%8D%E7%BD%AE/</guid>
      
        <description>&lt;p&gt;总结了一下自己的vim配置和zsh配置&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/customConfig/myVimPreview.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;zsh配置&#34;&gt;zsh配置&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/robbyrussell/oh-my-zsh&#34;&gt;https://github.com/robbyrussell/oh-my-zsh&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;powerline字体设置&#34;&gt;powerline字体设置&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://dwijaybane.wordpress.com/2017/12/04/oh-my-zsh-and-powerline-fonts-setup-for-awesome-terminal-in-ubuntu-16-04/&#34;&gt;https://dwijaybane.wordpress.com/2017/12/04/oh-my-zsh-and-powerline-fonts-setup-for-awesome-terminal-in-ubuntu-16-04/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;我的插件&#34;&gt;我的插件&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;plugins=(git autojump web-search last-working-dir zsh-syntax-highlighting colored-man-pages extract zsh-proxychains-ng adb pip npm python)
#plugins=(git autojump last-working-dir adb pip npm python)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;vim配置&#34;&gt;vim配置&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;当你使用&lt;code&gt;vim&lt;/code&gt;时, 可以在&lt;code&gt;~/.vimrc&lt;/code&gt;中编写你的vim配置文件.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当你使用&lt;code&gt;neovim&lt;/code&gt;时, 可以在&lt;code&gt;~/.config/nvim/init.vim&lt;/code&gt;中编写你的vim配置文件.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;插件&#34;&gt;插件&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;插件管理&lt;code&gt;vim-plug&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;tagbar&lt;/li&gt;
&lt;li&gt;airline&lt;/li&gt;
&lt;li&gt;vimfilter&lt;/li&gt;
&lt;li&gt;vim-bufabline buffer窗口&lt;/li&gt;
&lt;li&gt;fzf和ag 搜索&lt;/li&gt;
&lt;li&gt;括号补全&amp;rsquo;Raimondi/delimitMate&amp;rsquo;&lt;/li&gt;
&lt;li&gt;include补全 neoinclude&lt;/li&gt;
&lt;li&gt;语法补全jedi-vim(python)&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;vim-plug-vim插件管理工具&#34;&gt;&lt;code&gt;vim-plug&lt;/code&gt; vim插件管理工具&lt;/h4&gt;

&lt;p&gt;README: &lt;a href=&#34;https://github.com/junegunn/vim-plug&#34;&gt;https://github.com/junegunn/vim-plug&lt;/a&gt;.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;安装&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;a. 当你使用&lt;code&gt;vim&lt;/code&gt;时.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -fLo ~/.vim/autoload/plug.vim --create-dirs \
    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;b. 当你使用`neovim时.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -fLo ~/.local/share/nvim/site/autoload/plug.vim --create-dirs \
    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;使用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;a. 可以使用git链接&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Plug &#39;https://github.com/junegunn/vim-github-dashboard.git&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;b. 使用git&lt;code&gt;UserName/Project&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Plug &#39;junegunn/vim-easy-align&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多可以参考文档.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;安装插件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;只是把要安装的插件写在配置文件中是不够的, 还需要安装.&lt;/p&gt;

&lt;p&gt;写好配置文件后, 重新打开vim, 运行&lt;code&gt;PlugInstall&lt;/code&gt;.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;例子:(我的部分配置)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;call plug#begin()

Plug &#39;NLKNguyen/papercolor-theme&#39;
Plug &#39;vim-airline/vim-airline&#39;
Plug &#39;vim-airline/vim-airline-themes&#39;
Plug &#39;Shougo/denite.nvim&#39;
Plug &#39;Shougo/unite.vim&#39;
Plug &#39;Shougo/vimfiler&#39;
Plug &#39;majutsushi/tagbar&#39;
Plug &#39;ap/vim-buftabline&#39;
Plug &#39;Shougo/deoplete.nvim&#39;, { &#39;do&#39;: &#39;:UpdateRemotePlugins&#39; }
Plug &#39;rip-rip/clang_complete&#39;
Plug &#39;SirVer/ultisnips&#39;           &amp;quot; 代码片段补全  模板补全
Plug &#39;honza/vim-snippets&#39;
Plug &#39;zchee/deoplete-jedi&#39;

Plug &#39;scrooloose/nerdcommenter&#39;   &amp;quot; 自动注释   &amp;lt;leader&amp;gt;cc  注释当先选中文本  
Plug &#39;ctrlpvim/ctrlp.vim&#39;

Plug &#39;lvht/tagbar-markdown&#39;       &amp;quot; markdown  tagbar显示

Plug &#39;~/.fzf&#39;
Plug &#39;junegunn/fzf.vim&#39;

call plug#end()
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;tagbar&#34;&gt;&lt;code&gt;tagbar&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;README: &lt;a href=&#34;https://github.com/majutsushi/tagbar&#34;&gt;https://github.com/majutsushi/tagbar&lt;/a&gt;.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;安装&lt;code&gt;ctags&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;$sudo apt install ctags
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;vim中配置&lt;code&gt;tagbar&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;call plug#begin()
Plug &#39;majutsushi/tagbar&#39;
call plug#end()

let g:tagbar_width=30
let g:tagbar_left=1

&amp;quot;映射F2快捷键为打开tagbar
nnoremap &amp;lt;F2&amp;gt; :TagbarToggle &amp;lt;CR&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;airline-主题&#34;&gt;&lt;code&gt;airline&lt;/code&gt; 主题&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/vim-airline/vim-airline&#34;&gt;https://github.com/vim-airline/vim-airline&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;call plug#begin()

Plug &#39;NLKNguyen/papercolor-theme&#39;           // 这是我自己的主题
Plug &#39;vim-airline/vim-airline&#39;
Plug &#39;vim-airline/vim-airline-themes&#39;

call plug#end()

let g:airline_theme=&#39;papercolor&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;vimfilter-文件树&#34;&gt;&lt;code&gt;vimfilter&lt;/code&gt; 文件树&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;call plug#begin()
Plug &#39;Shougo/vimfiler&#39;
call plug#end()

&amp;quot;我设置的打开vimfilter的对应快捷键为F3
nnoremap &amp;lt;F3&amp;gt; :VimFilerExplorer -split -direction=rightbelow &amp;lt;CR&amp;gt;          
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;vim-bufabline-buffer窗口&#34;&gt;&lt;code&gt;vim-bufabline&lt;/code&gt; buffer窗口&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;call plug#begin()
Plug &#39;ap/vim-buftabline&#39;
call plug#end()

&amp;quot;映射对应的快捷键为打开对应的buffer
nmap &amp;lt;leader&amp;gt;1 &amp;lt;Plug&amp;gt;BufTabLine.Go(1)
nmap &amp;lt;leader&amp;gt;2 &amp;lt;Plug&amp;gt;BufTabLine.Go(2)
nmap &amp;lt;leader&amp;gt;3 &amp;lt;Plug&amp;gt;BufTabLine.Go(3)
nmap &amp;lt;leader&amp;gt;4 &amp;lt;Plug&amp;gt;BufTabLine.Go(4)
nmap &amp;lt;leader&amp;gt;5 &amp;lt;Plug&amp;gt;BufTabLine.Go(5)
nmap &amp;lt;leader&amp;gt;6 &amp;lt;Plug&amp;gt;BufTabLine.Go(6)
nmap &amp;lt;leader&amp;gt;7 &amp;lt;Plug&amp;gt;BufTabLine.Go(7)
nmap &amp;lt;leader&amp;gt;8 &amp;lt;Plug&amp;gt;BufTabLine.Go(8)
nmap &amp;lt;leader&amp;gt;9 &amp;lt;Plug&amp;gt;BufTabLine.Go(9)
nmap &amp;lt;leader&amp;gt;0 &amp;lt;Plug&amp;gt;BufTabLine.Go(10)

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;fzf-和-ag&#34;&gt;fzf 和 ag&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/customConfig/fileContentSearch.png&#34; alt=&#34;目录下的全部文件内容搜索&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;下载安装fzf&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf
~/.fzf/install
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;vim 中配置fzf&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;插件使用&lt;code&gt;vim-plug&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Plug &#39;~/.fzf&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;ag安装&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ubuntu&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$sudo apt-get install silversearcher-ag
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;快捷键映射&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在我的vim中, &lt;leader&gt;映射为了&lt;code&gt;space&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;noremap &amp;lt;leader&amp;gt;sff :Files&amp;lt;CR&amp;gt;
noremap &amp;lt;leader&amp;gt;ssf :Lines&amp;lt;CR&amp;gt;
noremap &amp;lt;leader&amp;gt;sbf :BLines&amp;lt;CR&amp;gt; 
noremap &amp;lt;leader&amp;gt;ss  :Ag&amp;lt;CR&amp;gt;

noremap &amp;lt;leader&amp;gt;gls :GFiles&amp;lt;CR&amp;gt;
noremap &amp;lt;leader&amp;gt;gss :GFiles?&amp;lt;CR&amp;gt;   

noremap &amp;lt;leader&amp;gt;btag :Tags&amp;lt;CR&amp;gt;
noremap &amp;lt;leader&amp;gt;stag :BTags&amp;lt;CR&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;使用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;:BTags&lt;/code&gt; 可以在当前目录下build tags, &lt;code&gt;前提系统已经ctags&lt;/code&gt;(apt install ctags)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;:Tags&lt;/code&gt; 可以搜索tag. 在搜索前, 要先build tags. (可以自行阅读fzf doc, 应该可以在vim启动时自动build tags).&lt;/p&gt;

&lt;p&gt;当前文件内容搜索:
&lt;img src=&#34;https://l0phtg.github.io/customConfig/singleFileContentSearch.png&#34; alt=&#34;当前文件内容搜索&#34; /&gt;
当前目录的文件搜索:
&lt;img src=&#34;https://l0phtg.github.io/customConfig/searchFile.png&#34; alt=&#34;当前目录的文件搜索&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;括号补全-raimondi-delimitmate&#34;&gt;括号补全&amp;rsquo;Raimondi/delimitMate&amp;rsquo;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;call plug#begin()
Plug &#39;Raimondi/delimitMate&#39;       &amp;quot; 补全, \&amp;quot; \( 等.
call plug#end()
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;c-c-llvm头文件补全-neoinclude&#34;&gt;c/c++/llvm头文件补全 neoinclude&lt;/h4&gt;

&lt;p&gt;头文件补全需要设置头文件path, (&lt;strong&gt;注意, 是vim配置文件中的path, 而不是系统环境变量的path&lt;/strong&gt;)&lt;/p&gt;

&lt;p&gt;我使用的是nvim, 配置文件是~/config/nvim/init.vim&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot; ~/.config/nvim/init.vim

set path=.,/usr/include/c++/5,/usr/include,/home/l0phtg/tools/llvm-project/llvm/include

call plug#begin()
Plug &#39;Shougo/neoinclude.vim&#39;
call plug#end()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;我的配置&#34;&gt;我的配置&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;set nu

let mapleader= &#39; &#39;
let g:mapleader = &#39; &#39;


syntax on

filetype on

filetype indent on

filetype plugin on

filetype plugin indent on

&amp;quot; 标签页
set tabpagemax=20
set showtabline=2

&amp;quot; 设置文件浏览器目录为当前目录
set bsdir=buffer


&amp;quot; 突出显示当前行
set cursorline

&amp;quot; 突出显示当前列
&amp;quot; set cursorcolumn

&amp;quot; 括号配对情况, 跳转并高亮匹配的括号
set showmatch
&amp;quot;
set matchtime=2

&amp;quot; 相对行号: 行号变成相对
set relativenumber number

set encoding=utf-8

set fileencodings=ucs-bom,utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1
set helplang=cn

set rtp+=~/.fzf                  &amp;quot; fzf 

set path=.,/usr/include/c++/5,/usr/include,/home/l0phtg/tools/llvm-project/llvm/include



&amp;quot;plug插件

call plug#begin()

Plug &#39;NLKNguyen/papercolor-theme&#39;
Plug &#39;vim-airline/vim-airline&#39;
Plug &#39;vim-airline/vim-airline-themes&#39;

Plug &#39;Shougo/denite.nvim&#39;
Plug &#39;Shougo/unite.vim&#39;
Plug &#39;Shougo/vimfiler&#39;


Plug &#39;Shougo/deoplete.nvim&#39;, { &#39;do&#39;: &#39;:UpdateRemotePlugins&#39; }

Plug &#39;Shougo/neoinclude.vim&#39;

Plug &#39;majutsushi/tagbar&#39;
&amp;quot;&amp;quot;Plug &#39;https://github.com/fholgado/minibufexpl.vim.git&#39;
Plug &#39;ap/vim-buftabline&#39;


Plug &#39;justmao945/vim-clang&#39;
&amp;quot;Plug &#39;Valloric/YouCompleteMe&#39;     &amp;quot; YCM补全

&amp;quot;Plug &#39;SirVer/ultisnips&#39;           &amp;quot; 代码片段补全  模板补全

&amp;quot;Plug &#39;zchee/deoplete-jedi&#39;       &amp;quot; Python补全

Plug &#39;Raimondi/delimitMate&#39;       &amp;quot; 不全, \&amp;quot; \( 等.

Plug &#39;scrooloose/nerdcommenter&#39;   &amp;quot; 自动注释   &amp;lt;leader&amp;gt;cc  注释当先选中文本  &amp;lt;leader&amp;gt;cu 取消选中文本块的注释

Plug &#39;lvht/tagbar-markdown&#39;       &amp;quot; markdown  tagbar显示

Plug &#39;~/.fzf&#39;
Plug &#39;junegunn/fzf.vim&#39;

call plug#end()

set background=dark
colorscheme PaperColor

let g:airline_theme=&#39;papercolor&#39;


&amp;quot; 设置tagbar
let g:tagbar_width=30
let g:tagbar_left=1


&amp;quot; 配置fzf  和 ag
noremap &amp;lt;leader&amp;gt;sff :Files&amp;lt;CR&amp;gt;
noremap &amp;lt;leader&amp;gt;ssf :Lines&amp;lt;CR&amp;gt;
noremap &amp;lt;leader&amp;gt;sbf :BLines&amp;lt;CR&amp;gt; 
noremap &amp;lt;leader&amp;gt;ss  :Ag&amp;lt;CR&amp;gt;

noremap &amp;lt;leader&amp;gt;gls :GFiles&amp;lt;CR&amp;gt;
noremap &amp;lt;leader&amp;gt;gss :GFiles?&amp;lt;CR&amp;gt;   

noremap &amp;lt;leader&amp;gt;btag :Tags&amp;lt;CR&amp;gt;
noremap &amp;lt;leader&amp;gt;stag :BTags&amp;lt;CR&amp;gt;


&amp;quot; 配置vimbuftabline
let g:buftabline_numbers=2

noremap &amp;lt;leader&amp;gt;&amp;lt;Tab&amp;gt; :bnext&amp;lt;CR&amp;gt;

nmap &amp;lt;leader&amp;gt;1 &amp;lt;Plug&amp;gt;BufTabLine.Go(1)
nmap &amp;lt;leader&amp;gt;2 &amp;lt;Plug&amp;gt;BufTabLine.Go(2)
nmap &amp;lt;leader&amp;gt;3 &amp;lt;Plug&amp;gt;BufTabLine.Go(3)
nmap &amp;lt;leader&amp;gt;4 &amp;lt;Plug&amp;gt;BufTabLine.Go(4)
nmap &amp;lt;leader&amp;gt;5 &amp;lt;Plug&amp;gt;BufTabLine.Go(5)
nmap &amp;lt;leader&amp;gt;6 &amp;lt;Plug&amp;gt;BufTabLine.Go(6)
nmap &amp;lt;leader&amp;gt;7 &amp;lt;Plug&amp;gt;BufTabLine.Go(7)
nmap &amp;lt;leader&amp;gt;8 &amp;lt;Plug&amp;gt;BufTabLine.Go(8)
nmap &amp;lt;leader&amp;gt;9 &amp;lt;Plug&amp;gt;BufTabLine.Go(9)
nmap &amp;lt;leader&amp;gt;0 &amp;lt;Plug&amp;gt;BufTabLine.Go(10)

&amp;quot; 设置 deoplete.nvim
let g:deoplete#enable_at_startup = 1

&amp;quot;设置Tab为补全
inoremap &amp;lt;expr&amp;gt; &amp;lt;Tab&amp;gt; pumvisible() ? &amp;quot;\&amp;lt;C-n&amp;gt;&amp;quot; : &amp;quot;\&amp;lt;Tab&amp;gt;&amp;quot;                
&amp;quot;inoremap &amp;lt;expr&amp;gt; &amp;lt;S-Tab&amp;gt; pumvisible() ? &amp;quot;\&amp;lt;C-p&amp;gt;&amp;quot; : &amp;quot;\&amp;lt;S-Tab&amp;gt;&amp;quot;
&amp;quot;inoremap &amp;lt;expr&amp;gt; &amp;lt;cr&amp;gt; pumvisible() ? &amp;quot;\&amp;lt;C-y&amp;gt;&amp;quot; : &amp;quot;\&amp;lt;cr&amp;gt;&amp;quot;


&amp;quot; 设置vim-clang
let g:clang_cpp_options = &#39;-std=c++11&#39;
let g:clang_check_syntax_auto = 1
let g:clang_cpp_completeopt = &#39;menuone,longest&#39;



&amp;quot;快捷键只在常规模式下有用 nnoremap
&amp;quot;设置 F3 为打开vimfiler
&amp;quot;设置 &amp;quot; &amp;quot;fs 为保存文件
&amp;quot;function vimfilertoRight()
&amp;quot;endfunction

nnoremap &amp;lt;F2&amp;gt; :TagbarToggle &amp;lt;CR&amp;gt;
nnoremap &amp;lt;F3&amp;gt; :VimFilerExplorer -split -direction=rightbelow &amp;lt;CR&amp;gt;          
nnoremap &amp;lt;leader&amp;gt;fs :w &amp;lt;CR&amp;gt;
nnoremap &amp;lt;leader&amp;gt;fS :wall &amp;lt;CR&amp;gt;

nnoremap &amp;lt;leader&amp;gt;qq :wq &amp;lt;CR&amp;gt;
&amp;quot;vim windows窗口左右
nnoremap &amp;lt;C-h&amp;gt; &amp;lt;C-w&amp;gt;h &amp;lt;CR&amp;gt;
nnoremap &amp;lt;C-l&amp;gt; &amp;lt;C-w&amp;gt;l &amp;lt;CR&amp;gt;
nnoremap &amp;lt;C-j&amp;gt; &amp;lt;C-w&amp;gt;j &amp;lt;CR&amp;gt;
nnoremap &amp;lt;C-k&amp;gt; &amp;lt;C-w&amp;gt;k &amp;lt;CR&amp;gt;

&amp;quot;分割窗口
nnoremap &amp;lt;leader&amp;gt;wj :split&amp;lt;CR&amp;gt;
nnoremap &amp;lt;leader&amp;gt;wl :vsplit&amp;lt;CR&amp;gt;


&amp;quot;set hidden &amp;quot; 避免必须保存才可以跳转buffer

&amp;quot; my settings 对vimfiler的配置
let g:vimfiler_as_default_explorer = 1
let g:vimfiler_safe_mode_by_default = 0
let g:vimfiler_tree_leaf_icon = &#39; &#39;
let g:vimfiler_tree_opened_icon = &#39;▾&#39;
let g:vimfiler_tree_closed_icon = &#39;▸&#39;
let g:vimfiler_enable_auto_cd = 1
let g:vimfiler_file_icon = &#39;-&#39;
let g:vimfiler_marked_file_icon = &#39;✓&#39;
let g:vimfiler_readonly_file_icon = &#39;✗&#39;
let g:vimfiler_time_format = &#39;%m-%d-%y %H:%M:%S&#39;
let g:vimfiler_expand_jump_to_first_child = 0
let g:vimfiler_ignore_pattern = &#39;\.git\|\.DS_Store\|\.pyc&#39;


&amp;quot; 文件类型设置 FileType Settings
set sw=4
set ts=4
autocmd FileType markdown set tabstop=4 shiftwidth=4 expandtab ai
autocmd FileType c++ set tabstop=4 shiftwidth=4 expandtab ai
autocmd FileType c set tabstop=4 shiftwidth=4 expandtab ai

autocmd FileType python set tabstop=4 shiftwidth=4 expandtab ai
autocmd FileType ruby,javascript,html,css,xml set tabstop=2 shiftwidth=2 softtabstop=2 expandtab ai


&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>Pixel1 源码编译</title>
      <link>https://l0phtg.github.io/post/pixel1-%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/</link>
      <pubDate>Tue, 02 Oct 2018 15:38:56 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/pixel1-%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/</guid>
      
        <description>&lt;p&gt;记录自己Pixel1刷机流程.&lt;/p&gt;

&lt;p&gt;相关网站&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Requirements
https://source.android.google.cn/setup/build/requirements.html#binaries

https://source.android.com/setup/build/running

buile numbers
https://source.android.com/setup/start/build-numbers

https://source.android.com/setup/build/downloading

驱动
https://developers.google.com/android/drivers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;ota-image&#34;&gt;ota, image&lt;/h2&gt;

&lt;p&gt;刷机使用. 不需要编译源码, 直接刷机.&lt;/p&gt;

&lt;p&gt;下载刷机包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https://developers.google.com/android/images

https://developers.google.com/android/ota
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;刷入:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$sudo ./flash_all.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;源码下载&#34;&gt;源码下载&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-6.0.1_r77
repo sync -j8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;适用于pixel 的:
NZH54D android-7.1.2_r33
OPM4.171019.021.P1 android-8.1.0_r38&lt;/p&gt;

&lt;p&gt;repo init -u &lt;a href=&#34;https://aosp.tuna.tsinghua.edu.cn/platform/manifest&#34;&gt;https://aosp.tuna.tsinghua.edu.cn/platform/manifest&lt;/a&gt; -b android-7.1.2_r33&lt;/p&gt;

&lt;p&gt;repo init -u &lt;a href=&#34;https://aosp.tuna.tsinghua.edu.cn/platform/manifest&#34;&gt;https://aosp.tuna.tsinghua.edu.cn/platform/manifest&lt;/a&gt; -b android-8.1.0_r38&lt;/p&gt;

&lt;h2 id=&#34;编译&#34;&gt;编译&lt;/h2&gt;

&lt;p&gt;直接编译userdebug版本, 方便我们调试&lt;/p&gt;

&lt;p&gt;安装jdk&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo add-apt-repository ppa:openjdk-r/ppa  
sudo apt-get update   
sudo apt-get install openjdk-7-jdk  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译,&lt;code&gt;如果要刷真机的话, 需要提前下载驱动到源码目录, 并解压之后运行.sh, ACCEPT后释放出来驱动相关文件.(https://developers.google.com/android/drivers)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$source ./build/envsetup.sh
$lunch
编译全部源码
$make -j12 
编译某个module
$make -j12 libart_32
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入系统&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这里不需要sudo 
$fastboot flashall -w
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;root&#34;&gt;root&lt;/h2&gt;

&lt;p&gt;root无源码的机型.
1. 解锁boot
2. 刷入twrp
3. 装入supersu.apk
4. 重启&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gist.github.com/rhyttr/931f5f14f40793a45170809bec6ca62a&#34;&gt;https://gist.github.com/rhyttr/931f5f14f40793a45170809bec6ca62a&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Download latest Android image, &amp;quot;hammerhead&amp;quot; for Nexus 5 (GSM/LTE)
https://developers.google.com/android/nexus/images#hammerhead

# Download latest TWRP
https://dl.twrp.me/hammerhead/

# Download latest SuperSu
https://download.chainfire.eu/supersu

Enable USB debugging.
Reboot into bootloader (power off, volume down + power on or sudo adb reboot-bootloader)
# Wait for boot loader to start
# Install factory ROM:
unzip hammerhead-m4b30z-factory-625c027b.zip
cd hammerhead-m4b30z
unzip image-hammerhead-m4b30z.zip
fastboot flash bootloader bootloader-hammerhead-hhz20h.img
fastboot reboot-bootloader #or power off/start bootloader
fastboot flash radio radio-hammerhead-m8974a-2.0.50.2.30.img
fastboot flash boot boot.img
fastboot flash cache cache.img
fastboot flash system system.img
# add params -S 256M if remaining memory is not enough . eg: sudo fastboot flash -S 256M system system.img
fastboot flash recovery recovery.img
fastboot reboot

# Wait boot to finish for application upgrade.
adb push SR1-SuperSU-v2.82-SR1-20170608224931.zip /sdcard/
adb reboot-bootloader

# [Wait for bootloader to start]
adb start-server
fastboot flash recovery twrp-3.1.1-0-hammerhead.img
fastboot reboot-bootloader
# on the screen, Navigate into Recovery mode (Reboot) -&amp;gt; Install -&amp;gt; zip, select SR3-SuperSU-v2.79-SR3-20170114223742.zip -&amp;gt; Swipe to confirm Flash
# Reboot System
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;调试&#34;&gt;调试&lt;/h2&gt;

&lt;p&gt;更改system分区读写权限&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$adb disable verity
$mount -o remount,rw /system
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;emulator测试&#34;&gt;emulator测试&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;列出创建avd&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;emulator -list-avd
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;emulator 启动avd&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$emulator -avd PixelN
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使&lt;code&gt;system&lt;/code&gt;分区可写&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$emulator -writable-system -avd PixelN
启动之后
$adb remount
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;n. help&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ emulator -help
ndroid Emulator usage: emulator [options] [-qemu args]
 options:
   -list-avds                      list available AVDs
   -sysdir &amp;lt;dir&amp;gt;                   search for system disk images in &amp;lt;dir&amp;gt;
   -system &amp;lt;file&amp;gt;                  read initial system image from &amp;lt;file&amp;gt;
   -vendor &amp;lt;file&amp;gt;                  read initial vendor image from &amp;lt;file&amp;gt;
   -writable-system                make system &amp;amp; vendor image writable after &#39;adb remount&#39;
   -datadir &amp;lt;dir&amp;gt;                  write user data into &amp;lt;dir&amp;gt;
   -kernel &amp;lt;file&amp;gt;                  use specific emulated kernel
   -ramdisk &amp;lt;file&amp;gt;                 ramdisk image (default &amp;lt;system&amp;gt;/ramdisk.img
   -image &amp;lt;file&amp;gt;                   obsolete, use -system &amp;lt;file&amp;gt; instead
   -initdata &amp;lt;file&amp;gt;                same as &#39;-init-data &amp;lt;file&amp;gt;&#39;
   -data &amp;lt;file&amp;gt;                    data image (default &amp;lt;datadir&amp;gt;/userdata-qemu.img
   -encryption-key &amp;lt;file&amp;gt;          read initial encryption key image from &amp;lt;file&amp;gt;
   -logcat-output &amp;lt;file&amp;gt;           output file of logcat(default none)
   -partition-size &amp;lt;size&amp;gt;          system/data partition size in MBs
   -cache &amp;lt;file&amp;gt;                   cache partition image (default is temporary file)
   -cache-size &amp;lt;size&amp;gt;              cache partition size in MBs
   -no-cache                       disable the cache partition
   -nocache                        same as -no-cache
   -sdcard &amp;lt;file&amp;gt;                  SD card image (default &amp;lt;datadir&amp;gt;/sdcard.img
   -quit-after-boot &amp;lt;timeout&amp;gt;      qeuit emulator after guest boots completely, or after timeout in seconds
   -snapstorage &amp;lt;file&amp;gt;             file that contains all state snapshots (default &amp;lt;datadir&amp;gt;/snapshots.img)
   -no-snapstorage                 do not mount a snapshot storage file (this disables all snapshot functionality)
   -snapshot &amp;lt;name&amp;gt;                name of snapshot within storage file for auto-start and auto-save (default &#39;default-boot&#39;)
   -no-snapshot                    perform a full boot and do not auto-save, but qemu vmload and vmsave operate on snapstorage
   -no-snapshot-save               do not auto-save to snapshot on exit: abandon changed state
   -no-snapshot-load               do not auto-start from snapshot: perform a full boot
   -snapshot-list                  show a list of available snapshots
   -no-snapshot-update-time        do not try to correct snapshot time on restore
   -wipe-data                      reset the user data image (copy it from initdata)
   -avd &amp;lt;name&amp;gt;                     use a specific android virtual device
   -skindir &amp;lt;dir&amp;gt;                  search skins in &amp;lt;dir&amp;gt; (default &amp;lt;system&amp;gt;/skins)
   -skin &amp;lt;name&amp;gt;                    select a given skin
   -no-skin                        deprecated: create an AVD with no skin instead
   -noskin                         same as -no-skin
   -memory &amp;lt;size&amp;gt;                  physical RAM size in MBs
   -cores &amp;lt;number&amp;gt;                 Set number of CPU cores to emulator
   -accel &amp;lt;mode&amp;gt;                   Configure emulation acceleration
   -no-accel                       Same as &#39;-accel off&#39;
   -ranchu                         Use new emulator backend instead of the classic one
   -engine &amp;lt;engine&amp;gt;                Select engine. auto|classic|qemu2
   -netspeed &amp;lt;speed&amp;gt;               maximum network download/upload speeds
   -netdelay &amp;lt;delay&amp;gt;               network latency emulation
   -netfast                        disable network shaping
   -code-profile &amp;lt;name&amp;gt;            enable code profiling
   -show-kernel                    display kernel messages
   -shell                          enable root shell on current terminal
   -no-jni                         disable JNI checks in the Dalvik runtime
   -nojni                          same as -no-jni
   -logcat &amp;lt;tags&amp;gt;                  enable logcat output with given tags
   -use-system-libs                Use system libstdc++ instead of bundled one
   -bluetooth &amp;lt;vendorid:productid&amp;gt; forward bluetooth to vendorid:productid
   -no-audio                       disable audio support
   -noaudio                        same as -no-audio
   -audio &amp;lt;backend&amp;gt;                use specific audio backend
   -radio &amp;lt;device&amp;gt;                 redirect radio modem interface to character device
   -port &amp;lt;port&amp;gt;                    TCP port that will be used for the console
   -ports &amp;lt;consoleport&amp;gt;,&amp;lt;adbport&amp;gt;  TCP ports used for the console and adb bridge
   -onion &amp;lt;image&amp;gt;                  use overlay PNG image over screen
   -onion-alpha &amp;lt;%age&amp;gt;             specify onion-skin translucency
   -onion-rotation 0|1|2|3         specify onion-skin rotation
   -dpi-device &amp;lt;dpi&amp;gt;               specify device&#39;s resolution in dpi (default 165)
   -scale &amp;lt;scale&amp;gt;                  scale emulator window (deprecated)
   -http-proxy &amp;lt;proxy&amp;gt;             make TCP connections through a HTTP/HTTPS proxy
   -timezone &amp;lt;timezone&amp;gt;            use this timezone instead of the host&#39;s default
   -dns-server &amp;lt;servers&amp;gt;           use this DNS server(s) in the emulated system
   -net-tap &amp;lt;interface&amp;gt;            use this TAP interface for networking
   -net-tap-script-up &amp;lt;script&amp;gt;     script to run when the TAP interface goes up
   -net-tap-script-down &amp;lt;script&amp;gt;   script to run when the TAP interface goes down
   -cpu-delay &amp;lt;cpudelay&amp;gt;           throttle CPU emulation
   -no-boot-anim                   disable animation for faster boot
   -no-window                      disable graphical window display
   -no-sim                         device has no SIM card
   -lowram                         device is a low ram device
   -version                        display emulator version number
   -report-console &amp;lt;socket&amp;gt;        report console port to remote socket
   -gps &amp;lt;device&amp;gt;                   redirect NMEA GPS to character device
   -shell-serial &amp;lt;device&amp;gt;          specific character device for root shell
   -tcpdump &amp;lt;file&amp;gt;                 capture network packets to file
   -bootchart &amp;lt;timeout&amp;gt;            enable bootcharting
   -charmap &amp;lt;file&amp;gt;                 use specific key character map
   -studio-params &amp;lt;file&amp;gt;           used by Android Studio to provide parameters
   -prop &amp;lt;name&amp;gt;=&amp;lt;value&amp;gt;            set system property on boot
   -shared-net-id &amp;lt;number&amp;gt;         join the shared network, using IP address 10.1.2.&amp;lt;number&amp;gt;
   -nand-limits &amp;lt;nlimits&amp;gt;          enforce NAND/Flash read/write thresholds
   -gpu &amp;lt;mode&amp;gt;                     set hardware OpenGLES emulation mode
   -camera-back &amp;lt;mode&amp;gt;             set emulation mode for a camera facing back
   -camera-front &amp;lt;mode&amp;gt;            set emulation mode for a camera facing front
   -webcam-list                    lists web cameras available for emulation
   -screen &amp;lt;mode&amp;gt;                  set emulated screen mode
   -selinux &amp;lt;disabled|permissive&amp;gt;  Set SELinux to either disabled or permissive mode
   -unix-pipe &amp;lt;path&amp;gt;               Add &amp;lt;path&amp;gt; to the list of allowed Unix pipes
   -fixed-scale                    Use fixed 1:1 scale for the initial emulator window.
   -wait-for-debugger              Pause on launch and wait for a debugger process to attach before resuming
   -skip-adb-auth                  Skip adb authentication dialogue
   -metrics-to-console             Enable usage metrics and print the messages to stdout
   -metrics-to-file &amp;lt;file&amp;gt;         Enable usage metrics and write the messages into specified file
   -feature &amp;lt;name|-name&amp;gt;           Force-enable or disable (-name) the features
   -sim-access-rules-file &amp;lt;file&amp;gt;   Use SIM access rules from specified file
   -phone-number-prefix &amp;lt;string&amp;gt;   Number to use as the emulator&#39;s phone number prefix

    -qemu args...                  pass arguments to qemu
    -qemu -h                       display qemu help

    -verbose                       same as &#39;-debug-init&#39;
    -debug &amp;lt;tags&amp;gt;                  enable/disable debug messages
    -debug-&amp;lt;tag&amp;gt;                   enable specific debug messages
    -debug-no-&amp;lt;tag&amp;gt;                disable specific debug messages

    -help                          print this help
    -help-&amp;lt;option&amp;gt;                 print option-specific help

    -help-disk-images              about disk images
    -help-debug-tags               debug tags for -debug &amp;lt;tags&amp;gt;
    -help-char-devices             character &amp;lt;device&amp;gt; specification
    -help-environment              environment variables
    -help-virtual-device           virtual device management
    -help-sdk-images               about disk images when using the SDK
    -help-build-images             about disk images when building Android
    -help-all                      prints all help content
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>Hugo搭建博客</title>
      <link>https://l0phtg.github.io/post/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Wed, 19 Sep 2018 20:04:10 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</guid>
      
        <description>&lt;p&gt;博客半年多没更新了. 正好最近时间比较多, 想着把博客更新下, 再把几篇平时总结的文章上传在Blog里面.&lt;/p&gt;

&lt;p&gt;以前使用hexo搭的, 最近发现了好多人在用&lt;code&gt;hugo&lt;/code&gt;, 自己使用hugo重新搭建了一下, 简单方便, 好感指数五颗星.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gohugo.io/getting-started/quick-start/&#34;&gt;https://gohugo.io/getting-started/quick-start/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;hugo 搭建&lt;/p&gt;

&lt;h2 id=&#34;linux平台安装hugo&#34;&gt;linux平台安装hugo&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;源码安装&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;安装go:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/doc/install?download=go1.11.linux-amd64.tar.gz&#34;&gt;https://golang.org/doc/install?download=go1.11.linux-amd64.tar.gz&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$tar -C /usr/local -xzf go1.11.linux-amd64.tar.gz
$ vim /etc/profile
export PATH=$PATH:/usr/local/go/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下载源码安装hugo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir $HOME/src
cd $HOME/src
git clone https://github.com/gohugoio/hugo.git
cd hugo
go install
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;apt安装&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$sudo apt install hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;

&lt;h3 id=&#34;创建new-site&#34;&gt;创建New site&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$hugo new site quickstart
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;创建md&#34;&gt;创建md&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$hugo new posts/my-first-post.md
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;预览&#34;&gt;预览&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$hugo server -D 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Navigate to your new site at &lt;a href=&#34;http://localhost:1313/&#34;&gt;http://localhost:1313/&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;个性化主题&#34;&gt;个性化主题&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://themes.gohugo.io/&#34;&gt;https://themes.gohugo.io/&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;网站配置&#34;&gt;网站配置&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;config.toml&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;baseURL = &amp;quot;https://example.org/&amp;quot;
languageCode = &amp;quot;en-us&amp;quot;
title = &amp;quot;My New Hugo Site&amp;quot;
theme = &amp;quot;ananke&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;post到github-pages上&#34;&gt;post到github pages上&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;升级git&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Debian/Ubuntu
For the latest stable version for your release of Debian/Ubuntu

# apt-get install git
For Ubuntu, this PPA provides the latest stable upstream Git version
# add-apt-repository ppa:git-core/ppa # apt update; apt install git
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;github上创建USER_NAME.github.io的repo.&lt;/li&gt;
&lt;li&gt;clone repo到public目录&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git submodule add -b master git@github.com:&amp;lt;USERNAME&amp;gt;/&amp;lt;USERNAME&amp;gt;.github.io.git public
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;push&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;depl4oy.sh&lt;/code&gt;如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

echo -e &amp;quot;\033[0;32mDeploying updates to GitHub...\033[0m&amp;quot;

# Build the project.
hugo # if using a theme, replace with `hugo -t &amp;lt;YOURTHEME&amp;gt;`

# Go To Public folder
cd public
# Add changes to git.
git add .

# Commit changes.
msg=&amp;quot;rebuilding site `date`&amp;quot;
if [ $# -eq 1 ]
  then msg=&amp;quot;$1&amp;quot;
fi
git commit -m &amp;quot;$msg&amp;quot;

# Push source and build repos.
git push origin master

# Come Back up to the Project Root
cd ..
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;内容编写&#34;&gt;内容编写&lt;/h2&gt;

&lt;h3 id=&#34;文档模板&#34;&gt;文档模板&lt;/h3&gt;

&lt;p&gt;默认是&lt;code&gt;archetypes /default.md&lt;/code&gt;. new 文档时, 根据这个文档创建.&lt;/p&gt;

&lt;p&gt;我的&lt;code&gt;default.md&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;---
title: &amp;quot;{{ replace .TranslationBaseName &amp;quot;-&amp;quot; &amp;quot; &amp;quot; | title }}&amp;quot;
date: {{ .Date }}
lastmod: {{ .Date }}
draft: true
keywords: []
description: &amp;quot;&amp;quot;
tags: []
categories: []
author: &amp;quot;&amp;quot;

# You can also close(false) or open(true) something for this content.
# P.S. comment can only be closed
comment: false
toc: true
autoCollapseToc: false
# You can also define another contentCopyright. e.g. contentCopyright: &amp;quot;This is another copyright.&amp;quot;
#contentCopyright: false
reward: false
mathjax: false
---

&amp;lt;!--more--&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;插入图片&#34;&gt;插入图片&lt;/h3&gt;

&lt;p&gt;图片放在static目录下&lt;/p&gt;

&lt;p&gt;例如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;目录下的文件:
- static
   - deepin
      - desktop.png
      - splitScreen.png
      - vimMarkdownPreview.png
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用的时候:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;![desktop](/deepin/desktop.png)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;文章摘要&#34;&gt;文章摘要&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;!--more--&amp;gt;&lt;/code&gt;前面的会成为文章的摘要, 在首页显示.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
title : &amp;quot;hihi&amp;quot;
tags :  &amp;quot;blog&amp;quot;
---

&amp;lt;!--more--&amp;gt;

正文
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;显示toc&#34;&gt;显示toc&lt;/h3&gt;

&lt;p&gt;toc : true&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
title: &amp;quot;Iqiyi开源hook框架XHook分析&amp;quot;
date: 2018-09-19T02:19:05+08:00
lastmod: 2018-09-19T02:19:05+08:00
draft: false
keywords: []
description: &amp;quot;&amp;quot;
tags: [&amp;quot;hook&amp;quot;]
categories: [&amp;quot;hook&amp;quot;]
author: &amp;quot;&amp;quot;

# You can also close(false) or open(true) something for this content.
# P.S. comment can only be closed
comment: false
toc: true
autoCollapseToc: false
# You can also define another contentCopyright. e.g. contentCopyright: &amp;quot;This is another copyright.&amp;quot;
contentCopyright: false
reward: false
mathjax: false
---
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;语法高亮&#34;&gt;语法高亮&lt;/h3&gt;

&lt;h4 id=&#34;chroma&#34;&gt;Chroma&lt;/h4&gt;

&lt;p&gt;hugo &lt;strong&gt;使用chroma默认进行语法高亮, 垃圾, 不好用, 推荐highlight.js&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pygmentsCodefences = true #高亮markdown的代码块
pygmentsCodefencesGuessSyntax = true #高亮markdown中没有标注语言的代码块
pygmentsStyle = &#39;manni&#39; #高亮主题
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有些主题的默认css设置了background. 会导致highlight时出现字体白色阴影. 此时我们需要将它的background-color删掉或者覆盖掉.&lt;/p&gt;

&lt;p&gt;我使用的主题是&lt;code&gt;jane&lt;/code&gt;, 默认css样式是&lt;code&gt;/themes/jane/static/dist/jane.min.css&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;#jane.min.css
 code{padding:0 7px;background:#f8f5ec;border-radius:4px;color:#c7254e}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把该块删掉.&lt;/p&gt;

&lt;p&gt;这要就可以解决阴影的问题了.&lt;strong&gt;可能自己的主题版本太老了, 可以pull一下最新版本, 这个问题应该会被修复了&lt;/strong&gt; .&lt;/p&gt;

&lt;h4 id=&#34;highlight-js&#34;&gt;highlight.js&lt;/h4&gt;

&lt;p&gt;添加&lt;strong&gt;主题css&lt;/strong&gt;和&lt;strong&gt;highlight.pack.js&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;customCSS = [&#39;styles/dracula.css]
customJS = [&#39;highlight.pack.js]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;body&lt;/strong&gt;中添加&lt;strong&gt;script&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;script&amp;gt;hljs.initHighlightingOnLoad();&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;显示最后更新日期&#34;&gt;显示最后更新日期&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;enableGitInfo = true    # 开启gitinfo

[frontmatter]
date = [&amp;quot;date&amp;quot;, &amp;quot;publishDate&amp;quot;, &amp;quot;lastmod&amp;quot;]
lastmod = [&amp;quot;:git&amp;quot;, &amp;quot;lastmod&amp;quot;, &amp;quot;date&amp;quot;, &amp;quot;publishDate&amp;quot;]
publishDate = [&amp;quot;publishDate&amp;quot;, &amp;quot;date&amp;quot;]
expiryDate = [&amp;quot;expiryDate&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要实现该功能需要有&lt;strong&gt;commit记录&lt;/strong&gt; , 所以需要&lt;strong&gt;添加我们的.md到git版本控制工具&lt;/strong&gt; 中. 请阅读下面的&lt;strong&gt;博客搭建心得&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&#34;数学公式&#34;&gt;数学公式&lt;/h3&gt;

&lt;h4 id=&#34;如何开启mathjax&#34;&gt;如何开启mathjax&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;/layout/partical&lt;/code&gt;目录下创建&lt;code&gt;mathjax_support.html&lt;/code&gt;, 写入:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;
  src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML&amp;quot;&amp;gt;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;支持内联&#34;&gt;支持内联&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;/layouts/partials/custom_head.html&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;script type=&amp;quot;text/x-mathjax-config&amp;quot;&amp;gt;
  MathJax.Hub.Config({tex2jax: {inlineMath: [[&#39;$&#39;,&#39;$&#39;], [&#39;\\(&#39;,&#39;\\)&#39;]]}});  // 内联公式
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;支持color&#34;&gt;支持color&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;/layouts/partials/custom_head.html&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;script type=&amp;quot;text/x-mathjax-config&amp;quot;&amp;gt;
  MathJax.Hub.Config({                                                      // support color
  showProcessingMessages: false,
  jax: [&amp;quot;input/TeX&amp;quot;, &amp;quot;output/HTML-CSS&amp;quot;],
  TeX: {
    TagSide: &amp;quot;left&amp;quot;,
    Macros: {
      RR: &#39;{\\bf R}&#39;,
      bold: [&#39;{\\bf #1}&#39;,1]
    }
  }
});
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mermaid&#34;&gt;mermaid&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;mermaid&lt;/code&gt;支持画流程图, 甘特图等.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/knsv/mermaid/releases&#34;&gt;https://github.com/knsv/mermaid/releases&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;和使用&lt;code&gt;highlight.js&lt;/code&gt;的方法类似:&lt;/p&gt;

&lt;p&gt;添加&lt;code&gt;mermaid.css&lt;/code&gt; 和 &lt;code&gt;mermaid.min.js&lt;/code&gt; .&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;customCSS = [&#39;styles/dracula.css&#39;, &#39;mermaid.css&#39;]            # if [&#39;custom.css&#39;], load &#39;/static/css/custom.css&#39; file
customJS = [&#39;highlight.pack.js&#39;,&#39;mermaid.min.js&#39;]             # if [&#39;custom.js&#39;], load &#39;/static/js/custom.js&#39; file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;script.html&lt;/code&gt;中添加&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script&amp;gt; mermaid.initialize({ startOnLoad: true });&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;使用-1&#34;&gt;使用&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;&amp;lt;div class=&amp;quot;mermaid&amp;quot;&amp;gt;
graph TD
    Start --&amp;gt; Stop
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成:&lt;/p&gt;

&lt;div class=&#34;mermaid&#34;&gt;
graph TD
    Start --&gt; Stop
&lt;/div&gt;

&lt;h1 id=&#34;博客搭建心得&#34;&gt;博客搭建心得&lt;/h1&gt;

&lt;p&gt;注意到, 在上文我们&lt;strong&gt;post网站到github pages&lt;/strong&gt; 上时,  是将&lt;strong&gt;public目录作为submodule&lt;/strong&gt;  push的. (push 的就是public目录的内容 ).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/life/blog-public.png&#34; alt=&#34;blog-public&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们可以将当前的hugo 目录, 按上图来说就是&lt;strong&gt;quickstart目录&lt;/strong&gt; 作为我们的博客代码编写目录添加到&lt;strong&gt;quickstart的git版本控制中&lt;/strong&gt; .&lt;/p&gt;

&lt;p&gt;我添加到git仓库中的文件有: &lt;strong&gt;config.toml, content/ , deploy.sh&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/life/blog-ls-files.png&#34; alt=&#34;blog-ls-files&#34; /&gt;&lt;/p&gt;

&lt;p&gt;添加到版本控制的目的: 可以将它提交到我们的&lt;strong&gt;github&lt;/strong&gt;或者 &lt;strong&gt;gitee&lt;/strong&gt;上, &lt;strong&gt;方便跨平台编辑, 也可以当作一个备份&lt;/strong&gt; .&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Iqiyi开源hook框架XHook分析</title>
      <link>https://l0phtg.github.io/post/iqiyi%E5%BC%80%E6%BA%90hook%E6%A1%86%E6%9E%B6xhook%E5%88%86%E6%9E%90/</link>
      <pubDate>Sun, 19 Aug 2018 02:19:05 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/iqiyi%E5%BC%80%E6%BA%90hook%E6%A1%86%E6%9E%B6xhook%E5%88%86%E6%9E%90/</guid>
      
        <description>&lt;p&gt;Got Hook 可以使用dlsym得到目标函数的地址, 然后遍历got表进行Hook.&lt;/p&gt;

&lt;p&gt;但是有时候我们不能通过dlsym得到函数地址. 这时我们需要怎么办呢? iqiyi的xhook很好的解决了这个问题, (可以参考linker的实现, &lt;strong&gt;有问题, 看源码&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;通过找到目标函数地址存放在got表中位置, 只要找到了目标symbol在got表中的offset, 想要修改或者得到目标函数的实际地址就轻松多了.&lt;/p&gt;

&lt;p&gt;symbol -&amp;gt; symid -&amp;gt; 在got表中的offset  -&amp;gt; 目标函数实际地址&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;阅读readme&#34;&gt;阅读Readme&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/iqiyi/xHook/blob/master/README.zh-CN.md&#34;&gt;https://github.com/iqiyi/xHook/blob/master/README.zh-CN.md&lt;/a&gt;
&lt;a href=&#34;https://github.com/iqiyi/xHook/blob/master/docs/overview/android_plt_hook_overview.zh-CN.md&#34;&gt;https://github.com/iqiyi/xHook/blob/master/docs/overview/android_plt_hook_overview.zh-CN.md&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//监测内存泄露
xhook_register(&amp;quot;.*\\.so$&amp;quot;, &amp;quot;malloc&amp;quot;,  my_malloc,  NULL);
xhook_register(&amp;quot;.*\\.so$&amp;quot;, &amp;quot;calloc&amp;quot;,  my_calloc,  NULL);
xhook_register(&amp;quot;.*\\.so$&amp;quot;, &amp;quot;realloc&amp;quot;, my_realloc, NULL);
xhook_register(&amp;quot;.*\\.so$&amp;quot;, &amp;quot;free&amp;quot;,    my_free,    NULL);

//监控 sockets 生命周期
xhook_register(&amp;quot;.*\\.so$&amp;quot;, &amp;quot;getaddrinfo&amp;quot;, my_getaddrinfo, NULL);
xhook_register(&amp;quot;.*\\.so$&amp;quot;, &amp;quot;socket&amp;quot;,      my_socket,      NULL);
xhook_register(&amp;quot;.*\\.so$&amp;quot;, &amp;quot;setsockopt&amp;quot;   my_setsockopt,  NULL);
xhook_register(&amp;quot;.*\\.so$&amp;quot;, &amp;quot;bind&amp;quot;,        my_bind,        NULL);
xhook_register(&amp;quot;.*\\.so$&amp;quot;, &amp;quot;listen&amp;quot;,      my_listen,      NULL);
xhook_register(&amp;quot;.*\\.so$&amp;quot;, &amp;quot;connect&amp;quot;,     my_connect,     NULL);
xhook_register(&amp;quot;.*\\.so$&amp;quot;, &amp;quot;shutdown&amp;quot;,    my_shutdown,    NULL);
xhook_register(&amp;quot;.*\\.so$&amp;quot;, &amp;quot;close&amp;quot;,       my_close,       NULL);

//过滤出和保存部分安卓 log 到本地文件
xhook_register(&amp;quot;.*\\.so$&amp;quot;, &amp;quot;__android_log_write&amp;quot;,  my_log_write,  NULL);
xhook_register(&amp;quot;.*\\.so$&amp;quot;, &amp;quot;__android_log_print&amp;quot;,  my_log_print,  NULL);
xhook_register(&amp;quot;.*\\.so$&amp;quot;, &amp;quot;__android_log_vprint&amp;quot;, my_log_vprint, NULL);
xhook_register(&amp;quot;.*\\.so$&amp;quot;, &amp;quot;__android_log_assert&amp;quot;, my_log_assert, NULL);

//追踪某些调用 (忽略 linker 和 linker64)
xhook_register(&amp;quot;^/system/.*$&amp;quot;, &amp;quot;mmap&amp;quot;,   my_mmap,   NULL);
xhook_register(&amp;quot;^/vendor/.*$&amp;quot;, &amp;quot;munmap&amp;quot;, my_munmap, NULL);
xhook_ignore  (&amp;quot;.*/linker$&amp;quot;,   &amp;quot;mmap&amp;quot;);
xhook_ignore  (&amp;quot;.*/linker$&amp;quot;,   &amp;quot;munmap&amp;quot;);
xhook_ignore  (&amp;quot;.*/linker64$&amp;quot;, &amp;quot;mmap&amp;quot;);
xhook_ignore  (&amp;quot;.*/linker64$&amp;quot;, &amp;quot;munmap&amp;quot;);

//防御某些注入攻击
xhook_register(&amp;quot;.*com\\.hacker.*\\.so$&amp;quot;, &amp;quot;malloc&amp;quot;,  my_malloc_always_return_NULL, NULL);
xhook_register(&amp;quot;.*/libhacker\\.so$&amp;quot;,     &amp;quot;connect&amp;quot;, my_connect_with_recorder,     NULL);

//修复某些系统 bug
xhook_register(&amp;quot;.*some_vendor.*/libvictim\\.so$&amp;quot;, &amp;quot;bad_func&amp;quot;, my_nice_func, NULL);

//忽略 libwebviewchromium.so 的所有 hook 信息
xhook_ignore(&amp;quot;.*/libwebviewchromium.so$&amp;quot;, NULL);

//现在执行 hook!
xhook_refresh(1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现重点为下面几个函数:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;xhook_register&lt;/li&gt;
&lt;li&gt;xhook_ignore&lt;/li&gt;
&lt;li&gt;xhook_refresh&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;接下来依次分析&lt;/p&gt;

&lt;h1 id=&#34;分析&#34;&gt;分析&lt;/h1&gt;

&lt;h2 id=&#34;xhook-register-hook函数注册&#34;&gt;xhook_register Hook函数注册&lt;/h2&gt;

&lt;h3 id=&#34;函数申明&#34;&gt;函数申明&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int xhook_register(const char *pathname_regex_str, const char *symbol,
                   void *new_func, void **old_func) XHOOK_EXPORT;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;函数实现分析&#34;&gt;函数实现分析&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int xhook_register(const char *pathname_regex_str, const char *symbol,
                   void *new_func, void **old_func)
{
    return xh_core_register(pathname_regex_str, symbol, new_func, old_func);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;xh-core-register&#34;&gt;xh_core_register&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int xh_core_register(const char *pathname_regex_str, const char *symbol,
                     void *new_func, void **old_func)
{
    xh_core_hook_info_t *hi;
    regex_t              regex;

    if(NULL == pathname_regex_str || NULL == symbol || NULL == new_func) return XH_ERRNO_INVAL;

    if(xh_core_inited)
    {
        XH_LOG_ERROR(&amp;quot;do not register hook after refresh(): %s, %s&amp;quot;, pathname_regex_str, symbol);
        return XH_ERRNO_INVAL;
    }

    if(0 != regcomp(&amp;amp;regex, pathname_regex_str, REG_NOSUB)) return XH_ERRNO_INVAL;

    if(NULL == (hi = malloc(sizeof(xh_core_hook_info_t)))) return XH_ERRNO_NOMEM;
    if(NULL == (hi-&amp;gt;symbol = strdup(symbol)))
    {
        free(hi);
        return XH_ERRNO_NOMEM;
    }
#if XH_CORE_DEBUG
    if(NULL == (hi-&amp;gt;pathname_regex_str = strdup(pathname_regex_str)))
    {
        free(hi-&amp;gt;symbol);
        free(hi);
        return XH_ERRNO_NOMEM;
    }
#endif
    hi-&amp;gt;pathname_regex = regex;
    hi-&amp;gt;new_func = new_func;
    hi-&amp;gt;old_func = old_func;
    
    pthread_mutex_lock(&amp;amp;xh_core_mutex);
    TAILQ_INSERT_TAIL(&amp;amp;xh_core_hook_info, hi, link); // 核心
    pthread_mutex_unlock(&amp;amp;xh_core_mutex);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;xh-elf-init&#34;&gt;xh_elf_init:&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;设置 load_bias, elf_header, Program header地址.&lt;/li&gt;
&lt;li&gt;找到第一个PT_LOAD段&lt;/li&gt;
&lt;li&gt;找到dynamic_header. 之后解析dynamic segment, 找到strtab, symtab, rel.plt, .rel,等&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int xh_elf_init(xh_elf_t *self, uintptr_t base_addr, const char *pathname)
{
    if(0 == base_addr || NULL == pathname) return XH_ERRNO_INVAL;

    //always reset
    memset(self, 0, sizeof(xh_elf_t));
    
    self-&amp;gt;pathname = pathname;
    self-&amp;gt;base_addr = (ElfW(Addr))base_addr;
    self-&amp;gt;ehdr = (ElfW(Ehdr) *)base_addr;
    self-&amp;gt;phdr = (ElfW(Phdr) *)(base_addr + self-&amp;gt;ehdr-&amp;gt;e_phoff); //segmentation fault sometimes

    //find the first load-segment with offset 0
    ElfW(Phdr) *phdr0 = xh_elf_get_first_segment_by_type_offset(self, PT_LOAD, 0);
    if(NULL == phdr0)
    {
        XH_LOG_ERROR(&amp;quot;Can NOT found the first load segment. %s&amp;quot;, pathname);
        return XH_ERRNO_FORMAT;
    }

#if XH_ELF_DEBUG
    if(0 != phdr0-&amp;gt;p_vaddr)
        XH_LOG_DEBUG(&amp;quot;first load-segment vaddr NOT 0 (vaddr: %p). %s&amp;quot;,
                     (void *)(phdr0-&amp;gt;p_vaddr), pathname);
#endif

    //save load bias addr
    if(self-&amp;gt;base_addr &amp;lt; phdr0-&amp;gt;p_vaddr) return XH_ERRNO_FORMAT;
    self-&amp;gt;bias_addr = self-&amp;gt;base_addr - phdr0-&amp;gt;p_vaddr;
    
    //find dynamic-segment
    ElfW(Phdr) *dhdr = xh_elf_get_first_segment_by_type(self, PT_DYNAMIC);
    if(NULL == dhdr)
    {
        XH_LOG_ERROR(&amp;quot;Can NOT found dynamic segment. %s&amp;quot;, pathname);
        return XH_ERRNO_FORMAT;
    }

    //parse dynamic-segment
    self-&amp;gt;dyn          = (ElfW(Dyn) *)(self-&amp;gt;bias_addr + dhdr-&amp;gt;p_vaddr);
    self-&amp;gt;dyn_sz       = dhdr-&amp;gt;p_memsz;
    ElfW(Dyn) *dyn     = self-&amp;gt;dyn;
    ElfW(Dyn) *dyn_end = self-&amp;gt;dyn + (self-&amp;gt;dyn_sz / sizeof(ElfW(Dyn)));
    uint32_t  *raw;
    for(; dyn &amp;lt; dyn_end; dyn++)
    {
        switch(dyn-&amp;gt;d_tag) //segmentation fault sometimes
        {
        case DT_NULL:
            //the end of the dynamic-section
            dyn = dyn_end;
            break;
        case DT_STRTAB:
            {
                self-&amp;gt;strtab = (const char *)(self-&amp;gt;bias_addr + dyn-&amp;gt;d_un.d_ptr);
                if((ElfW(Addr))(self-&amp;gt;strtab) &amp;lt; self-&amp;gt;base_addr) return XH_ERRNO_FORMAT;
                break;
            }
        case DT_SYMTAB:
            {
                self-&amp;gt;symtab = (ElfW(Sym) *)(self-&amp;gt;bias_addr + dyn-&amp;gt;d_un.d_ptr);
                if((ElfW(Addr))(self-&amp;gt;symtab) &amp;lt; self-&amp;gt;base_addr) return XH_ERRNO_FORMAT;
                break;
            }
        case DT_PLTREL:
            //use rel or rela?
            self-&amp;gt;is_use_rela = (dyn-&amp;gt;d_un.d_val == DT_RELA ? 1 : 0);
            break;
        case DT_JMPREL:
            {
                self-&amp;gt;relplt = (ElfW(Addr))(self-&amp;gt;bias_addr + dyn-&amp;gt;d_un.d_ptr);
                if((ElfW(Addr))(self-&amp;gt;relplt) &amp;lt; self-&amp;gt;base_addr) return XH_ERRNO_FORMAT;
                break;
            }
        case DT_PLTRELSZ:
            self-&amp;gt;relplt_sz = dyn-&amp;gt;d_un.d_val;
            break;
        case DT_REL:
        case DT_RELA:
            {
                self-&amp;gt;reldyn = (ElfW(Addr))(self-&amp;gt;bias_addr + dyn-&amp;gt;d_un.d_ptr);
                if((ElfW(Addr))(self-&amp;gt;reldyn) &amp;lt; self-&amp;gt;base_addr) return XH_ERRNO_FORMAT;
                break;
            }
        case DT_RELSZ:
        case DT_RELASZ:
            self-&amp;gt;reldyn_sz = dyn-&amp;gt;d_un.d_val;
            break;
        case DT_ANDROID_REL:
        case DT_ANDROID_RELA:
            {
                self-&amp;gt;relandroid = (ElfW(Addr))(self-&amp;gt;bias_addr + dyn-&amp;gt;d_un.d_ptr);
                if((ElfW(Addr))(self-&amp;gt;relandroid) &amp;lt; self-&amp;gt;base_addr) return XH_ERRNO_FORMAT;
                break;
            }
        case DT_ANDROID_RELSZ:
        case DT_ANDROID_RELASZ:
            self-&amp;gt;relandroid_sz = dyn-&amp;gt;d_un.d_val;
            break;
        case DT_HASH:
            {
                raw = (uint32_t *)(self-&amp;gt;bias_addr + dyn-&amp;gt;d_un.d_ptr);
                if((ElfW(Addr))raw &amp;lt; self-&amp;gt;base_addr) return XH_ERRNO_FORMAT;
                self-&amp;gt;bucket_cnt  = raw[0];
                self-&amp;gt;chain_cnt   = raw[1];
                self-&amp;gt;bucket      = &amp;amp;raw[2];
                self-&amp;gt;chain       = &amp;amp;(self-&amp;gt;bucket[self-&amp;gt;bucket_cnt]);
                break;
            }
        case DT_GNU_HASH:
            {
                raw = (uint32_t *)(self-&amp;gt;bias_addr + dyn-&amp;gt;d_un.d_ptr);
                if((ElfW(Addr))raw &amp;lt; self-&amp;gt;base_addr) return XH_ERRNO_FORMAT;
                self-&amp;gt;bucket_cnt  = raw[0];
                self-&amp;gt;symoffset   = raw[1];
                self-&amp;gt;bloom_sz    = raw[2];
                self-&amp;gt;bloom_shift = raw[3];
                self-&amp;gt;bloom       = (ElfW(Addr) *)(&amp;amp;raw[4]);
                self-&amp;gt;bucket      = (uint32_t *)(&amp;amp;(self-&amp;gt;bloom[self-&amp;gt;bloom_sz]));
                self-&amp;gt;chain       = (uint32_t *)(&amp;amp;(self-&amp;gt;bucket[self-&amp;gt;bucket_cnt]));
                self-&amp;gt;is_use_gnu_hash = 1;
                break;
            }
        default:
            break;
        }
    }

    //check android rel/rela
    if(0 != self-&amp;gt;relandroid)
    {
        const char *rel = (const char *)self-&amp;gt;relandroid;
        if(self-&amp;gt;relandroid_sz &amp;lt; 4 ||
           rel[0] != &#39;A&#39; ||
           rel[1] != &#39;P&#39; ||
           rel[2] != &#39;S&#39; ||
           rel[3] != &#39;2&#39;)
        {
            XH_LOG_ERROR(&amp;quot;android rel/rela format error\n&amp;quot;);
            return XH_ERRNO_FORMAT;
        }
        
        self-&amp;gt;relandroid += 4;
        self-&amp;gt;relandroid_sz -= 4;
    }

    //check elf info
    if(0 != xh_elf_check(self))
    {
        XH_LOG_ERROR(&amp;quot;elf init check failed. %s&amp;quot;, pathname);
        return XH_ERRNO_FORMAT;
    }
    
#if XH_ELF_DEBUG
    xh_elf_dump(self);
#endif

    XH_LOG_INFO(&amp;quot;init OK: %s (%s %s PLT:%u DYN:%u ANDROID:%u)\n&amp;quot;, self-&amp;gt;pathname,
                self-&amp;gt;is_use_rela ? &amp;quot;RELA&amp;quot; : &amp;quot;REL&amp;quot;,
                self-&amp;gt;is_use_gnu_hash ? &amp;quot;GNU_HASH&amp;quot; : &amp;quot;ELF_HASH&amp;quot;,
                self-&amp;gt;relplt_sz, self-&amp;gt;reldyn_sz, self-&amp;gt;relandroid_sz);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;xh-refresh&#34;&gt;xh_refresh&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;xh_refresh -&amp;gt; xh_core_refresh -&amp;gt; xh_core_init_once

                              -&amp;gt; xh_core_refresh_impl 
   

xh_core_refresh_impl -&amp;gt; xh_core_check_elf_header
                     -&amp;gt; xh_core_hook             -&amp;gt; xh_core_hook_impl
                     
                     
xh_core_hook_impl    -&amp;gt; xh_elf_init
                     -&amp;gt; xh_elf_hook
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;xh-elf-hook&#34;&gt;xh_elf_hook&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;xh_elf_find_symidx_by_name    //find symbol index by symbol name&lt;/li&gt;
&lt;li&gt;replace.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    //find symbol index by symbol name
    if(0 != (r = xh_elf_find_symidx_by_name(self, symbol, &amp;amp;symidx))) return 0;
    
    //replace for .rel(a).plt
    if(0 != self-&amp;gt;relplt)
    {
        xh_elf_plain_reloc_iterator_init(&amp;amp;plain_iter, self-&amp;gt;relplt, self-&amp;gt;relplt_sz, self-&amp;gt;is_use_rela);
        while(NULL != (rel_common = xh_elf_plain_reloc_iterator_next(&amp;amp;plain_iter)))
        {
            if(0 != (r = xh_elf_find_and_replace_func(self,
                                                      (self-&amp;gt;is_use_rela ? &amp;quot;.rela.plt&amp;quot; : &amp;quot;.rel.plt&amp;quot;), 1,
                                                      symbol, new_func, old_func,
                                                      symidx, rel_common, &amp;amp;found))) return r;
            if(found) break;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;xh-elf-find-symidx-by-name&#34;&gt;xh_elf_find_symidx_by_name&lt;/h4&gt;

&lt;p&gt;其中: 寻找symidx, 遍历symtab,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static int xh_elf_find_symidx_by_name(xh_elf_t *self, const char *symbol, uint32_t *symidx)
{
    if(self-&amp;gt;is_use_gnu_hash)
        return xh_elf_gnu_hash_lookup(self, symbol, symidx);
    else
        return xh_elf_hash_lookup(self, symbol, symidx);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;xh-elf-find-and-replace-func&#34;&gt;xh_elf_find_and_replace_func&lt;/h4&gt;

&lt;p&gt;rel, rela表中存放这r_offset, 和symidx.&lt;/p&gt;

&lt;p&gt;真正替换的流程在&lt;strong&gt;xh_elf_find_and_replace_func&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static int xh_elf_find_and_replace_func(xh_elf_t *self, const char *section,
                                        int is_plt, const char *symbol,
                                        void *new_func, void **old_func,
                                        uint32_t symidx, void *rel_common,
                                        int *found)
{
    ElfW(Rela)    *rela;
    ElfW(Rel)     *rel;
    ElfW(Addr)     r_offset;
    size_t         r_info;
    size_t         r_sym;
    size_t         r_type;
    ElfW(Addr)     addr;
    int            r;

    if(NULL != found) *found = 0;
    
    if(self-&amp;gt;is_use_rela)
    {
        rela = (ElfW(Rela) *)rel_common;
        r_info = rela-&amp;gt;r_info;
        r_offset = rela-&amp;gt;r_offset;
    }
    else
    {
        rel = (ElfW(Rel) *)rel_common;
        r_info = rel-&amp;gt;r_info;
        r_offset = rel-&amp;gt;r_offset;
    }

    //check sym
    r_sym = XH_ELF_R_SYM(r_info);
    if(r_sym != symidx) return 0;

    //check type
    r_type = XH_ELF_R_TYPE(r_info);
    if(is_plt &amp;amp;&amp;amp; r_type != XH_ELF_R_GENERIC_JUMP_SLOT) return 0;
    if(!is_plt &amp;amp;&amp;amp; (r_type != XH_ELF_R_GENERIC_GLOB_DAT &amp;amp;&amp;amp; r_type != XH_ELF_R_GENERIC_ABS)) return 0;

    //we found it
    XH_LOG_INFO(&amp;quot;found %s at %s offset: %p\n&amp;quot;, symbol, section, (void *)r_offset);
    if(NULL != found) *found = 1;

    //do replace
    addr = self-&amp;gt;bias_addr + r_offset;
    if(addr &amp;lt; self-&amp;gt;base_addr) return XH_ERRNO_FORMAT;
    if(0 != (r = xh_elf_replace_function(self, symbol, addr, new_func, old_func)))
    {
        XH_LOG_ERROR(&amp;quot;replace function failed: %s at %s\n&amp;quot;, symbol, section);
        return r;
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>InlineHook学习分析</title>
      <link>https://l0phtg.github.io/post/inlinehook%E5%AD%A6%E4%B9%A0%E5%88%86%E6%9E%90/</link>
      <pubDate>Thu, 05 Apr 2018 02:14:31 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/inlinehook%E5%AD%A6%E4%B9%A0%E5%88%86%E6%9E%90/</guid>
      
        <description>&lt;p&gt;分析开源的inlineHook代码, 总结inlineHook的原理与实现.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;本文首发于&lt;strong&gt;看雪论坛&lt;/strong&gt;, 转载请注明出处.&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;最近在面试某大厂的安全岗位时，面试官问到了一些有关hook的知识, 在简单分析了下F8大牛的开源代码之后, 有了这篇文章.&lt;/p&gt;

&lt;h2 id=&#34;参考文章和项目代码&#34;&gt;参考文章和项目代码&lt;/h2&gt;

&lt;p&gt;文章:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://ele7enxxh.com/Android-Arm-Inline-Hook.html
http://gslab.qq.com/portal.php?mod=view&amp;amp;aid=168
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;项目:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https://github.com/ele7enxxh/Android-Inline-Hook
https://github.com/F8LEFT/FAInHook
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使用方法&#34;&gt;使用方法&lt;/h2&gt;

&lt;p&gt;MainActivity:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static {
        System.loadLibrary(&amp;quot;FHook&amp;quot;);
    }
    
public native String stringFromJNI();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们会将会测试Hook 这个&amp;rdquo;stringFromJNI()&amp;ldquo;函数.&lt;/p&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;

&lt;h4 id=&#34;使用&#34;&gt;使用&lt;/h4&gt;

&lt;p&gt;在native层, 我们的main.cpp中&lt;/p&gt;

&lt;p&gt;会在JNI_OnLoad中有一个init函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;jstring stringFromJNI(
        JNIEnv *env,
        jobject ) {
     doInHook();
    // doGotHook();
    return env-&amp;gt;NewStringUTF(getStr());
}

JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void *reserved) {
    JNIEnv* env = nullptr;
    jint resultstr = -1;
    if (vm-&amp;gt;GetEnv((void **) &amp;amp;env, JNI_VERSION_1_6) != JNI_OK) {
        return -1;
    }

    auto jclazz = env-&amp;gt;FindClass(&amp;quot;com/example/l0phtg/hookstudyf8/MainActivity&amp;quot;);
    JNINativeMethod natives[] = {
            {&amp;quot;stringFromJNI&amp;quot;, &amp;quot;()Ljava/lang/String;&amp;quot;, (void*)stringFromJNI}};
    env-&amp;gt;RegisterNatives(jclazz, natives, 1);
    env-&amp;gt;DeleteLocalRef(jclazz);

    init();

    return JNI_VERSION_1_6;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Hook.cpp我们来看一下init函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool init() {
    auto hook = FAInHook::instance();
    hook-&amp;gt;registerHook((Elf_Addr)getStr,
                       (Elf_Addr)inlCallback,
                       (Elf_Addr*)&amp;amp;inlCallbackSrc);
    auto lib = dlopen(&amp;quot;libFHook.so&amp;quot;, RTLD_NOW);
    gotCallbackSrc = (const char* (*)())dlsym(lib, &amp;quot;_Z6getStrv&amp;quot;);
    dlclose(lib);

    return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到, 我们实例化了一个FAInHook对象, &lt;code&gt;new FAInHook()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;并调用了&lt;code&gt;registerHook&lt;/code&gt;函数来注册对getStr的hook.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
FAInHook *FAInHook::instance() {
    static FAInHook* mIns = nullptr;
    if(mIns == nullptr) {
        mIns = new FAInHook();
    }
    return mIns;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们在使用是还会用到的&lt;code&gt;doInHook&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bool doInHook() {
    static bool isHooked = false;
    if (isHooked) {
        isHooked = false;
        FAInHook::instance()-&amp;gt;unhookAll();
    } else {
        isHooked = true;
        FAInHook::instance()-&amp;gt;hookAll();
    }
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;现在可以看到, 我们主要的任务就是分析&lt;code&gt;registerHook&lt;/code&gt;和&lt;code&gt;doInHook&lt;/code&gt;这两个函数的实现.&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;registerhook函数&#34;&gt;registerHook函数&lt;/h4&gt;

&lt;p&gt;我们现在主要分析&lt;code&gt;registerHook&lt;/code&gt;函数.&lt;/p&gt;

&lt;p&gt;先来分析参数:
在Hook之前我们首先要注册这个函数&lt;/p&gt;

&lt;p&gt;函数申明:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    HOOK_STATUS registerHook(Elf_Addr orginalFunAddr, Elf_Addr newFunAddr,
                             Elf_Addr* callOrigin);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数(原始函数地址, 新函数地址, 调用原始函数).&lt;/p&gt;

&lt;p&gt;函数主要流程:
1. 注册函数信息, 计算hook stub.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;首先判断`originFunAddr`和`newFunAddr`是否是函数地址.

auto info = getHookInfo(originFunAddr); 得到函数信息

然后判断函数是否已经被Hook. 
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;检查判断指令类型(thumb or arm or x86 &amp;hellip;)&lt;/li&gt;
&lt;li&gt;createStub(info)     创建stub, 就是thumb下创建ldr.w pc, [pc],   addr 来执行跳转到newFuncAddr功能&lt;/li&gt;
&lt;li&gt;createCallOriginalStub(info) 创建originalFunAddr的stub, 主要会涉及一些对pc相关指令的处理.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//  register hook
FAInHook::HOOK_STATUS FAInHook::registerHook(
        Elf_Addr orginalFunAddr, Elf_Addr newFunAddr, Elf_Addr *callOrigin) {
    // register hook information, calc hook stub at the same time.
    if(!FAHook::MemHelper::isFunctionAddr((void *) orginalFunAddr)
       || !FAHook::MemHelper::isFunctionAddr((void *) newFunAddr)) {
        return FERROR_NOT_EXECUTABLE;
    }

    auto info = getHookInfo(orginalFunAddr);
    if(nullptr != info) {
        auto hookStatus = info-&amp;gt;getHookStatus();
        if(FAHook::HOOKED == hookStatus) {
            return FERROR_ALREADY_HOOKED;
        } else if(FAHook::REGISTERED == hookStatus) {
            delHookInfo(info);
        }
    }

    // check for FunctionType
    auto type = FAHook::Instruction::getFunctionType(orginalFunAddr);
    if(FAHook::ERRTYPE == type) {
        return FERROR_UNKNOWN;
    }

    info = new FAHook::HookInfo((void *) orginalFunAddr, (void *) newFunAddr);
    info-&amp;gt;setOriginalFunctionType(type);

    FAHook::Instruction* instruction = nullptr;
    switch(type) {
#if defined(__arm__)
        case FAHook::ARM:
            instruction = new FAHook::ArmInstruction();
            break;
        case FAHook::THUMB:
            instruction = new FAHook::ThumbInstruction();
            break;
#elif defined(__aarch64__)
        case FAHook::ARM64:
            instruction = new FAHook::Arm64Instruction();
            break;
#elif defined(__i386__) || defined(__x86_64__)
        case FAHook::X86:
        case FAHook::X64:
            instruction = new FAHook::IntelInstruction();
            break;
#elif defined(__mips64__)
            case FAHook::MIPS64:
            instruction = new FAHook::Mips64Instruction();
            break;
#elif defined(__mips__)
        case FAHook::MIPS:
            instruction = new FAHook::MipsInstruction();
            break;
#endif
        default:
            assert(false &amp;amp;&amp;amp; &amp;quot;not support abi&amp;quot;);
            return FERROR_UNKNOWN;
            break;
    }

    if(!instruction-&amp;gt;createStub(info)
       || !instruction-&amp;gt;createBackStub(info)
       || (callOrigin != nullptr) ?
            !instruction-&amp;gt;createCallOriginalStub(info) : false  // want a callback
       ) {
        delete instruction;
        delete info;
        return FERROR_MEMORY;
    }

    addHookInfo(info);
    info-&amp;gt;setHookStatus(FAHook::REGISTERED);

    if(callOrigin != nullptr) {
        *callOrigin = (Elf_Addr) info-&amp;gt;getCallOriginalIns();
    }

    delete instruction;
    return FERROR_SUCCESS;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;判断该地址是否是函数地址&#34;&gt;判断该地址是否是函数地址&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;打开&lt;code&gt;/proc/self/maps&lt;/code&gt;， 读取每行的信息, 用strstr根据权限做出判断.(r-x, 表示可读可执行, 即为code)()&lt;/li&gt;
&lt;li&gt;addr &amp;gt;= startAddr &amp;amp;&amp;amp; addr &amp;lt;= endAddr&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;bool FAHook::MemHelper::isFunctionAddr(void *addr) {
    char buf[MAX_BUF];
    auto fp = fopen(maps, &amp;quot;r&amp;quot;);
    if(nullptr == fp) {
        return false;
    }

    while(fgets(buf, MAX_BUF, fp)) {
        if(strstr(buf, &amp;quot;r-xp&amp;quot;) != nullptr) {
            void* startAddr = (void*)strtoul(strtok(buf, &amp;quot;-&amp;quot;), nullptr, 16);
            void* endAddr = (void*)strtoul(strtok(nullptr, &amp;quot; &amp;quot;), nullptr, 16);
            if(addr &amp;gt;= startAddr &amp;amp;&amp;amp; addr &amp;lt;= endAddr) {
                fclose(fp);
                return true;
            }
        }
    }
    fclose(fp);
    FLOGE(this functionAddr is not a function!);
    return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;得到hook地址的信息-是否已经hook&#34;&gt;得到Hook地址的信息, 是否已经Hook.&lt;/h5&gt;

&lt;p&gt;hook_map是一个std::map&lt;Elf_Addr, FAInHook::HookInfo*&gt;的map类型. find函数会返回返回一个迭代器, 可以用&lt;code&gt;it-&amp;gt;first&lt;/code&gt;和&lt;code&gt;it-&amp;gt;second&lt;/code&gt;来访问它的成员(key和value). 这个过程其实对已经注册过的hook函数的处理.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FAHook::HookInfo *FAInHook::getHookInfo(Elf_Addr origFunAddr) {
    auto it = hook_map.find(origFunAddr);
    if(it == hook_map.end()) {
        return nullptr;
    }
    return it-&amp;gt;second;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;得到originlfunaddr的指令类型&#34;&gt;得到originlFunAddr的指令类型,&lt;/h5&gt;

&lt;p&gt;auto type = FAHook::Instruction::getFunctionType(orginalFunAddr);&lt;/p&gt;

&lt;p&gt;下面是&lt;code&gt;getFunctionAddr&lt;/code&gt;的实现, 可以看到. 判断指令类型的方式, 是通过自己定义宏来实现的. 当然, 在Arm指令中, 我们还要是否该指令为thumb指令.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;static FunctionType getFunctionType(Elf_Addr functionAddr) {
#if defined(__arm__)
            if(0 == functionAddr) {
                return ERRTYPE;
            } else if((functionAddr &amp;amp; 3) == 0) {
                return ARM;
            } else {
                return THUMB;
            }
#elif defined(__aarch64__)
            return ARM64;
#elif defined(__i386__)
            return X86;
#elif defined(__x86_64__)
            return X64;
#elif defined(__mips64__)  /* mips64el-* toolchain defines __mips__ too */
            return MIPS64;
#elif defined(__mips__)
            return MIPS;
#endif
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;接下来-我们分析最重要的过程&#34;&gt;接下来, 我们分析最重要的过程:&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;info = new HookInfo(originFunAddr, newFunAddr);&lt;/li&gt;
&lt;li&gt;info.setOriginalFunctionType(type);   设置指令类型为(Arm或者thumb)&lt;/li&gt;
&lt;li&gt;instruction = new FAHook::ArmInstruction();        new arm或者thumb指令. 我发现无构造函数.&lt;/li&gt;
&lt;li&gt;instruction-&amp;gt;createStub(info);        创建stub.(stub为 jump stub来jump到newFuncAddr)&lt;/li&gt;
&lt;li&gt;instruction-&amp;gt;createCallOriginalStub(info)    创建原函数的call back stub.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在看&lt;code&gt;HookInfo.h&lt;/code&gt;时, 我们可以看到&lt;code&gt;FAHook&lt;/code&gt;是一个&lt;code&gt;namespace&lt;/code&gt;, 而里面主要包含了一个&lt;code&gt;HookInfo&lt;/code&gt;的类:&lt;/p&gt;

&lt;p&gt;我们先来分析它的构造函数:&lt;/p&gt;

&lt;p&gt;这里运用了c++中的构造函数初始化列表来初始化类成员.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        HookInfo(void* originalAddr, void* hookAddr)
            : original_addr_(originalAddr), hook_addr_(hookAddr),
              original_stub_back_(nullptr), back_len_(0), call_original_ins_(nullptr),
              hook_status_(ERRSTATUS),
              original_function_type_(ERRTYPE), hook_function_type_(ERRTYPE){}
              

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分析&lt;code&gt;createStub(info)&lt;/code&gt;
我们这里分析&lt;code&gt;FAHook::ThumbInstrution::createStub(FAHook::HookInfo *info)&lt;/code&gt;:
1. 将地址按4字节对齐.
2. 保存我们的stub指令, (方便之后path)指令为: &lt;code&gt;LDR.W PC, [PC]&lt;/code&gt;. 可参考(&lt;a href=&#34;http://ele7enxxh.com/Android-Arm-Inline-Hook.html&#34;&gt;http://ele7enxxh.com/Android-Arm-Inline-Hook.html&lt;/a&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bool FAHook::ThumbInstruction::createStub(FAHook::HookInfo *info) {
    auto stubSize = 0;
    uint8_t *stub = nullptr;

    uint32_t addr = (uint32_t)info-&amp;gt;getOriginalAddr();
    auto clearBit0 = addr &amp;amp; 0xFFFFFFFE;

    if (clearBit0 % 4 != 0) {                       // need to align 4, just patch with nop
        stub = new uint8_t[10];
        ((uint16_t*)stub)[stubSize++] = 0xBF00;     //NOP
    } else {
        stub = new uint8_t[8];
    }
    ((uint16_t*)stub)[stubSize++] = 0xF8DF;
    ((uint16_t*)stub)[stubSize++] = 0xF000; // LDR.W PC, [PC]
    ((uint16_t*)stub)[stubSize++] = (uint32_t)info-&amp;gt;getHookAddr() &amp;amp; 0xFFFF;
    ((uint16_t*)stub)[stubSize++] = (uint32_t)info-&amp;gt;getHookAddr() &amp;gt;&amp;gt; 16;

    info-&amp;gt;setJumpStubLen(stubSize * 2);
    info-&amp;gt;setJumpStubBack(stub);
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;下面分析-createcalloriginalstub-hookinfo-info&#34;&gt;下面分析 &lt;code&gt;createCallOriginalStub(HookInfo *info)&lt;/code&gt;:&lt;/h5&gt;

&lt;p&gt;thumbInstruction.cpp的实现:&lt;/p&gt;

&lt;p&gt;基础知识:&lt;/p&gt;

&lt;p&gt;reinterpret_cast&lt;uint16_t*&gt;   为类型转换&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;处理ldr.w指令.&lt;/li&gt;
&lt;li&gt;调用createExecMemory(length);              // 分配buffer空间&lt;/li&gt;
&lt;li&gt;修正pc相关指令. (ldr liternal.  b.  b.  bl.  cbz. ldrw. add)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;为什么要修正pc相关指令?&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;举例分析: b &amp;lt;label&amp;gt;:
指令编码分析: [15:12] 1101 [11:8] cond [7:0] imm8
解析时: imm32 = ZeroExtend(imm8:&#39;0&#39;, 32); 
        BranchWritePC(PC+imm32)
可以看到, b指令的指令编码中, 存放的立即数为imm8, 而真实的跳转地址为(pc + imm32).
由于我们是要inlineHook, 所以我们的hook函数执行完成之后还有继续执行我们原来的函数,那么我们就要执行被patch掉的那些指令（我们已经将这些指令保存了下来），但由于存放这些指令的内存是我们mmap出来的,所以我们 要想能够在这里成功运行pc相关指令的话, 我们需要将pc相关的指令转换为其它pc无关的指令。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;inlineHook原理图, 来源于gslab.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://gslab.qq.com/data/attachment/portal/201605/04/165921tz43a3sm4vi2s4s4.png&#34; alt=&#34;inlineHook原理图 ---  来源于gslab&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool FAHook::ThumbInstruction::createCallOriginalStub(FAHook::HookInfo *info) {
    uint16_t *area(reinterpret_cast&amp;lt;uint16_t *&amp;gt;(getOriginalAddr(info)));    // 起始地址


    uint16_t *trail(reinterpret_cast&amp;lt;uint16_t *&amp;gt;(
                            reinterpret_cast&amp;lt;uintptr_t &amp;gt;(area) + info-&amp;gt;getJumpStubLen())); // 结束地址

    if(T$pcrel$ldrw(area[0]) &amp;amp;&amp;amp;  // 第一条指令
        area[1] == 0xF000   // 判断第一条指令是否为 ldr pc, [pc]  
            ) {
        uint32_t *arm(reinterpret_cast&amp;lt;uint32_t *&amp;gt;(area));
        info-&amp;gt;setCallOriginalIns(reinterpret_cast&amp;lt;uint8_t *&amp;gt;(arm[1]));
        return true;
    }

    size_t required((trail - area) * sizeof(uint16_t)); // required == 需要patch多少字节

    size_t used(0);
    while (used &amp;lt; required)
        used += MSGetInstructionWidthThumb(reinterpret_cast&amp;lt;uint8_t *&amp;gt;(area) + used);
    used = (used + sizeof(uint16_t) - 1) / sizeof(uint16_t) * sizeof(uint16_t);

    size_t blank((used - required) / sizeof(uint16_t));

    uint16_t backup[used / sizeof(uint16_t)];
    memcpy(backup, area, used);


    size_t length(used);
    for (unsigned offset(0); offset != used / sizeof(uint16_t); ++offset)
        if (T$pcrel$ldr(backup[offset]))
            length += 3 * sizeof(uint16_t);
        else if (T$pcrel$b(backup[offset]))
            length += 6 * sizeof(uint16_t);
        else if (T2$pcrel$b(backup + offset)) {
            length += 5 * sizeof(uint16_t);
            ++offset;
        } else if (T$pcrel$bl(backup + offset)) {
            length += 5 * sizeof(uint16_t);
            ++offset;
        } else if (T$pcrel$cbz(backup[offset])) {
            length += 16 * sizeof(uint16_t);
        } else if (T$pcrel$ldrw(backup[offset])) {
            length += 4 * sizeof(uint16_t);
            ++offset;
        } else if (T$pcrel$add(backup[offset]))
            length += 6 * sizeof(uint16_t);
        else if (T$32bit$i(backup[offset]))
            ++offset;

        unsigned pad((length &amp;amp; 0x2) == 0 ? 0 : 1);
        length += (pad + 2) * sizeof(uint16_t) + 2 * sizeof(uint32_t);

    uint16_t *buffer = (uint16_t *) MemHelper::createExecMemory(length);
    if(buffer == nullptr) {
        return false;
    }

    size_t start(pad), end(length / sizeof(uint16_t));
    uint32_t *trailer(reinterpret_cast&amp;lt;uint32_t *&amp;gt;(buffer + end));
    for (unsigned offset(0); offset != used / sizeof(uint16_t); ++offset) {
        if (T$pcrel$ldr(backup[offset])) {
            union {
                uint16_t value;

                struct {
                    uint16_t immediate : 8;
                    uint16_t rd : 3;
                    uint16_t : 5;
                };
            } bits = {backup[offset+0]};

            buffer[start+0] = T$ldr_rd_$pc_im_4$(bits.rd, T$Label(start+0, end-2) / 4);
            buffer[start+1] = T$ldr_rd_$rn_im_4$(bits.rd, bits.rd, 0);

            // XXX: this code &amp;quot;works&amp;quot;, but is &amp;quot;wrong&amp;quot;: the mechanism is more complex than this
            *--trailer = ((reinterpret_cast&amp;lt;uint32_t&amp;gt;(area + offset) + 4) &amp;amp; ~0x2) + bits.immediate * 4;

            start += 2;
            end -= 2;
        } else if (T$pcrel$b(backup[offset])) {
            union {
                uint16_t value;

                struct {
                    uint16_t imm8 : 8;
                    uint16_t cond : 4;
                    uint16_t /*1101*/ : 4;
                };
            } bits = {backup[offset+0]};

            intptr_t jump(bits.imm8 &amp;lt;&amp;lt; 1);
            jump |= 1;
            jump &amp;lt;&amp;lt;= 23;
            jump &amp;gt;&amp;gt;= 23;

            buffer[start+0] = T$b$_$im(bits.cond, (end-6 - (start+0)) * 2 - 4);

            *--trailer = reinterpret_cast&amp;lt;uint32_t&amp;gt;(area + offset) + 4 + jump;
            *--trailer = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);
            *--trailer = T$nop &amp;lt;&amp;lt; 16 | T$bx(A$pc);

            start += 1;
            end -= 6;
        } else if (T2$pcrel$b(backup + offset)) {
            union {
                uint16_t value;

                struct {
                    uint16_t imm6 : 6;
                    uint16_t cond : 4;
                    uint16_t s : 1;
                    uint16_t : 5;
                };
            } bits = {backup[offset+0]};

            union {
                uint16_t value;

                struct {
                    uint16_t imm11 : 11;
                    uint16_t j2 : 1;
                    uint16_t a : 1;
                    uint16_t j1 : 1;
                    uint16_t : 2;
                };
            } exts = {backup[offset+1]};

            intptr_t jump(1);
            jump |= exts.imm11 &amp;lt;&amp;lt; 1;
            jump |= bits.imm6 &amp;lt;&amp;lt; 12;

            if (exts.a) {
                jump |= bits.s &amp;lt;&amp;lt; 24;
                jump |= (~(bits.s ^ exts.j1) &amp;amp; 0x1) &amp;lt;&amp;lt; 23;
                jump |= (~(bits.s ^ exts.j2) &amp;amp; 0x1) &amp;lt;&amp;lt; 22;
                jump |= bits.cond &amp;lt;&amp;lt; 18;
                jump &amp;lt;&amp;lt;= 7;
                jump &amp;gt;&amp;gt;= 7;
            } else {
                jump |= bits.s &amp;lt;&amp;lt; 20;
                jump |= exts.j2 &amp;lt;&amp;lt; 19;
                jump |= exts.j1 &amp;lt;&amp;lt; 18;
                jump &amp;lt;&amp;lt;= 11;
                jump &amp;gt;&amp;gt;= 11;
            }

            buffer[start+0] = T$b$_$im(exts.a ? A$al : bits.cond, (end-6 - (start+0)) * 2 - 4);

            *--trailer = reinterpret_cast&amp;lt;uint32_t&amp;gt;(area + offset) + 4 + jump;
            *--trailer = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);
            *--trailer = T$nop &amp;lt;&amp;lt; 16 | T$bx(A$pc);

            ++offset;
            start += 1;
            end -= 6;
        } else if (T$pcrel$bl(backup + offset)) {
            union {
                uint16_t value;

                struct {
                    uint16_t immediate : 10;
                    uint16_t s : 1;
                    uint16_t : 5;
                };
            } bits = {backup[offset+0]};

            union {
                uint16_t value;

                struct {
                    uint16_t immediate : 11;
                    uint16_t j2 : 1;
                    uint16_t x : 1;
                    uint16_t j1 : 1;
                    uint16_t : 2;
                };
            } exts = {backup[offset+1]};

            int32_t jump(0);
            jump |= bits.s &amp;lt;&amp;lt; 24;
            jump |= (~(bits.s ^ exts.j1) &amp;amp; 0x1) &amp;lt;&amp;lt; 23;
            jump |= (~(bits.s ^ exts.j2) &amp;amp; 0x1) &amp;lt;&amp;lt; 22;
            jump |= bits.immediate &amp;lt;&amp;lt; 12;
            jump |= exts.immediate &amp;lt;&amp;lt; 1;
            jump |= exts.x;
            jump &amp;lt;&amp;lt;= 7;
            jump &amp;gt;&amp;gt;= 7;

            buffer[start+0] = T$push_r(1 &amp;lt;&amp;lt; A$r7);
            buffer[start+1] = T$ldr_rd_$pc_im_4$(A$r7, ((end-2 - (start+1)) * 2 - 4 + 2) / 4);
            buffer[start+2] = T$mov_rd_rm(A$lr, A$r7);
            buffer[start+3] = T$pop_r(1 &amp;lt;&amp;lt; A$r7);
            buffer[start+4] = T$blx(A$lr);

            *--trailer = reinterpret_cast&amp;lt;uint32_t&amp;gt;(area + offset) + 4 + jump;

            ++offset;
            start += 5;
            end -= 2;
        } else if (T$pcrel$cbz(backup[offset])) {
            union {
                uint16_t value;

                struct {
                    uint16_t rn : 3;
                    uint16_t immediate : 5;
                    uint16_t : 1;
                    uint16_t i : 1;
                    uint16_t : 1;
                    uint16_t op : 1;
                    uint16_t : 4;
                };
            } bits = {backup[offset+0]};

            intptr_t jump(1);
            jump |= bits.i &amp;lt;&amp;lt; 6;
            jump |= bits.immediate &amp;lt;&amp;lt; 1;

            //jump &amp;lt;&amp;lt;= 24;
            //jump &amp;gt;&amp;gt;= 24;

            unsigned rn(bits.rn);
            unsigned rt(rn == A$r7 ? A$r6 : A$r7);

            buffer[start+0] = T$push_r(1 &amp;lt;&amp;lt; rt);
            buffer[start+1] = T1$mrs_rd_apsr(rt);
            buffer[start+2] = T2$mrs_rd_apsr(rt);
            buffer[start+3] = T$cbz$_rn_$im(bits.op, rn, (end-10 - (start+3)) * 2 - 4);
            buffer[start+4] = T1$msr_apsr_nzcvqg_rn(rt);
            buffer[start+5] = T2$msr_apsr_nzcvqg_rn(rt);
            buffer[start+6] = T$pop_r(1 &amp;lt;&amp;lt; rt);

            *--trailer = reinterpret_cast&amp;lt;uint32_t&amp;gt;(area + offset) + 4 + jump;
            *--trailer = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);
            *--trailer = T$nop &amp;lt;&amp;lt; 16 | T$bx(A$pc);
            *--trailer = T$nop &amp;lt;&amp;lt; 16 | T$pop_r(1 &amp;lt;&amp;lt; rt);
            *--trailer = T$msr_apsr_nzcvqg_rn(rt);

#if 0
            if ((start &amp;amp; 0x1) == 0)
                buffer[start++] = T$nop;
            buffer[start++] = T$bx(A$pc);
            buffer[start++] = T$nop;

            uint32_t *arm(reinterpret_cast&amp;lt;uint32_t *&amp;gt;(buffer + start));
            arm[0] = A$add(A$lr, A$pc, 1);
            arm[1] = A$ldr_rd_$rn_im$(A$pc, A$pc, (trailer - arm) * sizeof(uint32_t) - 8);
#endif

            start += 7;
            end -= 10;
        } else if (T$pcrel$ldrw(backup[offset])) {
            union {
                uint16_t value;

                struct {
                    uint16_t : 7;
                    uint16_t u : 1;
                    uint16_t : 8;
                };
            } bits = {backup[offset+0]};

            union {
                uint16_t value;

                struct {
                    uint16_t immediate : 12;
                    uint16_t rt : 4;
                };
            } exts = {backup[offset+1]};

            buffer[start+0] = T1$ldr_rt_$rn_im$(exts.rt, A$pc, T$Label(start+0, end-2));
            buffer[start+1] = T2$ldr_rt_$rn_im$(exts.rt, A$pc, T$Label(start+0, end-2));

            buffer[start+2] = T1$ldr_rt_$rn_im$(exts.rt, exts.rt, 0);
            buffer[start+3] = T2$ldr_rt_$rn_im$(exts.rt, exts.rt, 0);

            // XXX: this code &amp;quot;works&amp;quot;, but is &amp;quot;wrong&amp;quot;: the mechanism is more complex than this
            *--trailer = ((reinterpret_cast&amp;lt;uint32_t&amp;gt;(area + offset) + 4) &amp;amp; ~0x2) + (bits.u == 0 ? -exts.immediate : exts.immediate);

            ++offset;
            start += 4;
            end -= 2;
        } else if (T$pcrel$add(backup[offset])) {
            union {
                uint16_t value;

                struct {
                    uint16_t rd : 3;
                    uint16_t rm : 3;
                    uint16_t h2 : 1;
                    uint16_t h1 : 1;
                    uint16_t : 8;
                };
            } bits = {backup[offset+0]};

            if (bits.h1) {
                return false;
            }

            unsigned rt(bits.rd == A$r7 ? A$r6 : A$r7);

            buffer[start+0] = T$push_r(1 &amp;lt;&amp;lt; rt);
            buffer[start+1] = T$mov_rd_rm(rt, (bits.h1 &amp;lt;&amp;lt; 3) | bits.rd);
            buffer[start+2] = T$ldr_rd_$pc_im_4$(bits.rd, T$Label(start+2, end-2) / 4);
            buffer[start+3] = T$add_rd_rm((bits.h1 &amp;lt;&amp;lt; 3) | bits.rd, rt);
            buffer[start+4] = T$pop_r(1 &amp;lt;&amp;lt; rt);
            *--trailer = reinterpret_cast&amp;lt;uint32_t&amp;gt;(area + offset) + 4;

            start += 5;
            end -= 2;
        } else if (T$32bit$i(backup[offset])) {
            buffer[start++] = backup[offset];
            buffer[start++] = backup[++offset];
        } else {
            buffer[start++] = backup[offset];
        }
    }

    buffer[start++] = T$bx(A$pc);
    buffer[start++] = T$nop;

    uint32_t *transfer = reinterpret_cast&amp;lt;uint32_t *&amp;gt;(buffer + start);
    transfer[0] = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);
    transfer[1] = reinterpret_cast&amp;lt;uint32_t&amp;gt;(area + used / sizeof(uint16_t)) + 1;

    info-&amp;gt;setCallOriginalIns(reinterpret_cast&amp;lt;uint8_t *&amp;gt;(buffer + pad) + 1);

    return true;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;msgetinstructionwiththumb&#34;&gt;MSGetInstructionWithThumb&lt;/h5&gt;

&lt;p&gt;调用    used += MSGetInstructionWithThumb(reinterpret_cast&lt;uint8_t *&gt;(area) + used);
MSGetInstructionWithThumb: 参数为(uint16_t*).
返回结果: 为这条指令是多少字节的指令.(4 or 2)&lt;/p&gt;

&lt;p&gt;T$32bit$i的作用: (指令(ic) &amp;amp; 1110 0000 0000 0000) &amp;amp;&amp;amp; (ic &amp;amp; 0001 1000 0000 0000 != 0x0000);
第一个判断为确定高位3个bit(即bit[15], bit[14], bit[13])为1. 第二个判断为确保bit[12], bit[11]有值(即至少这两位有 1 位为 1).&lt;/p&gt;

&lt;p&gt;&lt;code&gt;其实就是判断是该thumb指令是否为thumb32指令,&lt;/code&gt;
&lt;code&gt;thumb32指令的判断依据是 b[15:11] 为 0b11101或0b11110或0b11111.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;MSGetInstructionWithThumb:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;        static size_t MSGetInstructionWidthThumb(void *start) {
            uint16_t *thumb(reinterpret_cast&amp;lt;uint16_t *&amp;gt;(start));   //
            return T$32bit$i(thumb[0]) ? 4 : 2;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;T$32bit$i:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;        static inline bool T$32bit$i(uint16_t ic) {
            return ((ic &amp;amp; 0xe000) == 0xe000 &amp;amp;&amp;amp; (ic &amp;amp; 0x1800) != 0x0000);
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;分析memhelper类&#34;&gt;分析MemHelper类&lt;/h4&gt;

&lt;p&gt;有4个方法:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;static bool isFunctionAddr(void* addr);&lt;/li&gt;
&lt;li&gt;static bool unProtectMemory(void* addr, uint32_t size);  remove 写保护&lt;/li&gt;
&lt;li&gt;static bool protectMemory(void* addr, uint32_t size);    add    写保护&lt;/li&gt;
&lt;li&gt;static void* createExecMemory(uint32_t size);            创建一个可执行的内存&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有4个field:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;std::vector&lt;void*&gt; all_memory_page;&lt;/li&gt;
&lt;li&gt;void* current_page = nullptr;&lt;/li&gt;
&lt;li&gt;uint32_t page_ptr  = 0;&lt;/li&gt;
&lt;li&gt;static uint32_t page_size;      // 构造函数&lt;code&gt;page_size = sysconf(_SC_PAGESIZE).&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们现在分析一下&lt;code&gt;createExecMemory(uint32_t size)&lt;/code&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;可以看到, 分配内存的操作是通过&lt;code&gt;mmap&lt;/code&gt;实现的.&lt;/li&gt;
&lt;li&gt;all_memory_page是一个vector, 每个单位保存一个指针, 指向mmap的内存.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;createExecMemory:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void *FAHook::MemHelper::createExecMemory(uint32_t size) {
    if(size &amp;amp; 1) {
        size ++;
    }
    if(size &amp;gt; page_size) {
        return nullptr;
    }
    if(gMemHelper.current_page != nullptr &amp;amp;&amp;amp; page_size - gMemHelper.page_ptr_ &amp;gt;= size) {
        auto funPtr = (void*)((size_t)gMemHelper.current_page + gMemHelper.page_ptr_);
        gMemHelper.page_ptr_ += size;
        // Align 4
        while(gMemHelper.page_ptr_ &amp;amp; 0x3) {
            gMemHelper.page_ptr_ ++;
        }
        return funPtr;
    }
    // scroll to next page
    auto newPage = mmap(nullptr, page_size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANONYMOUS | MAP_PRIVATE, 0, 0);
    if(newPage != MAP_FAILED) {
        gMemHelper.alloc_memory_page_.push_back(newPage);

        gMemHelper.current_page = newPage;
        gMemHelper.page_ptr_ = 0;
        return createExecMemory(size);
    }
    return nullptr;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;分析doinhook&#34;&gt;分析doInHook&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;主要操作: FAInHook::instance()-&amp;gt;hookAll();&lt;/li&gt;
&lt;li&gt;FAInHook::instance()-&amp;gt;unHookAll();&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool doInHook() {
    static bool isHooked = false;
    if (isHooked) {
        isHooked = false;
        FAInHook::instance()-&amp;gt;unhookAll();
    } else {
        isHooked = true;
        FAInHook::instance()-&amp;gt;hookAll();
    }
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;hookAll():&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void FAInHook::hookAll() {
    for(auto it: hook_map) {
        if(it.second-&amp;gt;getHookStatus() == FAHook::REGISTERED) {
            Hook(it.second);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进而转到Hook函数
1. 调用`enableJumpStub(info)
2. info-&amp;gt;setHookStatus(FAHook::HOOKED)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bool FAInHook::Hook(FAHook::HookInfo *info) {
    if(!FAHook::Instruction::enableJumpStub(info)) {
        return false;
    }
    info-&amp;gt;setHookStatus(FAHook::HOOKED);
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分析&lt;code&gt;enableJumpStub(info)&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bool FAHook::Instruction::enableJumpStub(FAHook::HookInfo *info) {
    auto origAddr = getOriginalAddr(info);
    auto len = info-&amp;gt;getJumpStubLen();
    auto stubAddr = info-&amp;gt;getJumpStubBack();
    return patchMemory(origAddr, stubAddr, len);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到, 在得到了&lt;code&gt;origAddr&lt;/code&gt;和&lt;code&gt;stubAddr&lt;/code&gt;和&lt;code&gt;len&lt;/code&gt;之后,我们会进入到patch函数&lt;code&gt;patchMemory&lt;/code&gt;, 根据我们前面的分析, 它会patch原函数的入口指令的前(8 or 10?)个字节.&lt;/p&gt;

&lt;p&gt;patchMemory:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bool FAHook::Instruction::patchMemory(void *dest, void *src, uint32_t len) {
    if(dest == nullptr || src == nullptr || len == 0) {
        return false;
    }
    if(!MemHelper::unProtectMemory(dest, len)) {
        return false;
    }

    memcpy(dest, src, len);
    MemHelper::protectMemory(dest, len);
#ifdef __arm__
    cacheflush((Elf_Addr)dest, (Elf_Addr)dest + len, 0);
#endif
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先会调用&lt;code&gt;unProtectMemory&lt;/code&gt;函数来将对应内存修改为(rwx), 然后调用&lt;code&gt;memcpy&lt;/code&gt;来修改内存, 最后调用&lt;code&gt;protectMemory&lt;/code&gt;来修改对应内存为(r-x).&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;现在我们就基本对该项目进行了简单的分析, 我这里总结一下:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;registerHook
主要操作其实就是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;createStub:  创建代理(这个代理就是要执行跳转到我们的&lt;code&gt;newFuncAddr&lt;/code&gt;函数)&lt;/li&gt;
&lt;li&gt;createCallOriginalStub:  call back代理(这个代理就是执行回调, 回调我们的&lt;code&gt;originalFunAddr&lt;/code&gt;.) 主要涉及处理pc相关指令(原因在文中已经有介绍).
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;doInHook&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;主要就是patchMemory. patch我们originalFunAddr的函数起始处的几个指令为&lt;code&gt;stubInstruction&lt;/code&gt;.之后函数涉及pc相关指令的修复, 方便继续执行原函数.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;unHook&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;也是patchMemory.
就是将我们原函数的原始指令进行复原.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
      
    </item>
    
    <item>
      <title>装机日志-deepin</title>
      <link>https://l0phtg.github.io/post/%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97-deepin/</link>
      <pubDate>Thu, 28 Dec 2017 11:47:58 +0000</pubDate>
      
      <guid>https://l0phtg.github.io/post/%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97-deepin/</guid>
      
        <description>&lt;p&gt;17年使用了一段时间deepin系统, 这里简单记录一些使用心得(现在已转ubuntu.&lt;/p&gt;

&lt;p&gt;主要就是&lt;strong&gt;装机的过程&lt;/strong&gt;, 以及&lt;strong&gt;装机后的效果展示&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/deepin/desktop.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;最近一直在码代码和写.md, 深刻体会到在windows上办公有多么艰难. 安装了一下&lt;code&gt;spacevim/neovim&lt;/code&gt;后, 意识到了高效率的办公会给人带来很大的乐趣. 所以, 在遇到了很多与环境配置相关的问题(却解决不了之后), 毅然决定更换系统.&lt;/p&gt;

&lt;h2 id=&#34;选择&#34;&gt;选择&lt;/h2&gt;

&lt;p&gt;犹豫了一天到底是该装&lt;code&gt;Ubuntu16.04&lt;/code&gt;还是&lt;code&gt;deepin&lt;/code&gt;(&lt;code&gt;导致上课前, 忘了给舍友刷卡...&lt;/code&gt;).最终还是经不住deepin&lt;code&gt;绚丽的UI设计&lt;/code&gt;的诱惑, 决定尝试一下&lt;code&gt;deepin&lt;/code&gt;.(&lt;strong&gt;没错, 颜值在我心中就是这么重要&lt;/strong&gt;)&lt;/p&gt;

&lt;h2 id=&#34;装机过程&#34;&gt;装机过程&lt;/h2&gt;

&lt;p&gt;装机过程很简单, 下载好官方的镜像源, 之后检验一下&lt;strong&gt;md5&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$checksum  

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后用&lt;strong&gt;官方的启动盘制作工具&lt;/strong&gt;把U盘装入deepin, 重启时插入U盘, 设置为U盘启动就可以了.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重点来了&lt;/strong&gt;, 因为我不想用windows10了, 所以直接把系统装在c盘中, 因为原来的系统有&lt;strong&gt;3个分区, 所以装机时不用格式化 D 盘 和 E 盘&lt;/strong&gt;(&lt;code&gt;我的E盘有7/8个虚拟机文件, 在装好deepin后, 依然可以正常使用&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;装机总结:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;deepin系统装入c盘.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;D盘, E盘可以不用格式化.(当然, 如果电脑里没啥重要文件的, skip it)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;下来就是激动人心的时刻了&#34;&gt;下来就是激动人心的时刻了&lt;/h2&gt;

&lt;p&gt;先放几张图:&lt;/p&gt;

&lt;p&gt;桌面&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/deepin/desktop.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;分屏&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/deepin/splitScreen.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们最爱的vim&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/deepin/vimMarkdownPreview.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当然, 还有很多其它的不错的设计, 这里就不多放图了.&lt;/p&gt;

&lt;h3 id=&#34;配置nvim-spacevim&#34;&gt;配置nvim/spacevim&lt;/h3&gt;

&lt;p&gt;依赖项:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;python支持: 建议先&lt;code&gt;pip install neovim&lt;/code&gt;和&lt;code&gt;pip3 install neovim&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;font支持: (读者可以自行查看readme进行安装) git地址: &lt;code&gt;https://github.com/powerline/fonts.git&lt;/code&gt; , 用来更好的显示vim界面(字体, 状态栏&amp;hellip;).&lt;/li&gt;
&lt;li&gt;tagbar支持: 安装 &lt;code&gt;ctags&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo apt install ctags
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;安装&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;neovim安装: &lt;code&gt;sudo apt install neovim&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Spacevim安装: (读者可以自行查看readme进行安装) git地址: &lt;code&gt;https://github.com/SpaceVim/SpaceVim&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;init.nvim(来, 放出我们的口号: &lt;strong&gt;打造属于自己的编辑器&lt;/strong&gt;, 这个文件是用户配置文件, 读者可以自行配置)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我这里只是对自己的需求进行了简单的配置:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;配置markdown预览:(因为它默认预览采用的插件是&lt;code&gt;iamcoo/MarkdownPreview.vim&lt;/code&gt;, 所以根据该插件作者的说明进行配置)&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;默认预览浏览器为&lt;code&gt;google-chrome&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;let g:mkdp_path_to_chrome = &#39;google-chrome&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;映射预览为&lt;code&gt;F4&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nmap &amp;lt;silent&amp;gt; &amp;lt;F4&amp;gt; &amp;lt;Plug&amp;gt;MarkdownPreview        &amp;quot; for normal mode
imap &amp;lt;silent&amp;gt; &amp;lt;F4&amp;gt; &amp;lt;Plug&amp;gt;MarkdownPreview        &amp;quot; for insert mode
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;设置状态栏分隔符为箭头:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;let g:spacevim_statusline_separator = &#39;arrow&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;配置zsh-oh-my-zsh&#34;&gt;配置zsh/oh-my-zsh&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;安装zsh&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt install zsh
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;安装oh-my-zsh&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sh -c &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体的配置看个人喜好.&lt;/p&gt;

&lt;h3 id=&#34;安装tools&#34;&gt;安装tools&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/PikachuHy/..&#34;&gt;https://github.com/PikachuHy/..&lt;/a&gt;.       &lt;code&gt;一位大佬写的net工具,  大家懂得&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;总之, &lt;code&gt;deepin&lt;/code&gt;还是带给我很大的惊喜的.  &lt;code&gt;deepin终端&lt;/code&gt;, &lt;code&gt;深度截图&lt;/code&gt;, 还可以愉快的使用网络, 开心的在linux下办公hahahahaha.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>thumb指令虚拟化学习(一)</title>
      <link>https://l0phtg.github.io/post/thumb%E6%8C%87%E4%BB%A4%E8%99%9A%E6%8B%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B8%80/</link>
      <pubDate>Tue, 24 Oct 2017 20:23:30 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/thumb%E6%8C%87%E4%BB%A4%E8%99%9A%E6%8B%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B8%80/</guid>
      
        <description>&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/thumb-vmp/thumb16.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上半年接触过一些 &lt;strong&gt;app加固&lt;/strong&gt; 的知识, 对 &lt;strong&gt;vm&lt;/strong&gt; 这块一直空有兴趣而没有了解过;  最近, 阅读了几篇文章, &lt;code&gt;有所启发&lt;/code&gt;, 所以决定学习一下 &lt;strong&gt;vm&lt;/strong&gt; 这块的一些操作.&lt;/p&gt;

&lt;p&gt;主要内容分为:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;环境搭建&lt;/li&gt;
&lt;li&gt;提取指令&lt;/li&gt;
&lt;li&gt;capstone处理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;阅读资料&#34;&gt;阅读资料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/knownsec/KCon/blob/master/2017/%5BKCon%202017%5D0827_3_%E9%99%88%E6%84%89%E9%91%AB_%E7%AC%AC%E4%BA%94%E4%BB%A3%E5%8A%A0%E5%9B%BA%E6%8A%80%E6%9C%AFARM%20VMP%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%BA%94%E7%94%A8.pdf&#34;&gt;Kcon2017 第五代加固技术ARM VMP原理与应用&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/2014asm/p/6534897.html&#34;&gt;ARM平台指令虚拟化探索&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;环境搭建&#34;&gt;环境搭建:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;需要安装python的capstone模块, 可以直接使用pip安装. (另外: &lt;strong&gt;强烈建议下载capstone源码, 以便随时阅读&lt;/strong&gt;.)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
    sudo apt install libcapstone3
    sudo apt install libcapstone-dev
    pip install capstone

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ida/radare2 &lt;code&gt;在本节中, 提取指令的时候会用到&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;arm官方文档(&lt;a href=&#34;https://yurichev.com/mirrors/ARMv8-A_Architecture_Reference_Manual_(Issue_A.a).pdf&#34;&gt;https://yurichev.com/mirrors/ARMv8-A_Architecture_Reference_Manual_(Issue_A.a).pdf&lt;/a&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;本篇文章大致分为如下几个部分&#34;&gt;本篇文章大致分为如下几个部分:&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;手动提取编译好的可执行文件中的 &lt;strong&gt;你想要加密的函数&lt;/strong&gt;, 并转换为 &lt;strong&gt;16进制的格式&lt;/strong&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;初步了解 &lt;strong&gt;capstone&lt;/strong&gt; 中的 &lt;strong&gt;对Arm指令进行处理的操作函数&lt;/strong&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;了解 &lt;strong&gt;thumb指令编码&lt;/strong&gt; , &lt;code&gt;此处研究thumb的原因是: 在提出函数的bytes时, 发现自定义的函数, 都被转换成了thumb指令的格式, 所以笔者先研究thumb;  当然, 要知道, thumb并不是独立于arm存在的, thumb的存在是为了提高效率&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;设计自己的一套 &lt;strong&gt;指令集&lt;/strong&gt; , &lt;code&gt;很简单的一套指令集, 能模拟常见的thumb指令, 例如 push, pop, str, ldr, add, sub, mov, cmp, blx ...&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;写代码, &lt;code&gt;此处参考了capstone源码中的/bindings/python/capstone/* 中的有关代码, 初学py, 代码写的差, 有什么建议还请多多交流)&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;提取指令&#34;&gt;提取指令.&lt;/h3&gt;

&lt;p&gt;我们提取的是下面程序中的 &lt;strong&gt;judge&lt;/strong&gt; 函数.&lt;/p&gt;

&lt;h4 id=&#34;用ida提取&#34;&gt;用ida提取:&lt;/h4&gt;

&lt;p&gt;我们将会在这篇文章中用到的程序:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

char key[16] = {&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;q&#39;, &#39;r&#39;, &#39;c&#39;, &#39;o&#39;, &#39;b&#39;, &#39;g&#39;, &#39;s&#39;, &#39;k&#39;};

int judge(const char *s)
{
    int ret = 1;
    char c[16] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;q&#39;, &#39;s&#39;, &#39;e&#39;, &#39;r&#39;, &#39;b&#39;, &#39;h&#39;, &#39;u&#39;, &#39;n&#39;};
    int i;
    for (i = 0; i &amp;lt; 16; i++)
    {
        switch(i % 4)   
        {
        case 0: 
            if (s[i]  == c[i])
                continue;
            break;  
        case 1:
            if (s[i] + 1 == c[i])
                continue;
            break;
        case 2:
            if (s[i] + 2 == c[i])
                continue;
            break;
        case 3:
            if (s[i] + 3 == c[i])
                continue; 
            break;
        } 
        ret = 0; 
    }
    return ret;
}

int main(int argc, char *argv[])
{
    printf(&amp;quot;hello World\n&amp;quot;);
    char a[16];
    scanf(&amp;quot;%s&amp;quot;, a);

    if (judge(a) == 1)
        printf(&amp;quot;ok&amp;quot;);
    else
        printf(&amp;quot;error&amp;quot;);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用ndk-build编译成armv7a可执行程序后, 放入ida中, 用idc脚本提::&lt;/p&gt;

&lt;p&gt;idc脚本, start为judge函数的起始地址, end为judge函数的结束地址.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;idc.idc&amp;gt;

static main() {
    auto start, end, fd, i, inst;
    fd = fopen(&amp;quot;D:\\idaResult\\armOpcodeByte.txt&amp;quot;, &amp;quot;wt+&amp;quot;);
    start = 0x863c;
    end = 0x86BA;
    
    for(i = start; i &amp;lt; end; i++) {
        inst = Byte(i);
        fprintf(fd, &amp;quot;\\x%02x&amp;quot;, inst);
    }
    fclose(fd);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提取出来后的结果:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;\x1f\x49\xf0\xb5\x79\x44\x09\x68\x87\xb0\x07\x46\x0b\x68\x01\xaa\x0d\x46\x16\x46\x05\x93\x1b\x4b\x7b\x44\x03\xf1\x10\x0e\x18\x68\x08\x33\x53\xf8\x04\x1c\x73\x45\x14\x46\x03\xc4\x22\x46\xf6\xd1\x3a\x46\x00\x23\x01\x20\x03\xf0\x03\x01\x02\x29\x09\xd0\x03\x29\x0a\xd0\x01\x29\x02\xd0\x14\x78\xf1\x5c\x08\xe0\x11\x78\x01\x31\x04\xe0\x11\x78\x02\x31\x01\xe0\x11\x78\x03\x31\xf4\x5c\x01\x33\xa1\x42\x18\xbf\x00\x20\x10\x2b\x02\xf1\x01\x02\xe3\xd1\x05\x9a\x2b\x68\x9a\x42\x01\xd0\xff\xf7\x0a\xef\x07\xb0\xf0\xbd
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;用radare2提取&#34;&gt;用radare2提取&lt;/h4&gt;

&lt;p&gt;(才发现原来radare2 v2.0都已经发布了)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;对r2语法不做讲解了, 网上也有了一些文章, 大家可以去看&lt;/code&gt;.  笔者本身也不是很熟悉~&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;username-l0phtg@L0phTg:armeabi-v7a$ r2 test
 -- Interpret radare2 scripts with &#39;. &amp;lt;path-to-script&amp;gt;&#39;. Similar to the bash source alias command.
[0x000085a0]&amp;gt; aa
[x] Analyze all flags starting with sym. and entry0 (aa)
[0x000085a0]&amp;gt; afl~judge
0x0000863c   17 126          sym.judge
[0x000085a0]&amp;gt; 0x863c
[0x0000863c]&amp;gt; pcp 126
import struct
buf = struct.pack (&amp;quot;126B&amp;quot;, *[
0x1f,0x49,0xf0,0xb5,0x79,0x44,0x09,0x68,0x87,0xb0,0x07,
0x46,0x0b,0x68,0x01,0xaa,0x0d,0x46,0x16,0x46,0x05,0x93,
0x1b,0x4b,0x7b,0x44,0x03,0xf1,0x10,0x0e,0x18,0x68,0x08,
0x33,0x53,0xf8,0x04,0x1c,0x73,0x45,0x14,0x46,0x03,0xc4,
0x22,0x46,0xf6,0xd1,0x3a,0x46,0x00,0x23,0x01,0x20,0x03,
0xf0,0x03,0x01,0x02,0x29,0x09,0xd0,0x03,0x29,0x0a,0xd0,
0x01,0x29,0x02,0xd0,0x14,0x78,0xf1,0x5c,0x08,0xe0,0x11,
0x78,0x01,0x31,0x04,0xe0,0x11,0x78,0x02,0x31,0x01,0xe0,
0x11,0x78,0x03,0x31,0xf4,0x5c,0x01,0x33,0xa1,0x42,0x18,
0xbf,0x00,0x20,0x10,0x2b,0x02,0xf1,0x01,0x02,0xe3,0xd1,
0x05,0x9a,0x2b,0x68,0x9a,0x42,0x01,0xd0,0xff,0xf7,0x0a,
0xef,0x07,0xb0,0xf0,0xbd])
[0x0000863c]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;了解capstone中对arm指令进行操作的函数-接口&#34;&gt;了解capstone中对arm指令进行操作的函数 &lt;code&gt;接口&lt;/code&gt;&lt;/h3&gt;

&lt;h4 id=&#34;从源代码中提供的-example-来初步了解capstone提供给我们的可用的-接口-的使用&#34;&gt;从源代码中提供的&lt;code&gt;example&lt;/code&gt;, 来初步了解capstone提供给我们的可用的&lt;code&gt;接口&lt;/code&gt;的使用&lt;/h4&gt;

&lt;p&gt;我们参考的主要是 &lt;code&gt;/bindings/python/test_arm.py&lt;/code&gt; 和 &lt;code&gt;/bindings/python/test_detail.py&lt;/code&gt;这两个文件:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;test_arm.py   &lt;code&gt;源代码过多, 这里就不全部都放上来了&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python

# Capstone Python bindings, by Nguyen Anh Quynnh &amp;lt;aquynh@gmail.com&amp;gt;

from __future__ import print_function
from capstone import *
from capstone.arm import *
from xprint import to_hex, to_x, to_x_32

ARM_CODE = b&amp;quot;\xED\xFF\xFF\xEB\x04\xe0\x2d\xe5\x00\x00\x00\x00\xe0\x83\x22\xe5\xf1\x02\x03\x0e\x00\x00\xa0\xe3\x02\x30\xc1\xe7\x00\x00\x53\xe3\x00\x02\x01\xf1\x05\x40\xd0\xe8\xf4\x80\x00\x00&amp;quot;
THUMB_CODE = b&amp;quot;\x70\x47\x00\xf0\x10\xe8\xeb\x46\x83\xb0\xc9\x68\x1f\xb1\x30\xbf\xaf\xf3\x20\x84&amp;quot;

all_tests = (
        (CS_ARCH_ARM, CS_MODE_ARM, ARM_CODE, &amp;quot;ARM&amp;quot;, None),
        (CS_ARCH_ARM, CS_MODE_THUMB, THUMB_CODE, &amp;quot;Thumb&amp;quot;, None),
        )

def print_insn_detail(insn):
    # print address, mnemonic and operands
    print(&amp;quot;0x%x:\t%s\t%s&amp;quot; % (insn.address, insn.mnemonic, insn.op_str))

    # &amp;quot;data&amp;quot; instruction generated by SKIPDATA option has no detail
    if insn.id == 0:
        return

    if len(insn.operands) &amp;gt; 0:
        print(&amp;quot;\top_count: %u&amp;quot; % len(insn.operands))
        c = 0
        for i in insn.operands:
            if i.type == ARM_OP_REG:
                print(&amp;quot;\t\toperands[%u].type: REG = %s&amp;quot; % (c, insn.reg_name(i.reg)))
            if i.type == ARM_OP_IMM:
                print(&amp;quot;\t\toperands[%u].type: IMM = 0x%s&amp;quot; % (c, to_x_32(i.imm)))
...............................
            if i.type == ARM_OP_MEM:
                print(&amp;quot;\t\toperands[%u].type: MEM&amp;quot; % c)
                if i.mem.base != 0:
                    print(&amp;quot;\t\t\toperands[%u].mem.base: REG = %s&amp;quot; \
                        % (c, insn.reg_name(i.mem.base)))
                if i.mem.index != 0:
                    print(&amp;quot;\t\t\toperands[%u].mem.index: REG = %s&amp;quot; \
                        % (c, insn.reg_name(i.mem.index)))
                if i.mem.scale != 1:
                    print(&amp;quot;\t\t\toperands[%u].mem.scale: %u&amp;quot; \
                        % (c, i.mem.scale))
                if i.mem.disp != 0:
                    print(&amp;quot;\t\t\toperands[%u].mem.disp: 0x%s&amp;quot; \
                        % (c, to_x_32(i.mem.disp)))
...............................
            c += 1

    if insn.update_flags:
        print(&amp;quot;\tUpdate-flags: True&amp;quot;)
    if insn.writeback:
        print(&amp;quot;\tWrite-back: True&amp;quot;)
    if not insn.cc in [ARM_CC_AL, ARM_CC_INVALID]:
        print(&amp;quot;\tCode condition: %u&amp;quot; % insn.cc)
...............................

### Test class Cs
def test_class():

    for (arch, mode, code, comment, syntax) in all_tests:
        print(&amp;quot;*&amp;quot; * 16)
        print(&amp;quot;Platform: %s&amp;quot; % comment)
        print(&amp;quot;Code: %s&amp;quot; % to_hex(code))
        print(&amp;quot;Disasm:&amp;quot;)

        try:
            md = Cs(arch, mode)
            if syntax:
                md.syntax = syntax
            md.detail = True
            for insn in md.disasm(code, 0x80001000):
                print_insn_detail(insn)
                print ()
            print (&amp;quot;0x%x:\n&amp;quot; % (insn.address + insn.size))
        except CsError as e:
            print(&amp;quot;ERROR: %s&amp;quot; % e)


if __name__ == &#39;__main__&#39;:
    test_class()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;观察&lt;code&gt;test_arm.py&lt;/code&gt;, 我们可以看到的重要的一些操作有:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;md = Cs(arch, mode)
for insn in md.disasm(code, 0x80001000):
    print_insn_detail(insn)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先通过&lt;code&gt;md = Cs(arch, mode)&lt;/code&gt;来选择我们的架构, 然后调用&lt;code&gt;md.disasm&lt;/code&gt;返回 指令(insn) (这里Cs.disasm就是一个生成器, 参看py语法)
然后打印&lt;code&gt;insn&lt;/code&gt;的细节(助记符, 操作数, 以及每个操作数的类型等)&lt;/p&gt;

&lt;p&gt;打印的时候(这里我只列举了部分操作):
- 我们可以发现 &lt;strong&gt;针对指令&lt;/strong&gt; 调用了 &lt;strong&gt;insn.address&lt;/strong&gt;, &lt;strong&gt;insn.mnemonic&lt;/strong&gt;,  &lt;strong&gt;insn.op_str&lt;/strong&gt;, &lt;strong&gt;insn.operands&lt;/strong&gt;, &lt;strong&gt;insn.update_flags&lt;/strong&gt;, &lt;strong&gt;insn.cc&lt;/strong&gt;&amp;hellip;..
- 针对 &lt;strong&gt;操作数&lt;/strong&gt; 调用了 &lt;strong&gt;i.type&lt;/strong&gt;, &lt;strong&gt;i.reg&lt;/strong&gt;, &lt;strong&gt;i.mem&lt;/strong&gt;&amp;hellip;.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;test_detail.py (省略了一些和上面test_arm.py相似的代码)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;..........
def print_detail(insn):
    print(&amp;quot;0x%x:\t%s\t%s  // insn-ID: %u, insn-mnem: %s&amp;quot; \
        % (insn.address, insn.mnemonic, insn.op_str, insn.id, \
        insn.insn_name()))

    # &amp;quot;data&amp;quot; instruction generated by SKIPDATA option has no detail
    if insn.id == 0:
        return

    if len(insn.regs_read) &amp;gt; 0:
        print(&amp;quot;\tImplicit registers read: &amp;quot;, end=&#39;&#39;),
        for m in insn.regs_read:
            print(&amp;quot;%s &amp;quot; % insn.reg_name(m), end=&#39;&#39;),
        print()

    if len(insn.regs_write) &amp;gt; 0:
        print(&amp;quot;\tImplicit registers modified: &amp;quot;, end=&#39;&#39;),
        for m in insn.regs_write:
            print(&amp;quot;%s &amp;quot; % insn.reg_name(m), end=&#39;&#39;),
        print()

    if len(insn.groups) &amp;gt; 0:
        print(&amp;quot;\tThis instruction belongs to groups: &amp;quot;, end=&#39;&#39;),
        for m in insn.groups:
            print(&amp;quot;%s &amp;quot; % insn.group_name(m), end=&#39;&#39;),
        print()``
        ....................................

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;操作很明显:
&lt;strong&gt;insn.regs_read&lt;/strong&gt;, &lt;strong&gt;insn.regs_write&lt;/strong&gt;, &lt;strong&gt;insn.groups&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&#34;观察源代码中的-bindings-python-capstone-init-py-来了解-cs-和-csinsn-的实现&#34;&gt;观察源代码中的&lt;code&gt;/bindings/python/capstone/__init__.py&lt;/code&gt;来了解&lt;strong&gt;CS&lt;/strong&gt; 和 &lt;strong&gt;CsInsn&lt;/strong&gt; 的实现:&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Cs(object):
    def __init__(self, arch, mode):
        ....
        ....省略


    # Disassemble binary &amp;amp; return disassembled instructions in CsInsn objects   反汇编二进制代码&amp;amp;&amp;amp; 返回反汇编的指令in CsInsn对象中
    def disasm(self, code, offset, count=0):
        all_insn = ctypes.POINTER(_cs_insn)()
        &#39;&#39;&#39;if not _python2:
            print(code)
            code = code.encode()
            print(code)&#39;&#39;&#39;
        # Hack, unicorn&#39;s memory accessors give you back bytearrays, but they
        # cause TypeErrors when you hand them into Capstone.
        if isinstance(code, bytearray):
            code = bytes(code)
        res = _cs.cs_disasm(self.csh, code, len(code), offset, count, ctypes.byref(all_insn))*************
        if res &amp;gt; 0:
            try:
                for i in range(res):
                    yield CsInsn(self, all_insn[i])         ## all_info*********************************** 重点操作
            finally:
                _cs.cs_free(all_insn, res)
        else:
            status = _cs.cs_errno(self.csh)
            if status != CS_ERR_OK:
                raise CsError(status)
            return
            yield
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过观察&lt;strong&gt;Cs&lt;/strong&gt;这个类的实现, 我们发现了它是一个生成器, 一直返回&lt;strong&gt;CsInsn&lt;/strong&gt; 这个类的对象, 现在我们来看一下CsInsn 这个类的实现(从名字可以就可以看出来, 它保存了我们每条指令的性质)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;▼ CsInsn : class
   +__init__ : function
   +id : function           @property
   +address : function      @property // 返回 指令的地址
   +size : function         @property // 返回 大小
   +bytes : function        @property // 返回 字节码 []
   +mnemonic : function     @property // 返回 指令名称(助记符)
   +op_str : function       @property // 返回 操作string
   +regs_read : function    @property // 返回 会被*隐式*读的寄存器[]
   +regs_write : function   @property // 返回 会被*隐式*写的寄存器[]
   +groups : function       @property // 指令的group
   -__gen_detail : function
   -__getattr__ : function
   +errno : function
   +reg_name : function   (self, reg_id)  // 返回寄存器的名称
   +insn_name : function                  // 返回指令名称, 不同于mnemonic
   +group_name : function
   +group : function
   +reg_read : function   (self, reg_id)  // 识别该寄存器会被隐式read
   +reg_write : function  (self, reg_id)  // 识别该寄存器是否会被隐式 write
   +op_count : function
   +op_find : function
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我罗列了一下它的所有操作,  我们下面写代码的时候会用到.&lt;/p&gt;

&lt;h4 id=&#34;这里我们先简单写一个-py-来对上面的部分函数进行应用&#34;&gt;这里我们先简单写一个.py, 来对上面的部分函数进行应用&lt;/h4&gt;

&lt;p&gt;我们可以先看一下输出结果:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;l0phtg@l0phtg-PC:~/blogTest$ python test.py 
0x1000: push    {r4, r6, r7, lr}
id:426  groups:[150, 151]   size:2  
bytes:  0xd0 0xb5 
    op_count: 4
        operands[0].type: REG = r4
        operands[1].type: REG = r6
        operands[2].type: REG = r7
        operands[3].type: REG = lr

0x1002: pop {r4, r6, r7, pc}
id:425  groups:[150, 151]   size:2  
bytes:  0xd0 0xbd 
    op_count: 4
        operands[0].type: REG = r4
        operands[1].type: REG = r6
        operands[2].type: REG = r7
        operands[3].type: REG = pc

0x1004: beq #0x100e
id:17   groups:[150, 151, 1]    size:2  
bytes:  0x3 0xd0 
    op_count: 1
        operands[0].type: IMM = 0x100e

0x1006: movs    r0, #0
id:80   groups:[150, 151]   size:2  
bytes:  0x0 0x20 
    op_count: 2
        operands[0].type: REG = r0
        operands[1].type: IMM = 0x0
    Update-flags: True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每条指令的指令名称, 指令操作数, 操作数类型, 该指令是否更新flag都显示了出来.&lt;/p&gt;

&lt;p&gt;下面的代码(参考test_arm.py的实现)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python2
#-*- coding:utf-8 -*-

import sys
from capstone import *
from capstone.arm import *
from xprint import to_hex, to_x, to_x_32

my_thumb_code = b&amp;quot;\xd0\xb5\xd0\xbd\x03\xd0\x00\x20&amp;quot;


def print_insn_detail(insn):
    print(&amp;quot;0x%x:\t%s\t%s&amp;quot; % (insn.address, insn.mnemonic, insn.op_str))
    print(&amp;quot;id:%d\tgroups:%s\tsize:%x\t&amp;quot; % (insn.id, insn.groups, insn.size))
    sys.stdout.write(&#39;bytes:\t&#39;)
    for i in insn.bytes:
        sys.stdout.write(&amp;quot;%s &amp;quot; % hex(i))
    sys.stdout.write(&#39;\n&#39;)

    if len(insn.operands) &amp;gt; 0:
        print(&amp;quot;\top_count: %u&amp;quot; % len(insn.operands))
        c = 0
        for i in insn.operands:
            if i.type == ARM_OP_REG:
                print(&amp;quot;\t\toperands[%u].type: REG = %s&amp;quot; % (c, insn.reg_name(i.reg)))
            if i.type == ARM_OP_IMM:
                print(&amp;quot;\t\toperands[%u].type: IMM = 0x%s&amp;quot; % (c, to_x_32(i.imm)))
            if i.type == ARM_OP_PIMM:
                print(&amp;quot;\t\toperands[%u].type: P-IMM = %u&amp;quot; % (c, i.imm))
            if i.type == ARM_OP_CIMM:
                print(&amp;quot;\t\toperands[%u].type: C-IMM = %u&amp;quot; % (c, i.imm))
            if i.type == ARM_OP_FP:
                print(&amp;quot;\t\toperands[%u].type: FP = %f&amp;quot; % (c, i.fp))
            if i.type == ARM_OP_SYSREG:
                print(&amp;quot;\t\toperands[%u].type: SYSREG = %u&amp;quot; % (c, i.reg))
            if i.type == ARM_OP_SETEND:
                if i.setend == ARM_SETEND_BE:
                    print(&amp;quot;\t\toperands[%u].type: SETEND = be&amp;quot; % c)
                else:
                    print(&amp;quot;\t\toperands[%u].type: SETEND = le&amp;quot; % c)
            if i.type == ARM_OP_MEM:
                print(&amp;quot;\t\toperands[%u].type: MEM&amp;quot; % c)
                if i.mem.base != 0:
                    print(&amp;quot;\t\t\toperands[%u].mem.base: REG = %s&amp;quot; \
                        % (c, insn.reg_name(i.mem.base)))
                if i.mem.index != 0:
                    print(&amp;quot;\t\t\toperands[%u].mem.index: REG = %s&amp;quot; \
                        % (c, insn.reg_name(i.mem.index)))
                if i.mem.scale != 1:
                    print(&amp;quot;\t\t\toperands[%u].mem.scale: %u&amp;quot; \
                        % (c, i.mem.scale))
                if i.mem.disp != 0:
                    print(&amp;quot;\t\t\toperands[%u].mem.disp: 0x%s&amp;quot; \
                        % (c, to_x_32(i.mem.disp)))

            if i.shift.type != ARM_SFT_INVALID and i.shift.value:
                print(&amp;quot;\t\t\tShift: %u = %u&amp;quot; \
                    % (i.shift.type, i.shift.value))
            if i.vector_index != -1:
                print(&amp;quot;\t\t\toperands[%u].vector_index = %u&amp;quot; %(c, i.vector_index))
            if i.subtracted:
                print(&amp;quot;\t\t\toperands[%u].subtracted = True&amp;quot; %c)

            c += 1

    if insn.update_flags:
        print(&amp;quot;\tUpdate-flags: True&amp;quot;)

def test_class():

    md = Cs(CS_ARCH_ARM, CS_MODE_THUMB)
    md.detail=True
    for insn in md.disasm(my_thumb_code, 0x1000):
        print_insn_detail(insn)
        sys.stdout.write(&#39;\n&#39;)

if __name__ == &#39;__main__&#39;:
    test_class()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;了解-thumb-的指令编码&#34;&gt;了解 thumb 的指令编码:&lt;/h3&gt;

&lt;p&gt;在前面环境搭建的时候, 我向大家推荐了arm的一个文档, 本节主要针对该文档进行分析.&lt;/p&gt;

&lt;p&gt;首先定位到第&lt;code&gt;F3&lt;/code&gt;章节, 观看目录:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Chapter F3

T32 Base Instruction Set Encoding

This chapter introduces the T32 instruction set and describes how it uses the ARM programmers’ model. It contains

the following sections:


• T32 instruction set encoding on page F3-2432.

• 16-bit T32 instruction encoding on page F3-2435.

• 32-bit T32 instruction encoding on page F3-2442.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们在此分析的是&lt;strong&gt;16-bit T32 instruction&lt;/strong&gt;, 再次定位到&lt;code&gt;F3-2435&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/thumb-vmp/thumb16.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>elf文件格式和AndroidLinker加载.so的源码分析</title>
      <link>https://l0phtg.github.io/post/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%92%8Candroidlinker%E5%8A%A0%E8%BD%BD-so%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Sun, 19 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://l0phtg.github.io/post/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%92%8Candroidlinker%E5%8A%A0%E8%BD%BD-so%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      
        <description>&lt;p&gt;最近在学习android应用的加壳和混淆方法, 所以遇到了一些有关.so是如何加载到android中去的问题, 看了一些视频和文章, 所以想在此总结一下.&lt;/p&gt;

&lt;p&gt;本文主要内容:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;elf的文件格式&lt;/li&gt;
&lt;li&gt;分析linker的源码, 主要dlopen流程.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;elf文件格式&#34;&gt;elf文件格式&lt;/h2&gt;

&lt;p&gt;本文只对elf文件格式进行简单的分析, 如果要进行深入的了解, 推荐&lt;code&gt;&amp;lt;&amp;lt;程序员的自我修养&amp;gt;&amp;gt;&lt;/code&gt;中第3章.&lt;/p&gt;

&lt;p&gt;/usr/includ/elf.h中定义了elf文件头结构和相关的常数.&lt;/p&gt;

&lt;p&gt;分析elf文件时, 建议使用&lt;code&gt;010 editor&lt;/code&gt;这款十六进制编辑软件, 运行elf模板后可以清晰的将文件格式显示出来, 大致的显示是(坑, 此处应该用图片的)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;                NAME                           Value            Start       Size        Color       Comment
    struct file                                                 0h          109Ch
        struct elf_header                                       0h          34h
        struct program_header_table                             34h         120h
        struct section_header_table                             1B274h      460h
        struct dynamic_symbol_table                             18Ch        F10h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到, 一个elf文件中包含一个header, 3个table, 我们一个一个的来分析一下.
首先分析&lt;code&gt;Elf header&lt;/code&gt;, 它位于每一个elf文件开始的地方:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct                                                            typedef struct
{                                                                         {
    unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */     unsigned char e_ident[EI_NIDENT];
    Elf32_Half    e_type;         /* Object file type */                    Elf64_Half    e_type;     
    Elf32_Half    e_machine;      /* Architecture */                        Elf64_Half    e_machine;  
    Elf32_Word    e_version;      /* Object file version */                 Elf64_Word    e_version;  
    Elf32_Addr    e_entry;        /* Entry point virtual address */         Elf64_Addr    e_entry;    
    Elf32_Off e_phoff;        /* Program header table file offset */        Elf64_Off e_phoff;        
    Elf32_Off e_shoff;        /* Section header table file offset */        Elf64_Off e_shoff;        
    Elf32_Word    e_flags;        /* Processor-specific flags */            Elf64_Word    e_flags;    
    Elf32_Half    e_ehsize;       /* ELF header size in bytes */            Elf64_Half    e_ehsize;   
    Elf32_Half    e_phentsize;        /* Program header table entry size */ Elf64_Half    e_phentsize;
    Elf32_Half    e_phnum;        /* Program header table entry count */    Elf64_Half    e_phnum;    
    Elf32_Half    e_shentsize;        /* Section header table entry size */ Elf64_Half    e_shentsize;
    Elf32_Half    e_shnum;        /* Section header table entry count */    Elf64_Half    e_shnum;    
    Elf32_Half    e_shstrndx;     /* Section header string table index */   Elf64_Half    e_shstrndx; 
} Elf32_Ehdr;                                                              } Elf64_Ehdr;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到, header中包含了magic number, 文件类型, 目标文件版本, 入口地址(如果为0, 说明此文件为可重定位文件), program header的开始地址(即为在so文件中的offset), section header的开始地址, 标志位, elf头本身的大小, program header和section header的size和数量, 最后是section header中string section在section中的下标.(用010 editor可以看到清楚的看到一个.so文件包含众多的program header 和 section header, 这两个段在做.so混淆时会经常分析)&lt;/p&gt;

&lt;p&gt;现在分析&lt;code&gt;program header&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* Program segment header.  */

typedef struct                                                      typedef struct
{                                                                   {
    Elf32_Word    p_type;         /* Segment type */                    Elf64_Word    p_type;   
    Elf32_Off p_offset;       /* Segment file offset */                 Elf64_Off p_offset;     
    Elf32_Addr    p_vaddr;        /* Segment virtual address */         Elf64_Addr    p_vaddr;  
    Elf32_Addr    p_paddr;        /* Segment physical address */        Elf64_Addr    p_paddr;  
    Elf32_Word    p_filesz;       /* Segment size in file */            Elf64_Word    p_filesz; 
    Elf32_Word    p_memsz;        /* Segment size in memory */          Elf64_Word    p_memsz;  
    Elf32_Word    p_flags;        /* Segment flags */                   Elf64_Word    p_flags;  
    Elf32_Word    p_align;        /* Segment alignment */               Elf64_Word    p_align;  
} Elf32_Phdr;                                                       } Elf64_Phdr;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来分析&lt;code&gt;section header&lt;/code&gt;, section相信了解过汇编的同学都非常熟悉了, 这个section header里面就存放了我们elf中各个段的信息.
看一下section header段描述符的结构:(64位的与32位的结构体大致相同, 只是把类型改为了Elf64的类型)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct
{
    Elf32_Word    sh_name;        /* Section name (string tbl index) 段名*/
    Elf32_Word    sh_type;        /* Section type 段类型*/
    Elf32_Word    sh_flags;       /* Section flags 标志位*/
    Elf32_Addr    sh_addr;        /* Section virtual addr at execution 段虚拟地址*/
    Elf32_Off sh_offset;          /* Section file offset 段偏移*/
    Elf32_Word    sh_size;        /* Section size in bytes 段的长度*/
    Elf32_Word    sh_link;        /* Link to another section 段的链接信息*/
    Elf32_Word    sh_info;        /* Additional section information 段链接的相关信息*/
    Elf32_Word    sh_addralign;   /* Section alignment 段地址对齐*/
    Elf32_Word    sh_entsize;     /* Entry size if section holds table 项的长度*/
} Elf32_Shdr;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后分析动态符号表(&lt;code&gt;symbol table&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct
{
    Elf32_Word    st_name;        /* Symbol name (string tbl index) */
    Elf32_Addr    st_value;       /* Symbol value */
    Elf32_Word    st_size;        /* Symbol size */
    unsigned char st_info;        /* Symbol type and binding */
    unsigned char st_other;       /* Symbol visibility */
    Elf32_Section st_shndx;       /* Section index */
} Elf32_Sym;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;包含的信息有符号名, 符号相对应的值, 符号大小, 符号类型和绑定信息, 符号所在的段.&lt;/p&gt;

&lt;h2 id=&#34;android-linker加载-so的源码分析&#34;&gt;Android Linker加载.so的源码分析&lt;/h2&gt;

&lt;p&gt;Android中的本地文件.so是通过Linker加载到内存中去并且执行的.(本文分析的源码为Android4.4.4)
                &amp;mdash;- 推荐一款好用的源码阅读工具 source Insight&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;java层:  System.LoadLibrary(&amp;quot;function&amp;quot;);
native:         ---&amp;gt;  Dalvik/vm/native/java_lang_Runtime.cpp: Dalvik_java_lang_Runtime_nativeLoad 
                        ---&amp;gt;Dalvik/vm/Native.cpp: dvmLoadNativeCode(const char* fileName, Object* ClassLoader, char** reason)
                                ---&amp;gt;bionic/linker/dlfcn.c: dlopen(const char* pathName, RTLD_LAZY)
                                        ---&amp;gt;bionic/linker/linker.cpp: do_dlopen(const char* name, int flags)
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;核心函数为&lt;code&gt;do_dlopen&lt;/code&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;soinfo* do_dlopen(const char* name, int flags) {  // 函数的参数为
    if ((flags &amp;amp; ~(RTLD_NOW|RTLD_LAZY|RTLD_LOCAL|RTLD_GLOBAL)) != 0) {
        DL_ERR(&amp;quot;invalid flags to dlopen: %x&amp;quot;, flags);
        return NULL;
    }
    set_soinfo_pool_protection(PROT_READ | PROT_WRITE); // 设置so信息池的访问权限为可读可写
    soinfo* si = find_library(name);                    // 找到name函数, 装载so, 并返回指向.soinfo的指针
    if (si != NULL) {
                      si-&amp;gt;CallConstructors();           // 初始化so库
    }
    set_soinfo_pool_protection(PROT_READ);              // 设置so信息池的访问权限为只读
    return si;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;查看&lt;code&gt;find_library&lt;/code&gt;函数可以发现它调用了&lt;code&gt;find_library_internal&lt;/code&gt;函数,&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;static soinfo* find_library(const char* name) {
    soinfo* si = find_library_internal(name);
    if (si != NULL) {
        si-&amp;gt;ref_count++;
    }
    return si;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分析&lt;code&gt;find_library_internal&lt;/code&gt;函数, 发现其主要调用了&lt;code&gt;load_library()&lt;/code&gt;函数和 &lt;code&gt;soinfo_link_image()&lt;/code&gt; 函数.
_&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;static soinfo* find_library_internal(const char* name) {
    if (name == NULL) {
        return somain;
    }
    soinfo* si = find_loaded_library(name);         // 判断.so是否完全加载, 如果加载: 返回有效的指针;如果没有加载, 返回null;
    if (si != NULL) {                               // 如果已经加载，返回
        if (si-&amp;gt;flags &amp;amp; FLAG_LINKED) {
            return si;
        }
        DL_ERR(&amp;quot;OOPS: recursive link to \&amp;quot;%s\&amp;quot;&amp;quot;, si-&amp;gt;name);
        return NULL;
    }

    TRACE(&amp;quot;[ &#39;%s&#39; has not been loaded yet.  Locating...]&amp;quot;, name);  // 打印so还没有加载
    si = load_library(name);        // 加载.so
    if (si == NULL) {
        return NULL;
    }
    // At this point we know that whatever is loaded @ base is a valid ELF
    // shared library whose segments are properly mapped in.
    TRACE(&amp;quot;[ init_library base=0x%08x sz=0x%08x name=&#39;%s&#39; ]&amp;quot;,
            si-&amp;gt;base, si-&amp;gt;size, si-&amp;gt;name);

    if (!soinfo_link_image(si)) {       // 完成.so的重定位
        munmap(reinterpret_cast&amp;lt;void*&amp;gt;(si-&amp;gt;base), si-&amp;gt;size);
        soinfo_free(si);
        return NULL;
    }
    return si;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分析&lt;code&gt;load_library&lt;/code&gt;函数, 会找到elf_read.&lt;code&gt;Load()&lt;/code&gt;方法, 这个方法就是load&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;static soinfo* load_library(const char* name) {
// Open the file.
    int fd = open_library(name);                        // 打开文件, 获取fd
    if (fd == -1) {
        DL_ERR(&amp;quot;library \&amp;quot;%s\&amp;quot; not found&amp;quot;, name);
        return NULL;
    }

    // Read the ELF header and load the segments.
    ElfReader elf_reader(name, fd);                     // 初始化elfReader对象
    if (!elf_reader.Load()) {                           // 通过elfReader对象的Load()方法, 将so文件装载到内存
        return NULL;
    }

    const char* bname = strrchr(name, &#39;/&#39;);
    soinfo* si = soinfo_alloc(bname ? bname + 1 : name);    // 分配so_info结构, 并按照装载结果更新相应的成员变量
    if (si == NULL) {
        return NULL;
    }
    si-&amp;gt;base = elf_reader.load_start();
    si-&amp;gt;size = elf_reader.load_size();
    si-&amp;gt;load_bias = elf_reader.load_bias();
    si-&amp;gt;flags = 0;
    si-&amp;gt;entry = 0;
    si-&amp;gt;dynamic = NULL;
    si-&amp;gt;phnum = elf_reader.phdr_count();
    si-&amp;gt;phdr = elf_reader.loaded_phdr();

    return si;
}

这里放一个ElfReader结构:
class ElfReader {
public:
    ElfReader(const char* name, int fd);
    ~ElfReader();

    bool Load();

    size_t phdr_count() { return phdr_num_; }
    Elf32_Addr load_start() { return reinterpret_cast&amp;lt;Elf32_Addr&amp;gt;(load_start_); }
    Elf32_Addr load_size() { return load_size_; }
    Elf32_Addr load_bias() { return load_bias_; }
    const Elf32_Phdr* loaded_phdr() { return loaded_phdr_; }

private:
    bool ReadElfHeader();
    bool VerifyElfHeader();
    bool ReadProgramHeader();
    bool ReserveAddressSpace();
    bool LoadSegments();
    bool FindPhdr();
    bool CheckPhdr(Elf32_Addr); 

    const char* name_;
    int fd_;    

    Elf32_Ehdr header_;
    size_t phdr_num_;   

    void* phdr_mmap_;
    Elf32_Phdr* phdr_table_;
    Elf32_Addr phdr_size_;  

    // First page of reserved address space.
    void* load_start_;
    // Size in bytes of reserved address space.
    Elf32_Addr load_size_;
    // Load bias.
    Elf32_Addr load_bias_;

    // Loaded phdr.
    const Elf32_Phdr* loaded_phdr_;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里是&lt;code&gt;Load()&lt;/code&gt;函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool ElfReader::Load() {
    return ReadElfHeader() &amp;amp;&amp;amp;                   // 读取
        VerifyElfHeader() &amp;amp;&amp;amp;                // 验证
        ReadProgramHeader() &amp;amp;&amp;amp;              // 读取Program header
        ReserveAddressSpace() &amp;amp;&amp;amp;            // 根据Program header计算so需要的内存size并分配相应的空间
        LoadSegments() &amp;amp;&amp;amp;                   // 将so按照segment为单位装载到内存
        FindPhdr();                     // on 装载到内存的so中找到program header, 方便以后链接过程use
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;首先是&lt;code&gt;ReadElfHeader&lt;/code&gt;()函数, 发现其是直接调用&lt;code&gt;read&lt;/code&gt;函数读取到header中的.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool ElfReader::ReadElfHeader() {
    ssize_t rc = TEMP_FAILURE_RETRY(read(fd_, &amp;amp;header_, sizeof(header_)));  // use read() function 直接将elfheader读取到header中
    ```//////////////////////////////
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;然后是&lt;code&gt;VerifyElfread&lt;/code&gt;()函数, 对Elfheader进行验证识别: 是否为32位，大小端，类型和版本.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;之后&lt;code&gt;ReadProgramHeader&lt;/code&gt;()函数(加载program header table从elf文件到一个只读的私有匿名的mmap-ed block中):&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool ElfReader::ReadProgramHeader() {
    phdr_num_ = header_.e_phnum;                                        
    //  将program header on内存中中单独映射一份, use于解析时临时use, on so装载到内存后, 便会释放这块内存, 转而使use装载后的so中的program header

    // Like the kernel, we only accept program header tables that
    // are smaller than 64KiB.
    if (phdr_num_ &amp;lt; 1 || phdr_num_ &amp;gt; 65536/sizeof(Elf32_Phdr)) {
        DL_ERR(&amp;quot;\&amp;quot;%s\&amp;quot; has invalid e_phnum: %d&amp;quot;, name_, phdr_num_);
        return false;
    }

    Elf32_Addr page_min = PAGE_START(header_.e_phoff);
    Elf32_Addr page_max = PAGE_END(header_.e_phoff + (phdr_num_ * sizeof(Elf32_Phdr)));
    Elf32_Addr page_offset = PAGE_OFFSET(header_.e_phoff);  

    phdr_size_ = page_max - page_min;

    void* mmap_result = mmap(NULL, phdr_size_, PROT_READ, MAP_PRIVATE, fd_, page_min);
        if (mmap_result == MAP_FAILED) {
        DL_ERR(&amp;quot;\&amp;quot;%s\&amp;quot; phdr mmap failed: %s&amp;quot;, name_, strerror(errno));
        return false;
    }

    phdr_mmap_ = mmap_result;
    phdr_table_ = reinterpret_cast&amp;lt;Elf32_Phdr*&amp;gt;(reinterpret_cast&amp;lt;char*&amp;gt;(mmap_result) + page_offset);
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ReverveAddressSpace&lt;/code&gt;()函数(准备虚拟内存足够的大来存放Program header中的&lt;code&gt;Load&lt;/code&gt;段(两个Load段～～) 通过&lt;code&gt;mmap with PROT_NONE&lt;/code&gt; 实现&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool ElfReader::ReserveAddressSpace() {
    Elf32_Addr min_vaddr;
    load_size_ = phdr_table_get_load_size(phdr_table_, phdr_num_, &amp;amp;min_vaddr);  // 获取so on 内存中需要的空间load_size
    if (load_size_ == 0) {
          DL_ERR(&amp;quot;\&amp;quot;%s\&amp;quot; has no loadable segments&amp;quot;, name_);
              return false;
    }

    uint8_t* addr = reinterpret_cast&amp;lt;uint8_t*&amp;gt;(min_vaddr);
    void* start = mmap(addr, load_size_, PROT_NONE, mmap_flags, -1, 0);         // use mmap匿名映射, 预留出相应的空间
    int mmap_flags = MAP_PRIVATE | MAP_ANONYMOUS;
    if (start == MAP_FAILED) {
        DL_ERR(&amp;quot;couldn&#39;t reserve %d bytes of address space for \&amp;quot;%s\&amp;quot;&amp;quot;, load_size_, name_);
        return false;
    }

    load_start_ = start;
    load_bias_ = reinterpret_cast&amp;lt;uint8_t*&amp;gt;(start) - addr;              // so可以指定加载的基址, 但是so指定的加载基址可能不是页对齐的, 这种情况
    return true;                                                            // 会导致实际映射地址和指定的加载地址有一个偏差, 这个偏差便是load_bias
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;LoadSegments&lt;/code&gt;()函数(在进程地址空间中加载所有可加载的段(假设你已经预留了空间为这个library)):&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool ElfReader::LoadSegments() {    
    for (size_t i = 0; i &amp;lt; phdr_num_; ++i) {
    const Elf32_Phdr* phdr = &amp;amp;phdr_table_[i];   // 遍历program header table

    if (phdr-&amp;gt;p_type != PT_LOAD) {          // 加载所有p_type == PT_LOAD的段
        continue;
    }

    ``` 之后就是一些设置段地址，段偏移, 之后mmap的一些操作

    return true;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FindPhdr&lt;/code&gt;()(返回program header table加载到内存中的地址, 因为之后还要执行.so的重定位).
现在回到我们&lt;code&gt;find_library_internal&lt;/code&gt;()这里，在执行完load_library()之后, 还有一个重要的函数为 &lt;code&gt;soinfo_link_image&lt;/code&gt;(soinfo* si):&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;这个函数会完成.so的动态链接，其中包含我们加载的.so库的重定位过程:
 1. 定位动态section,将动态section的虚拟地址和项数和读写权限存在dynamic, dynamic_count, dynamic_flags中.
    size_t dynamic_count;
    Elf32_Word dynamic_flags;
    phdr_table_get_dynamic_section(phdr, phnum, base, &amp;amp;si-&amp;gt;dynamic,     // 定位dynamic section
                                       &amp;amp;dynamic_count, &amp;amp;dynamic_flags);     // 

 2. 解析Dynamic section
 3. 调用find_library, 返回所有依赖的.so的soinfo指针并存放在数组中.
 4. 重定位(处理plt_rel(延迟绑定)和rel):
    可以看到, 处理两个重定位表的函数都是soinfo_relocate函数.
    if (si-&amp;gt;plt_rel != NULL) {
        DEBUG(&amp;quot;[ relocating %s plt ]&amp;quot;, si-&amp;gt;name );
        if (soinfo_relocate(si, si-&amp;gt;plt_rel, si-&amp;gt;plt_rel_count, needed)) {
            return false;
        }
    }
    if (si-&amp;gt;rel != NULL) {
        DEBUG(&amp;quot;[ relocating %s ]&amp;quot;, si-&amp;gt;name );
        if (soinfo_relocate(si, si-&amp;gt;rel, si-&amp;gt;rel_count, needed)) {       
            return false;
        }
    }       
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在分析soinfo_relocate函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;







&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
  </channel>
</rss>