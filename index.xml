<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>L0phTg&#39;s Blog</title>
    <link>https://l0phtg.github.io/</link>
    <description>Recent content on L0phTg&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>l0phtg</copyright>
    <lastBuildDate>Mon, 20 Aug 2018 21:38:52 +0800</lastBuildDate>
    
        <atom:link href="https://l0phtg.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://l0phtg.github.io/about/</link>
      <pubDate>Mon, 20 Aug 2018 21:38:52 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/about/</guid>
      
        <description>&lt;p&gt;某邮电大学大四学生.&lt;/p&gt;

&lt;p&gt;like: c/c++, 操作系统, 编译原理.&lt;/p&gt;

&lt;p&gt;从事方向: 移动安全.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Kaleidoscope: Code Generation to LLVM IR</title>
      <link>https://l0phtg.github.io/post/llvm/kaleidoscope-code-generation-to-llvm-ir/</link>
      <pubDate>Fri, 12 Apr 2019 16:55:05 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/llvm/kaleidoscope-code-generation-to-llvm-ir/</guid>
      
        <description>&lt;p&gt;translate from: &lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl03.html&#34;&gt;http://llvm.org/docs/tutorial/LangImpl03.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;介绍四个基本表达式和函数申明与定义的Codegen.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/docs-pic/llvm/Codegen.png&#34; alt=&#34;codegen .png&#34; /&gt;
&lt;/p&gt;

&lt;h1 id=&#34;3-1-chapter-3-introduction&#34;&gt;3.1 Chapter 3 Introduction&lt;/h1&gt;

&lt;p&gt;本章将会向你介绍如何转换为AST. built in Chapter2, into LLVM IR. 这将会教给你a little bit about LLVM是如何做这个的. 以及展示它的实用性. 构建一个词法分析器和解析器要比生成LLVM IR代码的工作多得多.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;please note&lt;/strong&gt;: 本章和之后的代码是基于LLVM 3.7 and later. LLVM 3.6 和之前的版本将不会工作for this code. 也要注意, 你需要一个匹配你的LLVM Release版本的tutorial.&lt;/p&gt;

&lt;h1 id=&#34;3-2-code-generation-setup&#34;&gt;3.2 Code Generation Setup&lt;/h1&gt;

&lt;p&gt;为了产生LLVM IR, 我们想要一些简单的setup来start. 首先我们定义virtual code generation(codegen)方法在每一个AST类中.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// ExprAST - Base class for all expression nodes.
class ExprAST {
public:
  virtual ~ExprAST() {}
  virtual Value *codegen() = 0;
};

/// NumberExprAST - Expression class for numeric literals like &amp;quot;1.0&amp;quot;.
class NumberExprAST : public ExprAST {
  double Val;

public:
  NumberExprAST(double Val) : Val(Val) {}
  virtual Value *codegen();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;codegen()表示为AST节点依赖它们来产生IR , 并且他们都返回一个&lt;strong&gt;Value&lt;/strong&gt;对象(被用来表示&amp;rdquo;Static Single Assigment(SSA) register&amp;rdquo; or &amp;ldquo;SSA value&amp;rdquo;in LLVM).&lt;/p&gt;

&lt;p&gt;SSA值的最独特的方面是当相关指令执行时, 他们的值被计算. 并且在指令再次执行之前, 它不会获得新值. 换句话说, 没有方法来改变SSA值. 为了了解更多关于SSA的信息, please read up on &lt;a href=&#34;https://l0phtg.github.io/post/llvm/static-single-assignment/&#34;&gt;Static Single Assignment&lt;/a&gt; - 一旦你理解了它, the concepts are really quite natural.&lt;/p&gt;

&lt;p&gt;请注意, 不是将虚方法添加到ExprAST的类层次结构中, 使用访问者模式或者其他方式对此进行建模也是有意义的.&lt;/p&gt;

&lt;p&gt;Again, 本教程将不再讨论良好的软件工程实践: 出于我们的目的, 添加虚拟方法是最简单的.&lt;/p&gt;

&lt;p&gt;我们想要的第二件事情, 是像我们在编写解析器时那样, 当发生错误时报告error. (例如, 对一个未声明参数的使用).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;static LLVMContext TheContext;
static IRBuilder&amp;lt;&amp;gt; Builder(TheContext);
static std::unique_ptr&amp;lt;Module&amp;gt; TheModule;
static std::map&amp;lt;std::string, Value *&amp;gt; NamedValues;

Value *LogErrorV(const char *Str) {
  LogError(Str);
  return nullptr;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在代码产生阶段, 静态变量将会被使用. TheContext 是一个掌握了大量的核心LLVM data 结构不透明的对象, 例如the type and 常量value tables. 我们不必关注它的细节, 我们仅仅需要一个简单的实例, 直接将它传到我们需要的API中即可.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;Builder object&lt;/strong&gt; 帮助我们使产生IR这件事变得很容易. &lt;strong&gt;IRBuilder&lt;/strong&gt;类的实例模板来&lt;strong&gt;跟踪当前插入指令的位置&lt;/strong&gt;并且&lt;strong&gt;提供创建新指令的方法&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TheModule&lt;/strong&gt; 是一个LLVM construct(包含函数和全局变量). In many ways, 它是一个LLVM IR用于包含代码的顶级结构.它将会掌控我们产生的IR的内存 (这就是为什么 codegen() method返回一个&lt;strong&gt;raw value&lt;/strong&gt;*, 而不是&lt;strong&gt;unique_ptr&lt;Value&gt;&lt;/strong&gt;).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The NamedValues map&lt;/strong&gt; 会跟踪&lt;strong&gt;当前作用域&lt;/strong&gt;中&lt;strong&gt;定义的值&lt;/strong&gt;以及它们的LLVM表示形式. (换句话说, 它是代码的符号表). &lt;code&gt;在 Kaleidoscope的形式中, 能被引用的唯一的things 是函数参数. 因此, 当为函数体进行Codegen时, 函数参数将会存在于该map中&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;有了这些基础知识, 我们可以开始讨论如何为每个表达式 generate code. 注意: this 假定已经设置了Builder来生成代码. 现在, 我们假设已经完成了, 我们将会just 用它来emit code.&lt;/p&gt;

&lt;h1 id=&#34;3-3-expression-code-generation&#34;&gt;3.3 Expression Code Generation&lt;/h1&gt;

&lt;p&gt;为每一个表达式产生LLVM code是非常直接的.&lt;/p&gt;

&lt;h2 id=&#34;numexpr&#34;&gt;numExpr&lt;/h2&gt;

&lt;p&gt;First we&amp;rsquo;ll do &lt;strong&gt;numberic literals&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Value *NumberExprAST::codegen() {
  return ConstantFP::get(TheContext, APFloat(Val));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在LLVM IR中, 数字常量用&lt;strong&gt;ConstantFP&lt;/strong&gt;类来表示, (在内部保存APFloat的值)(
APFloat 具有保存任意精度的浮点常数的能力). 这段代码基本就是创建并返回了一个&lt;strong&gt;ConstantFP&lt;/strong&gt;. 注意 在LLVM IR中, 常量都是唯一的, 并且被共享. 出于这个原因, The &lt;strong&gt;API use the &amp;ldquo;foo::(..)&amp;ldquo;而不是 &amp;ldquo;new foo(&amp;hellip;)&amp;rdquo; or &amp;ldquo;foo::Create(..)&amp;rdquo;&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&#34;variableexpr&#34;&gt;VariableExpr&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Value *VariableExprAST::codegen() {
  // Look this variable up in the function.
  Value *V = NamedValues[Name];
  if (!V)
    LogErrorV(&amp;quot;Unknown variable name&amp;quot;);
  return V;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用LLVM对变量的引用也非常简单. 在我们simple Kaleidoscope中, 我们假定变量已经被emitted somewhere 并且它的值是可用的. 实际上,  In the namedValues map 的唯一的值是函数参数. 此代码只是检查指定的name是否在map中. (如果没有, 未知变量将会被引用) 并且返回value for it. 在未来的章节, we&amp;rsquo;ll 将会在符号表和局部变量中增加&lt;strong&gt;Loop Induction variables&lt;/strong&gt; (可以阅读第5章: 对 Loop 进行 codegen的部分).&lt;/p&gt;

&lt;h2 id=&#34;binaryexprast&#34;&gt;BinaryExprAST&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Value *BinaryExprAST::codegen() {
  Value *L = LHS-&amp;gt;codegen();
  Value *R = RHS-&amp;gt;codegen();
  if (!L || !R)
    return nullptr;

  switch (Op) {
  case &#39;+&#39;:
    return Builder.CreateFAdd(L, R, &amp;quot;addtmp&amp;quot;);
  case &#39;-&#39;:
    return Builder.CreateFSub(L, R, &amp;quot;subtmp&amp;quot;);
  case &#39;*&#39;:
    return Builder.CreateFMul(L, R, &amp;quot;multmp&amp;quot;);
  case &#39;&amp;lt;&#39;:
    L = Builder.CreateFCmpULT(L, R, &amp;quot;cmptmp&amp;quot;);
    // Convert bool 0/1 to double 0.0 or 1.0
    return Builder.CreateUIToFP(L, Type::getDoubleTy(TheContext),
                                &amp;quot;booltmp&amp;quot;);
  default:
    return LogErrorV(&amp;quot;invalid binary operator&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二元操作符开始变得有趣.&lt;/p&gt;

&lt;p&gt;这里的基本思想: &lt;code&gt;我们递归地为表达式的左侧emit code, 然后是右侧, 然后我们计算二进制表达式的结果. 在这个代码中, 我们做一个简单的switch on the opcode来创建正确的LLVM 指令&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;在上面的例子中, LLVM Builder类开始显示其值. &lt;strong&gt;IRBuilder知道在哪里插入新创建的指令, 你所做的就是要指定什么指令将会被创建&lt;/strong&gt; (例如, 使用 &lt;strong&gt;CreateFAdd&lt;/strong&gt;), which &lt;strong&gt;使用哪些操作数(L and R here)&lt;/strong&gt; 并且optionally &lt;strong&gt;为生成的指令提供一个名字&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;关于LLVM, 一个不错的事情是名称就像一个提示.  例如, 如果上面的代码emit 多条 &amp;ldquo;addtmp&amp;rdquo; &lt;strong&gt;变量&lt;/strong&gt;, LLVM将自动地为每个变量提供一个递增的, 独特的数字suffix(后缀). 指令的本地值名称purely可选择的, but 它的名称应该要更方便我们阅读.&lt;/p&gt;

&lt;p&gt;LLVM 指令是被严格的规则所限制: For Example, &lt;strong&gt;一个指令的左边和右边的操作符一定要有相同的类型&lt;/strong&gt;, 并且add的&lt;strong&gt;结果类型一定要匹配操作数类型&lt;/strong&gt;. 因为in Kaleidoscope所有的值都是doubles, this makes for very simple code for add, sub, mul.&lt;/p&gt;

&lt;p&gt;在另一方面, LLVM 指定 &lt;strong&gt;fcmp&lt;/strong&gt; 指令总是返回一个 &amp;ldquo;i1&amp;rdquo; 值( 1 比特整型). 问题是 Kaleidoscope希望值是&lt;strong&gt;0.0&lt;/strong&gt;或者&lt;strong&gt;1.0&lt;/strong&gt;. 为了获得这些语义, 我们将&lt;strong&gt;fcmp指令&lt;/strong&gt;与&lt;strong&gt;uitofp指令&lt;/strong&gt;(unsigned integer to float point)结合起来. 该指令通过将它的输入整数转换为浮点值by 将输入视为无符号值. 相反, 如果我们使用&lt;strong&gt;sitofp指令&lt;/strong&gt;, The kaleidoscope &amp;lsquo;&amp;lt;&amp;rsquo; 操作符将会返回&lt;strong&gt;0.0&lt;/strong&gt;和&lt;strong&gt;-1.0&lt;/strong&gt;, 具体依赖于输入值.&lt;/p&gt;

&lt;h2 id=&#34;callexprast&#34;&gt;CallExprAST&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Value *CallExprAST::codegen() {
  // Look up the name in the global module table. 在全局module table中寻找name
  Function *CalleeF = TheModule-&amp;gt;getFunction(Callee);
  if (!CalleeF)
    return LogErrorV(&amp;quot;Unknown function referenced&amp;quot;);

  // If argument mismatch error.
  if (CalleeF-&amp;gt;arg_size() != Args.size())
    return LogErrorV(&amp;quot;Incorrect # arguments passed&amp;quot;);

  std::vector&amp;lt;Value *&amp;gt; ArgsV;
  for (unsigned i = 0, e = Args.size(); i != e; ++i) {
    ArgsV.push_back(Args[i]-&amp;gt;codegen());
    if (!ArgsV.back())
      return nullptr;
  }

  return Builder.CreateCall(CalleeF, ArgsV, &amp;quot;calltmp&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用LLVM来产生函数调用的codegen是相当简单直接的.&lt;/p&gt;

&lt;p&gt;上面的代码最开始会在LLVM Module&amp;rsquo;s 符号表中 寻找函数的名称. 回想一下, LLVM Module是一个可以包含我们正在执行的JIT函数的容器. 通过给每一个函数指定与用户指定的相同的名称, 我们可以使用LLVM 符号表来解析我们的函数名称.&lt;/p&gt;

&lt;p&gt;一旦我们有函数要调用, 我们递归地codegen(编码)每一个我们要传入的参数, 并且创建一个LLVM调用指令. 注意, LLVM默认使用本地的c调用规定, 允许这些调用来调用标准库函数(like &amp;ldquo;sin&amp;rdquo; and &amp;ldquo;cos&amp;rdquo;)是轻松的, 不需要任何额外的工作.&lt;/p&gt;

&lt;p&gt;这包含了我们对四个基本表达式(in Kaileidoscope)的处理. 当然, 你可以随意添加更多. 例如, 通过浏览 &lt;a href=&#34;http://llvm.org/docs/LangRef.html&#34;&gt;LLVM Language reference&lt;/a&gt;. 你将会找到其他一些有趣的指令, 并且将他们加到我们的框架中是非常简单的.&lt;/p&gt;

&lt;h1 id=&#34;3-4-function-code-generation&#34;&gt;3.4 Function Code Generation&lt;/h1&gt;

&lt;p&gt;函数申明和函数定义的代码生成要处理大量的细节, which 这使得它们的代码生成不如expression 的代码生成 漂亮, but 这允许我们说明一些重要的点.&lt;/p&gt;

&lt;h2 id=&#34;prototypeast&#34;&gt;PrototypeAST&lt;/h2&gt;

&lt;p&gt;首先, 我们先讨论函数申明的代码产生: 他们可以用于函数体, 也可以用于外部函数申明.&lt;/p&gt;

&lt;p&gt;The code starts with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Function *PrototypeAST::codegen() {
  // Make the function type:  double(double,double) etc.
  std::vector&amp;lt;Type*&amp;gt; Doubles(Args.size(),
                             Type::getDoubleTy(TheContext));
  FunctionType *FT =
    FunctionType::get(Type::getDoubleTy(TheContext), Doubles, false);

  Function *F =
    Function::Create(FT, Function::ExternalLinkage, Name, TheModule.get());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码将大量的功能集成到几行. First注意, 这个函数返回了一个&amp;rdquo;&lt;strong&gt;Function&lt;/strong&gt;&amp;ldquo;而不是&amp;rdquo;&lt;strong&gt;Value&lt;/strong&gt;&amp;rdquo;. 因为&amp;rdquo;prototype&amp;rdquo;是在讨论函数的外部接口(而不是表达式计算的值), 当codegen时, 返回LLVM Function是有意义的.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FunctionType::get&lt;/strong&gt;的调用创建&lt;strong&gt;FunctionType&lt;/strong&gt;(that 被用于给定的声明). 由于Kaleidoscope中所有的函数参数都是double类型的, 第一行创建了一个&amp;rdquo;N个double类型的vector&amp;rdquo;. 然后使用&lt;strong&gt;FunctionType::get&lt;/strong&gt;创建了接收N个double类型参数的函数. 返回一个double作为结果,(那不是可变参数(false表示这一点)). 注意 LLVM中类型是和常量一样唯一的, 所以你不用&amp;rdquo;new a type&amp;rdquo;, you &amp;ldquo;get&amp;rdquo; it.&lt;/p&gt;

&lt;p&gt;上面的最后一行实际上创建了与Prototype相对应的IR函数. 这表明了要使用的类型, 链接, 名称, 以及要插入的模块. &amp;ldquo;external linkage&amp;rdquo;意味着该函数可能在当前模块之外定义. and or 它能够被模块外面的函数所调用. 传入的名称是用户指定的名称: 由于指定了&amp;rdquo;TheModule&amp;rdquo;, 因此该名称在&amp;rdquo;TheModule&amp;rdquo;符号表中被注册.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Set names for all arguments. 设置所有参数的名称
unsigned Idx = 0;
for (auto &amp;amp;Arg : F-&amp;gt;args())
  Arg.setName(Args[Idx++]);

return F;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后, 我们根据Prototype中的名称设置每个函数参数的名称. 这一步并不是严格需要的, 但是保持名称的一致是IR的可读性更强, 并允许后面的代码直接引用其名称的参数, 而不需要在PrototypeAST中查找他们.&lt;/p&gt;

&lt;h2 id=&#34;functionast&#34;&gt;FunctionAST&lt;/h2&gt;

&lt;p&gt;我们有一个没有函数体的function prototype.  这是LLVM IR表示函数申明的方式. 对于在Kaileidoscope中的extern表达式来说, 这正是我们想要表达的. 然而对于函数定义来说,我们需要codegen并且attach a 函数体:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Function *FunctionAST::codegen() {
    // First, check for an existing function from a previous &#39;extern&#39; declaration.
  Function *TheFunction = TheModule-&amp;gt;getFunction(Proto-&amp;gt;getName());

  if (!TheFunction)
    TheFunction = Proto-&amp;gt;codegen();

  if (!TheFunction)
    return nullptr;

  if (!TheFunction-&amp;gt;empty())
    return (Function*)LogErrorV(&amp;quot;Function cannot be redefined.&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于函数定义来说, 我们首先在TheModule的符号表中搜索此函数的现有版本.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一种case是:using &amp;ldquo;extern&amp;rdquo; 语句时, 符号表就被创建了. 如果 Module::getFunction 返回 null, 则意味着不存在先前的版本, 所以我们就需要根据申明来进行Prototype Codegen.&lt;/li&gt;
&lt;li&gt;在另一种case中, 我们想要在我们开始之前, assert函数是empty(i.e. 还没有函数体)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Create a new basic block to start insertion into.  创建一个新的basic block 来插入.
BasicBlock *BB = BasicBlock::Create(TheContext, &amp;quot;entry&amp;quot;, TheFunction);
Builder.SetInsertPoint(BB);

// Record the function arguments in the NamedValues map. 在NamedValue mao中记录函数参数.
NamedValues.clear();
for (auto &amp;amp;Arg : TheFunction-&amp;gt;args())
  NamedValues[Arg.getName()] = &amp;amp;Arg;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们可以开始建立Builder了:&lt;/p&gt;

&lt;p&gt;第一行创建了一个&lt;strong&gt;new basic block(named &amp;ldquo;entry&amp;rdquo;)&lt;/strong&gt;, 被直接插入到函数中. 第二行告诉我们新的指令应该被插在&lt;strong&gt;new basic block&lt;/strong&gt;的末尾. 在LLVM中&lt;code&gt;Basic Block&lt;/code&gt;(define the &lt;strong&gt;Control Flow Graph&lt;/strong&gt;)是函数中重要的一部分. 因为我们没有任何控制流, 所以此时我们的函数只包含一个Block. &lt;strong&gt;we&amp;rsquo;ll fix this in Chapter 5&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;现在我们添加函数参数到&lt;strong&gt;NamedValues map&lt;/strong&gt;中(当然了, 首先它会被清空) 以便于它们可以被VariableExprAST节点所获取.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;if (Value *RetVal = Body-&amp;gt;codegen()) {
  // Finish off the function.
  Builder.CreateRet(RetVal);

  // Validate the generated code, checking for consistency.
  verifyFunction(*TheFunction);

  return TheFunction;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;一旦在&lt;strong&gt;设置了插入点&lt;/strong&gt;, 并且填充了&lt;strong&gt;NamedValues&lt;/strong&gt;之后, 我们调用codegen() 方法作为function的 root 表达式.&lt;/li&gt;
&lt;li&gt;如果没有error发生, &lt;strong&gt;this emits code&lt;/strong&gt;计算表达式到 &lt;strong&gt;entry block&lt;/strong&gt; 并返回计算出的值.&lt;/li&gt;
&lt;li&gt;假设没有error, 我们然后创建&lt;strong&gt;an LLVM ret instruction&lt;/strong&gt; (表示函数完成).&lt;/li&gt;
&lt;li&gt;一旦函数被构建后, 我们就会调用&lt;strong&gt;verifyFunction&lt;/strong&gt;(which provided by LLVM). 该函数对产生的IR做大量的一致性检测, 来确定是否我们的编译代码都是正确的. 使用它是相当重要地, 它能够捕获大量的bugs. 一旦一个函数完成并验证后, 我们就会返回它.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;  // Error reading body, remove function.
  TheFunction-&amp;gt;eraseFromParent();
  return nullptr;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后剩下的唯一一件事情就是处理error case. 简单起见, 我们仅仅通过使用&lt;strong&gt;earseFromParent&lt;/strong&gt;方法来删除我们Codegen的函数. 这允许用户重新定义他们之前输入错误的函数: 如果我们不删除它,  它将会继续保存在符号表中, 并且它还有body, 阻止我们之后定义.&lt;/p&gt;

&lt;p&gt;这代码有一个bug, 如果&lt;strong&gt;FunctionAST::codegen()&lt;/strong&gt;方法发现了一个存在的IR Function. 它不会根据自己的申明来验证其签名. 这意味着: 一个更早的&lt;code&gt;extern&lt;/code&gt;申明将会优先于函数定义的签名, 这可能导致codegen失败. 例如, 如果函数参数的名称不同.(what means ? 以后再研究)&lt;/p&gt;

&lt;p&gt;有很多方法可以解决这个问题, see what you can come up with! Here is a testcase:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;extern foo(a);     # ok, defines foo.
def foo(b) b;      # Error: Unknown variable name. (decl using &#39;a&#39; takes precedence).
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;3-5-driver-changes-and-closing-thoughts&#34;&gt;3.5 Driver Changes and Closing Thoughts&lt;/h1&gt;

&lt;p&gt;到目前为止, 除了我们可以查看漂亮的LLVM调用之外, LLVM的Codegen并没有给我们带来太多的帮助. The sample code 将对codegen的调用插入到 &amp;ldquo;HandleDefinition&amp;rdquo;, &amp;ldquo;HandleExtern&amp;rdquo;等函数中, 然后dump out the LLVM IR.&lt;/p&gt;

&lt;p&gt;这里有一个简单的方法来查看LLVM IR. Ex:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;ready&amp;gt; 4+5;
Read top-level expression:
define double @0() {
entry:
  ret double 9.000000e+00
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意 解析器是如何将顶级表达式转换为我们的anonymous函数. 当我们在下一章添加JIT Support时, 这会很便利.&lt;/p&gt;

&lt;p&gt;另外, 代码是literally transcribed, 除了IRBuilder会进行简单的常量折叠外, 不会执行任何优化. 下一章, 我们将会添加一些隐式地优化.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;ready&amp;gt; def foo(a b) a*a + 2*a*b + b*b;
Read function definition:
define double @foo(double %a, double %b) {
entry:
  %multmp = fmul double %a, %a
  %multmp1 = fmul double 2.000000e+00, %a
  %multmp2 = fmul double %multmp1, %b
  %addtmp = fadd double %multmp, %multmp2
  %multmp3 = fmul double %b, %b
  %addtmp4 = fadd double %addtmp, %multmp3
  ret double %addtmp4
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里展示了一些简单的表达式运算.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;ready&amp;gt; def bar(a) foo(a, 4.0) + bar(31337);
Read function definition:
define double @bar(double %a) {
entry:
  %calltmp = call double @foo(double %a, double 4.000000e+00)
  %calltmp1 = call double @bar(double 3.133700e+04)
  %addtmp = fadd double %calltmp, %calltmp1
  ret double %addtmp
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里展示了一些函数调用.&lt;/p&gt;

&lt;p&gt;Note 如果你调用它的话, 这个函数将会花大量时间来执行.&lt;/p&gt;

&lt;p&gt;在未来, 我们将会添加一些条件控制流来使递归变得可以使用.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;ready&amp;gt; extern cos(x);
Read extern:
declare double @cos(double)

ready&amp;gt; cos(1.234);
Read top-level expression:
define double @1() {
entry:
  %calltmp = call double @cos(double 1.234000e+00)
  ret double %calltmp
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里展示了一个extern for libm &amp;ldquo;cos&amp;rdquo; 函数, and call to it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;ready&amp;gt; ^D
; ModuleID = &#39;my cool jit&#39;

define double @0() {
entry:
  %addtmp = fadd double 4.000000e+00, 5.000000e+00
  ret double %addtmp
}

define double @foo(double %a, double %b) {
entry:
  %multmp = fmul double %a, %a
  %multmp1 = fmul double 2.000000e+00, %a
  %multmp2 = fmul double %multmp1, %b
  %addtmp = fadd double %multmp, %multmp2
  %multmp3 = fmul double %b, %b
  %addtmp4 = fadd double %addtmp, %multmp3
  ret double %addtmp4
}

define double @bar(double %a) {
entry:
  %calltmp = call double @foo(double %a, double 4.000000e+00)
  %calltmp1 = call double @bar(double 3.133700e+04)
  %addtmp = fadd double %calltmp, %calltmp1
  ret double %addtmp
}

declare double @cos(double)

define double @1() {
entry:
  %calltmp = call double @cos(double 1.234000e+00)
  ret double %calltmp
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当你退出demo时(在 linux 上通过CTRL+D,or  windows上通过CTRL+Z来发送EOF), 它将会显示该module产生的所有IR.&lt;/p&gt;

&lt;p&gt;这就是Kaleidoscope tutorial 第三章的内容.&lt;/p&gt;

&lt;p&gt;接下来, 我们会展示如何添加JIT Codegen和优化器支持, 以便于我们之后可以开始运行代码.&lt;/p&gt;

&lt;h1 id=&#34;3-6-full-code-listing&#34;&gt;3.6 Full Code Listing&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl03.html&#34;&gt;http://llvm.org/docs/tutorial/LangImpl03.html&lt;/a&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Kaleidoscope: Implementing a Parser and AST</title>
      <link>https://l0phtg.github.io/post/llvm/kaleidoscope-implementing-a-parser-and-ast/</link>
      <pubDate>Thu, 11 Apr 2019 15:41:17 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/llvm/kaleidoscope-implementing-a-parser-and-ast/</guid>
      
        <description>&lt;p&gt;translate from: &lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl02.html&#34;&gt;http://llvm.org/docs/tutorial/LangImpl02.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/docs-pic/dots/uml/ExprAst-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;介绍AST(抽象语法树)和Parser.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;2-1-introduction&#34;&gt;2.1 Introduction&lt;/h1&gt;

&lt;p&gt;本章介绍如何使用&lt;strong&gt;Lexer&lt;/strong&gt;, 来build一个完整的&lt;strong&gt;parser&lt;/strong&gt; for our Kaleidoscope language. 一旦我们有了parser, 我们将会定义并且build 一个 AST.&lt;/p&gt;

&lt;h1 id=&#34;2-2-ast&#34;&gt;2.2 AST&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/llvm/chapter2-AST.png&#34; alt=&#34;Chapter2 AST&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;2-3-parser-basic&#34;&gt;2.3 Parser Basic&lt;/h1&gt;

&lt;p&gt;现在我们有了AST, 我们需要定义parser code来build it. 这里的想法是我们要解析类似于&amp;rdquo;&lt;strong&gt;x+y&lt;/strong&gt;&amp;rdquo;(由词法分析器会返回3个Token)到AST中, 可以通过下面的代码产生:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto LHS = llvm::make_unique&amp;lt;VariableExprAST&amp;gt;(&amp;quot;x&amp;quot;);
auto RHS = llvm::make_unique&amp;lt;VariableExprAST&amp;gt;(&amp;quot;y&amp;quot;);
auto Result = std::make_unique&amp;lt;BinaryExprAST&amp;gt;(&#39;+&#39;, std::move(LHS),
                                              std::move(RHS));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Log&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// LogError* - These are little helper functions for error handling.
std::unique_ptr&amp;lt;ExprAST&amp;gt; LogError(const char *Str) {
  fprintf(stderr, &amp;quot;LogError: %s\n&amp;quot;, Str);
  return nullptr;
}
std::unique_ptr&amp;lt;PrototypeAST&amp;gt; LogErrorP(const char *Str) {
  LogError(Str);
  return nullptr;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;2-4-basic-expression-parsing&#34;&gt;2.4 Basic Expression Parsing&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;ParseNumberExpr&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// numberexpr ::= number
static std::unique_ptr&amp;lt;ExprAST&amp;gt; ParseNumberExpr() {
  auto Result = llvm::make_unique&amp;lt;NumberExprAST&amp;gt;(NumVal);
  getNextToken(); // consume the number
  return std::move(Result);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;ParseParenExpr&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;这里有一些有趣的点. 最主要的一点是 this routine eats all of the tokens that correspond to the production. 并且将next token返回到词法缓冲区中. (这不是一定要要求的), 这是一个实现递归下降parser的相当标准的写法.&lt;/p&gt;

&lt;p&gt;a better example, 括号运算符的parser defined like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// parenexpr ::= &#39;(&#39; expression &#39;)&#39;
static std::unique_ptr&amp;lt;ExprAST&amp;gt; ParseParenExpr() {  
  getNextToken(); // eat (.
  auto V = ParseExpression();
  if (!V)
    return nullptr;

  if (CurTok != &#39;)&#39;)
    return LogError(&amp;quot;expected &#39;)&#39;&amp;quot;);
  getNextToken(); // eat ).
  return V;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该函数说明了大量关于parser的有趣的事情:&lt;/p&gt;

&lt;p&gt;1) 展示了我们可以怎么样使用&lt;strong&gt;LogError&lt;/strong&gt;. 当被调用的时候, 该函数期待current token是 &amp;lsquo;&lt;strong&gt;(&lt;/strong&gt;&amp;rsquo;, 然后之后开始解析subexpression, (可能没有&amp;rsquo;)&amp;rsquo; waiting), 如果用户输入&amp;rdquo;(4 x&amp;rdquo; 代替 &amp;ldquo;(4)&amp;rdquo;, the parser应该弹一个error. 因为error发生了, parser需要一种方法来表明error发生时, 程序会做什么.在我们的解析器中, 当&lt;strong&gt;error&lt;/strong&gt;发生时, 我们会返回&lt;strong&gt;null&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;2) 另一个有趣的点是&lt;strong&gt;该函数使用了递归来调用ParserExpression&lt;/strong&gt;(我们不久将会看到&lt;strong&gt;ParserExpression&lt;/strong&gt;中调用了&lt;strong&gt;ParserParentExpr&lt;/strong&gt;). 这是一种处理递归语法的相当不错的方法. 并且它保证每个过程都十分simple. 注意, &lt;strong&gt;括号并不会引起AST node的构造&lt;/strong&gt;. 当我们这样做的时候, 括号最重要的角色就是&lt;strong&gt;知道parser来提供grouping&lt;/strong&gt;. 一旦parser成功构造了AST, 括号就不再被需要的.&lt;/p&gt;

&lt;p&gt;下面的例子是处理变量引用和函数调用:&lt;/p&gt;

&lt;p&gt;变量后面跟括号, 代表函数调用. 如果不是, 代码变量为identifier.&lt;/p&gt;

&lt;h1 id=&#34;2-5-binary-expression-parsing&#34;&gt;2.5 Binary Expression Parsing&lt;/h1&gt;

&lt;p&gt;二元表达式很难解析, 因为它们通常是模棱两可的. 例如, 当给 the string &amp;ldquo;x+y*z&amp;rdquo;, the parser可以选择&amp;rdquo;(x+y)*z&amp;rdquo;, 也可以选择&amp;rdquo;x+(y&lt;em&gt;z)&amp;ldquo;, 根据数学的定义, 我们的理解后面的是正确的. 因为 &amp;ldquo;&lt;/em&gt;&amp;ldquo;的优先级比&amp;rdquo;+&amp;ldquo;更高.&lt;/p&gt;

&lt;p&gt;有很多种方法来处理它, 但是一种优雅的和有效的方法是&lt;strong&gt;Operator-Precedence-Parsing&lt;/strong&gt;. 这种解析技术使用优先级来指导二元操作符递归处理. To start with, we need a table of precedences:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// BinopPrecedence - This holds the precedence for each binary operator that is
/// defined.
static std::map&amp;lt;char, int&amp;gt; BinopPrecedence;

/// GetTokPrecedence - Get the precedence of the pending binary operator token.
static int GetTokPrecedence() {
  if (!isascii(CurTok))
    return -1;

  // Make sure it&#39;s a declared binop.
  int TokPrec = BinopPrecedence[CurTok];
  if (TokPrec &amp;lt;= 0) return -1;
  return TokPrec;
}

int main() {
  // Install standard binary operators.
  // 1 is lowest precedence.
  BinopPrecedence[&#39;&amp;lt;&#39;] = 10;
  BinopPrecedence[&#39;+&#39;] = 20;
  BinopPrecedence[&#39;-&#39;] = 20;
  BinopPrecedence[&#39;*&#39;] = 40;  // highest.
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于Kaleidoscope基本的形式来说, 我们只支持4种二元操作符(很明显你可以扩展它, our brave and interpid reader). The &lt;strong&gt;GetTokPrecedence&lt;/strong&gt;返回目前token的优先级, 如果&lt;strong&gt;不是二元操作符的话, 返回 -1&lt;/strong&gt;. 通过一个map来增加一些操作符是一种不错的方法. 并且这很容易比较优先级.&lt;/p&gt;

&lt;p&gt;有了上面的定义, 我们就可以解析二元操作符了. 运算符优先级解析的基本思想是:&lt;strong&gt;将具有可能不明确的二元运算符的表达式分成多个&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Ex: 表达式&amp;rdquo;&lt;strong&gt;a+b+(c+d)*e*f+g&lt;/strong&gt;. operator precedence 将该表达式视为一个primary expressions流 separated by binary operators. 它将会先解析&lt;strong&gt;a&lt;/strong&gt;, 然后[+, b] [+, (c+d)] [&lt;em&gt;, e] [&lt;/em&gt;, f] and [+, g]. 注意括号也是primary expressions. 二元表达式不用担心它的subexpressions like (c+d) at all .&lt;/p&gt;

&lt;p&gt;To start, an expression is a primary expression. 可能后面跟着[binop, primaryexpr].&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// expression
///   ::= primary binoprhs
///
static std::unique_ptr&amp;lt;ExprAST&amp;gt; ParseExpression() {
  auto LHS = ParsePrimary();
  if (!LHS)
    return nullptr;

  return ParseBinOpRHS(0, std::move(LHS));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;ParseBinOpRHS&lt;/strong&gt;是一个函数来解析一系列的&lt;strong&gt;pairs&lt;/strong&gt;. 它需要一个优先级和指向表达式的指针.&lt;/p&gt;

&lt;p&gt;注意 that &amp;ldquo;&lt;strong&gt;x&lt;/strong&gt;&amp;rdquo; 是一个完全有效的表达式, 例如: &amp;ldquo;binoprhs&amp;rdquo; 可以是空的. 在这种情况下, it returns the expression that is passed into it. 在我们上面的例子中, 代码传递表达式&amp;rdquo;a&amp;rdquo;到ParseBinOpRHS 并且当前的token是 &amp;ldquo;+&amp;rdquo;;&lt;/p&gt;

&lt;p&gt;传递给ParseBinOpRHS的优先级值表示函数被允许eat 的 the minimal operator precedence.
例如, 如果目前的pair stream is [+, x] and ParseBinOpRHS被传递的优先级是40, 它将不会消耗任何tokens(因为&amp;rsquo;+&amp;lsquo;的优先级是20). 根据这种思想, ParseBinOpRHS starts with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// binoprhs
///   ::= (&#39;+&#39; primary)*
static std::unique_ptr&amp;lt;ExprAST&amp;gt; ParseBinOpRHS(int ExprPrec,
                                              std::unique_ptr&amp;lt;ExprAST&amp;gt; LHS) {
  // If this is a binop, find its precedence.
  while (1) {
    int TokPrec = GetTokPrecedence();

    // If this is a binop that binds at least as tightly as the current binop,
    // consume it, otherwise we are done.
    if (TokPrec &amp;lt; ExprPrec)
      return LHS;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该代码获得当前token的优先级, 并且检查它是否是too low. 因为我们定义无效的tokens的优先级是-1, 所以这隐式地可以知道(当run out of binary operators时, pair-stream就结束了).如果this check succeed, 我们知道token是一个二元表达式并且它将被included in this expression:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;    // Okay, we know this is a binop.
    int BinOp = CurTok;
    getNextToken();  // eat binop
    
    // Parse the primary expression after the binary operator.
    auto RHS = ParsePrimary();
    if (!RHS)
      return nullptr;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As such, this code eats(and remembers) 二元表达式 and 解析primary expression that follows. This build up the whole pair, the first of which is [+, b] for the running example.&lt;/p&gt;

&lt;p&gt;现在我们解析表达式的左边和一组RHS sequence, 我们不得不决定which way the expression associates. 特别地, 我们 have &amp;ldquo;(a+b)&amp;rdquo; binop unparsed or &amp;ldquo;a+(b binop unparsed&amp;rdquo;. 为了确定这个, 我们look ahead at &amp;ldquo;binop&amp;rdquo; to 确定它的优先级并且将它与BinOp&amp;rsquo;s 优先级比较(which is &amp;lsquo;+&amp;rsquo; in this case):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// If BinOp binds less tightly with RHS than the operator after RHS, let
// the pending operator take RHS as its LHS.
int NextPrec = GetTokPrecedence();
if (TokPrec &amp;lt; NextPrec) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果binop在&amp;rdquo;RHS&amp;rdquo;右侧的优先级低于或者等于我们当前运算符的优先级. in our example, 目前的操作符是&amp;rdquo;+&amp;rdquo; 并且下一个操作符是&amp;rdquo;+&amp;ldquo;, 我们明白他们有相同的优先级. in this case 我们将会创建node for &amp;ldquo;a+b&amp;rdquo;, and then continue parsing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;      ... if body omitted ...
    }

    // Merge LHS/RHS.
    LHS = llvm::make_unique&amp;lt;BinaryExprAST&amp;gt;(BinOp, std::move(LHS),
                                           std::move(RHS));
  }  // loop around to the top of the while loop.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在我们的例子中. 这将把 &amp;ldquo;a + b&amp;rdquo; into &amp;ldquo;(a + b)&amp;ldquo;并且来执行下一次循环的迭代. with &amp;ldquo;+&amp;rdquo; as the current token. 上面的代码将被eat, remember, and parse (&amp;ldquo;c + d&amp;rdquo;) as the primary expression, which makes the 目前的pair equal to [+, (c + d)]. 它将会评估上面的&amp;rdquo;if&amp;rdquo;条件, 并将&amp;rdquo;&lt;em&gt;&amp;ldquo;作为右侧的binop. 在该case中, 优先级 of &amp;ldquo;&lt;/em&gt;&amp;rdquo; 是比+的优先级更高, 因此if条件将会被输入.&lt;/p&gt;

&lt;p&gt;关键的问题是: if条件如何解析右边的全部? In particular, 为了在我们的例子中正确的build AST. 它需要将&amp;rdquo;(c + d)*e*f&amp;rdquo;作为RHS表达式变量. 执行该操作的代码相当简单.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;    // If BinOp binds less tightly with RHS than the operator after RHS, let
    // the pending operator take RHS as its LHS.
    int NextPrec = GetTokPrecedence();
    if (TokPrec &amp;lt; NextPrec) {
      RHS = ParseBinOpRHS(TokPrec+1, std::move(RHS));
      if (!RHS)
        return nullptr;
    }
    // Merge LHS/RHS.
    LHS = llvm::make_unique&amp;lt;BinaryExprAST&amp;gt;(BinOp, std::move(LHS),
                                           std::move(RHS));
  }  // loop around to the top of the while loop.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这一点上, 我们知道我们主要的RHS的二元运算符优于我们当前正在解析的binop. 因此, 我们知道任何运算符都优先于&amp;rdquo;+&amp;ldquo;的序列应该一起解析并作为&amp;rdquo;RHS&amp;rdquo;返回.&lt;/p&gt;

&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;

&lt;p&gt;递归构造.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;a+b*c*(d+e) + f&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;第一次循环:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!--1. [0, a] 和 [+, b]; [0, a] 为LHS; 0 &amp;lt; +,  [1+, b] 继续ParseBinOpRHS--&amp;gt;
&amp;lt;!--2. [+, b] 和 [*, c]; [+, b] 为LHS; + &amp;lt; *,  [*, c] 继续ParseBinOpRHS--&amp;gt;
&amp;lt;!--3. [*, c] 和 [(), d+e]; [*, c]为LHS     --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;mermaid&#34;&gt;
graph TB
    1((a)) 
    2((b))
    3((c))
    4((d))
    5((e))
    
    7((+))
    8((*))
    9((*))
    10((+))
    
    7 --&gt; 1
    
    8 --&gt; 2
    8 --&gt; 3
    9 --&gt; 8
    9 --&gt; 10
    10 --&gt; 4
    10 --&gt; 5
    
    7 --&gt; 9
&lt;/div&gt;

&lt;p&gt;第二次循环&lt;/p&gt;

&lt;div class=&#34;mermaid&#34;&gt;
graph TB
    1((a)) 
    2((b))
    3((c))
    4((d))
    5((e))
    6((f))
    7((+))
    8((*))
    9((*))
    10((+))
    11((+))
    
    7 --&gt; 1
    
    8 --&gt; 2
    8 --&gt; 3
    9 --&gt; 8
    9 --&gt; 10
    10 --&gt; 4
    10 --&gt; 5
    
    7 --&gt; 9
    
    subgraph TB
    11 --&gt; 7
    11 --&gt; 6
    end
&lt;/div&gt;

&lt;h1 id=&#34;2-6-parse-the-rest&#34;&gt;2.6 Parse the Rest&lt;/h1&gt;

&lt;p&gt;下一件事情是解析函数申明. in Kaleidoscope, &lt;code&gt;extern&lt;/code&gt;函数申明以及函数体定义. 代码是相当直接的, not very interesting(once you&amp;rsquo;re survived expressions):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// prototype
///   ::= id &#39;(&#39; id* &#39;)&#39;
static std::unique_ptr&amp;lt;PrototypeAST&amp;gt; ParsePrototype() {
  if (CurTok != tok_identifier)
    return LogErrorP(&amp;quot;Expected function name in prototype&amp;quot;);

  std::string FnName = IdentifierStr;
  getNextToken();

  if (CurTok != &#39;(&#39;)
    return LogErrorP(&amp;quot;Expected &#39;(&#39; in prototype&amp;quot;);

  // Read the list of argument names.
  std::vector&amp;lt;std::string&amp;gt; ArgNames;
  while (getNextToken() == tok_identifier)
    ArgNames.push_back(IdentifierStr);
  if (CurTok != &#39;)&#39;)
    return LogErrorP(&amp;quot;Expected &#39;)&#39; in prototype&amp;quot;);

  // success.
  getNextToken();  // eat &#39;)&#39;.

  return llvm::make_unique&amp;lt;PrototypeAST&amp;gt;(FnName, std::move(ArgNames));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然了, 函数定义是相当简单的, just &lt;strong&gt;一个申明&lt;/strong&gt;加&lt;strong&gt;一个表达式&lt;/strong&gt;来实现函数体.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// definition ::= &#39;def&#39; prototype expression
static std::unique_ptr&amp;lt;FunctionAST&amp;gt; ParseDefinition() {
  getNextToken();  // eat def.
  auto Proto = ParsePrototype();
  if (!Proto) return nullptr;

  if (auto E = ParseExpression())
    return llvm::make_unique&amp;lt;FunctionAST&amp;gt;(std::move(Proto), std::move(E));
  return nullptr;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，我们支持&lt;code&gt;extern&lt;/code&gt;来声明&lt;code&gt;sin&lt;/code&gt;和&lt;code&gt;cos&lt;/code&gt;之类的函数，以及支持用户函数的前向声明。这些&lt;code&gt;extern&lt;/code&gt;只是没有身体的原型:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// external ::= &#39;extern&#39; prototype
static std::unique_ptr&amp;lt;PrototypeAST&amp;gt; ParseExtern() {
  getNextToken();  // eat extern.
  return ParsePrototype();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后, 我们让用户输入任意顶级表达式并evaluate them. 我们将会处理this by defining anonymous nullary(zero argument) functions for them:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// toplevelexpr ::= expression
static std::unique_ptr&amp;lt;FunctionAST&amp;gt; ParseTopLevelExpr() {
  if (auto E = ParseExpression()) {
    // Make an anonymous proto.
    auto Proto = llvm::make_unique&amp;lt;PrototypeAST&amp;gt;(&amp;quot;&amp;quot;, std::vector&amp;lt;std::string&amp;gt;());
    return llvm::make_unique&amp;lt;FunctionAST&amp;gt;(std::move(Proto), std::move(E));
  }
  return nullptr;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们have all the pieces, let&amp;rsquo;s build a little driver that will let us actually execute this code we&amp;rsquo;ve built!&lt;/p&gt;

&lt;h1 id=&#34;2-7-the-driver&#34;&gt;2.7 The Driver&lt;/h1&gt;

&lt;p&gt;The Driver仅仅是通过调用所有的解析pieces.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// top ::= definition | external | expression | &#39;;&#39;
static void MainLoop() {
  while (1) {
    fprintf(stderr, &amp;quot;ready&amp;gt; &amp;quot;);
    switch (CurTok) {
    case tok_eof:
      return;
    case &#39;;&#39;: // ignore top-level semicolons.
      getNextToken();
      break;
    case tok_def:
      HandleDefinition();
      break;
    case tok_extern:
      HandleExtern();
      break;
    default:
      HandleTopLevelExpression();
      break;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一件有趣的事情是:  我们忽略了顶级&amp;rdquo;;&amp;ldquo;.&lt;/p&gt;

&lt;h1 id=&#34;2-8-conclusions&#34;&gt;2.8 Conclusions&lt;/h1&gt;

&lt;p&gt;通过这仅仅400行的代码, 我们定义了我们的最小的语言, 包含一个词法分析器, 解析器, 和AST builder.&lt;/p&gt;

&lt;p&gt;这是一个简单的交互例子:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./a.out
ready&amp;gt; def foo(x y) x+foo(y, 4.0);
Parsed a function definition.
ready&amp;gt; def foo(x y) x+y y;
Parsed a function definition.
Parsed a top-level expr
ready&amp;gt; def foo(x y) x+y );
Parsed a function definition.
Error: unknown token when expecting an expression
ready&amp;gt; extern sin(a);
ready&amp;gt; Parsed an extern
ready&amp;gt; ^D
$
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;2-9-full-code-listing&#34;&gt;2.9 Full Code Listing&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl02.html#the-abstract-syntax-tree-ast&#34;&gt;http://llvm.org/docs/tutorial/LangImpl02.html#the-abstract-syntax-tree-ast&lt;/a&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Kaleidoscope: Tutorial Introduction and Lexer</title>
      <link>https://l0phtg.github.io/post/kaleidoscope-tutorial-introduction-and-lexer/</link>
      <pubDate>Wed, 10 Apr 2019 10:17:08 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/kaleidoscope-tutorial-introduction-and-lexer/</guid>
      
        <description>&lt;p&gt;translate from &lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl01.html&#34;&gt;http://llvm.org/docs/tutorial/LangImpl01.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本tutorial将会介绍一个简单语言的实现.
&lt;/p&gt;

&lt;h1 id=&#34;1-1-tutorial-introduction&#34;&gt;1.1 Tutorial Introduction&lt;/h1&gt;

&lt;h1 id=&#34;1-2-the-basic-language&#34;&gt;1.2 The Basic Language&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;Kaleidoscope&lt;/code&gt;是一个过程语言. 它允许你定义函数, 使用条件分支, math, etc.&lt;/p&gt;

&lt;p&gt;在本tutorial中,  我们将会扩展Kaleidoscope来支持&lt;strong&gt;if/then/else 判断&lt;/strong&gt;, &lt;strong&gt;for循环&lt;/strong&gt;, &lt;strong&gt;用户自定义operators&lt;/strong&gt;, &lt;strong&gt;用一个简单的命令行接口的JIT 编译&lt;/strong&gt; , etc.&lt;/p&gt;

&lt;p&gt;因为我们都想要把事情做的简单. 所以in Kaleidoscope中, 唯一的数据类型是&lt;strong&gt;64-bit floating point type&lt;/strong&gt;. 因此, 所有的values都隐式地&lt;strong&gt;double&lt;/strong&gt;类型.&lt;/p&gt;

&lt;p&gt;下面是使用Kaleidoscope来计算Fibonacci numbers的一个simple example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//Compute the x&#39;th fibonacci number.
def fib(x)
    if x &amp;lt; 3 then 
        1
    else
        fib(x-1) + fib(x-2)

# This expression will compute the 40th number        
fib(40)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们也允许Kaleidoscope来调用标准库函数. 这意味着, 你可以在函数前面加关键字&amp;rdquo;&lt;strong&gt;extern&lt;/strong&gt;&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;For Example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;extern sin(arg);
extern cos(arg);
extern atan2(arg2, arg2);

atan2(sin(.4), cos(42))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第6章包含更有趣的例子, 我们使用Kaleidoscope写了一个小型应用 display a Mandelbrot Set at various levels of magnification.&lt;/p&gt;

&lt;p&gt;下面让我们探究Kaleidoscope的实现吧!!!.&lt;/p&gt;

&lt;h1 id=&#34;1-3-lexer&#34;&gt;1.3 Lexer&lt;/h1&gt;

&lt;p&gt;Token类型:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// The lexer returns tokens [0-255] if it is an unknown character, otherwise one
// of these for known things.
enum Token {
  tok_eof = -1,

  // commands
  tok_def = -2,
  tok_extern = -3,

  // primary
  tok_identifier = -4,
  tok_number = -5,
};

static std::string IdentifierStr; // Filled in if tok_identifier
static double NumVal;             // Filled in if tok_number
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从标准输入中返回next token&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// gettok - Return the next token from standard input.
static int gettok() {
  static int LastChar = &#39; &#39;;

  // Skip any whitespace.
  while (isspace(LastChar))
    LastChar = getchar();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;判断token是否为标识符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;if (isalpha(LastChar)) { // identifier: [a-zA-Z][a-zA-Z0-9]*
  IdentifierStr = LastChar;
  while (isalnum((LastChar = getchar())))
    IdentifierStr += LastChar;

  if (IdentifierStr == &amp;quot;def&amp;quot;)
    return tok_def;
  if (IdentifierStr == &amp;quot;extern&amp;quot;)
    return tok_extern;
  return tok_identifier;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;判断token是否为数字&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;if (isdigit(LastChar) || LastChar == &#39;.&#39;) {   // Number: [0-9.]+
  std::string NumStr;
  do {
    NumStr += LastChar;
    LastChar = getchar();
  } while (isdigit(LastChar) || LastChar == &#39;.&#39;);

  NumVal = strtod(NumStr.c_str(), 0);
  return tok_number;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;判断是否为注释&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;if (LastChar == &#39;#&#39;) {
  // Comment until end of line.
  do
    LastChar = getchar();
  while (LastChar != EOF &amp;amp;&amp;amp; LastChar != &#39;\n&#39; &amp;amp;&amp;amp; LastChar != &#39;\r&#39;);

  if (LastChar != EOF)
    return gettok();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是否文件末尾&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Check for end of file.  Don&#39;t eat the EOF.
if (LastChar == EOF)
      return tok_eof;

// Otherwise, just return the character as its ascii value.
int ThisChar = LastChar;
LastChar = getchar();
return ThisChar;
}
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>Static Single Assignment</title>
      <link>https://l0phtg.github.io/post/llvm/static-single-assignment/</link>
      <pubDate>Tue, 09 Apr 2019 21:54:49 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/llvm/static-single-assignment/</guid>
      
        <description>&lt;p&gt;translate from: &lt;a href=&#34;https://en.wikipedia.org/wiki/Static_single_assignment_form&#34;&gt;https://en.wikipedia.org/wiki/Static_single_assignment_form&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;单一变量赋值
&lt;img src=&#34;https://l0phtg.github.io/llvm/SSA_example1.2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;每个变量只被赋值一次.&lt;/p&gt;

&lt;p&gt;在编译器设计中, &lt;strong&gt;static single assigment form&lt;/strong&gt; (经常被称为&lt;strong&gt;SSA form&lt;/strong&gt; 或者 简化为 &lt;strong&gt;SSA&lt;/strong&gt;) 是IR的属性. 这要求每个变量只被assigment一次, 并且变量要在使用前定义. 原始IR中的已经存在的变量被划分为多个版本, 新的变量在文本中被显示为原始变量名称加下标的, 以便于每一个定义都有他们自己的版本.&lt;/p&gt;

&lt;h1 id=&#34;benefits&#34;&gt;Benefits&lt;/h1&gt;

&lt;p&gt;SSA的主要用途: 来自于它通过简化变量的属性来同时简化和改进各种编译器优化的结果.&lt;/p&gt;

&lt;p&gt;例如, 考虑这段代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;y := 1
y := 2
x := y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以一眼就看到第一行代码是不必要的, 第三行使用的y的值来自于第二行y的赋值. 一个程序必须执行 &lt;strong&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Reaching_definition&#34;&gt;reaching definition analysis&lt;/a&gt;&lt;/strong&gt; to 决定这个. 但是如果一个程序是SSA形式, 这些都是直接的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;y1 := 1
y2 := 2
x1 := y2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过SSA的包含使用, &lt;a href=&#34;https://en.wikipedia.org/wiki/Optimizing_compiler&#34;&gt;编译器优化&lt;/a&gt;
算法增强了很多:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Constant propagation 常量传播&lt;/li&gt;
&lt;li&gt;Value range propagation&lt;/li&gt;
&lt;li&gt;Sparse conditional constant propagation&lt;/li&gt;
&lt;li&gt;Dead code elimination&lt;/li&gt;
&lt;li&gt;Global value numbering          全局值编号&lt;/li&gt;
&lt;li&gt;Partial redundancy elimination  部分冗余代码消除&lt;/li&gt;
&lt;li&gt;Strength reduction&lt;/li&gt;
&lt;li&gt;Register allocation&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;converting-to-ssa&#34;&gt;Converting to SSA&lt;/h1&gt;

&lt;p&gt;将普通代码转换为SSA形式主要是通过&lt;strong&gt;使用新变量替换每个赋值的目标&lt;/strong&gt;.
and replacing each use of a variable with the &amp;ldquo;version&amp;rdquo; of the variable reaching that point.&lt;/p&gt;

&lt;p&gt;例如, consider the following &lt;a href=&#34;https://en.wikipedia.org/wiki/Control-flow_graph&#34;&gt;control flow graph&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/llvm/SSA_example1.1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;更改 &amp;ldquo;x -&amp;gt; x - 3&amp;rdquo; 左侧的名称, 并将之后对x的使用更改为新名称将使程序保持不变. 这可以通过在ssa中创建两个新的变量: x1 and x2 来利用, 每个变量只被分配一次. 同样, 给所有其他的变量也赋予不一样的下标.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/llvm/ssa-example1.2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;每一个使用都是很清楚的, 除了&lt;strong&gt;one case: 在底部block中,$\bold{y}$的使用应该是$\bold{y_1}$还是$\bold{y_2}$呢?&lt;/strong&gt; 取决于控制流的path.&lt;/p&gt;

&lt;p&gt;为了解决这个问题&lt;/p&gt;

&lt;p&gt;在最后的块中插入了一个特殊语句$\bold{\phi(phi)} $  函数. 这个表达式将会产生$\bold{y}$的新的定义, 通过选择$\bold{ y_1}$或者$\bold{y_2}$(取决于过去的控制流).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/llvm/ssa-example1.3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在, 最后一个块可以轻松使用$\bold{y_3}$ , 并且可以获得正确的值. 一个$\bold{\phi}$ 函数 for $\bold{x}$ 是不必要的: 因为只有一个$\bold{x}$ 的版本. （换句话说: $\bold{\phi(x_2, x_2) = x_2}$ 是不必要的.&lt;/p&gt;

&lt;p&gt;给定任意一个控制流图, 很难说出&lt;strong&gt;哪里需要插入 $\bold{\phi}$函数, and for which variables&lt;/strong&gt; .&lt;/p&gt;

&lt;p&gt;这个普遍的问题有一个有效的解决方案: &lt;strong&gt;dominance frontiers(支配边界)&lt;/strong&gt; . (see below)&lt;/p&gt;

&lt;p&gt;在大多数机器上: $\bold{\phi}$函数都没有被实现作为一个机器操作.&lt;/p&gt;

&lt;p&gt;编译器只需在存储器(或者相同的寄存器)中即可轻松地实现$\bold{\phi}$ 函数.  (存储器或寄存器作为一个$\bold{\phi}$函数输入的任何操作的目的地).  然而, 当simultaneous operations are speculatively producing inputs to a $\bold{\phi}$ 函数(就像很多机器上发生的那样), 该方法就不起作用了.&lt;/p&gt;

&lt;p&gt;通常, 大多数机器都有一个选择指令被用于该情况中, 这可以被我们的编译器用于实现$\bold{\phi}$函数.&lt;/p&gt;

&lt;p&gt;根据 Kenny Zadeck , $\bold{\phi}$ 函数最初被称为phony functions. 正式的名字是在学术paper上第一次发表时引入的.&lt;/p&gt;

&lt;h2 id=&#34;computing-minimal-ssa-using-dominance-frontiers-使用dominance边界计算最小的ssa&#34;&gt;computing minimal SSA using dominance frontiers(使用dominance边界计算最小的SSA)&lt;/h2&gt;

&lt;p&gt;首先, 我们需要了解&lt;strong&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Dominator_(graph_theory)&#34;&gt;dominator&lt;/a&gt;&lt;/strong&gt;的概念: 如果&lt;strong&gt;不先经过节点 A 就到不了节点 B&lt;/strong&gt;, 我们就称节点 A 在控制流中严格支配节点 B. 这很有用, 因为如果我们已经到达节点 B , 就证明 A 中的代码也都正在工作. 如果 &lt;strong&gt;A 严格支配 B&lt;/strong&gt; 或者 A = B, 我们就说 A dominates B ( 或者 B is dominated by A)&lt;/p&gt;

&lt;p&gt;现在, 我们可以定义 the &lt;strong&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Dominator_(graph_theory)&#34;&gt;dominance frontier&lt;/a&gt;&lt;/strong&gt; : 如果节点 A 不严格支配节点 B, 但是支配了一些 B的前面节点(predecessor), 就称为节点 B 在节点 A 的*dominace frontier*中. ( 可能节点 A 是 节点 B 的直接前节点. 然后, 因为任何节点都 &lt;em&gt;dominates&lt;/em&gt; 它自身, 并且节点 A &lt;em&gt;dominates&lt;/em&gt; 它自身, 所以节点 B 是处于节点 A的支配边界).&lt;/p&gt;

&lt;p&gt;从 A 的角度看, 那是在其他控制路径上不经过A的 最早出现的节点.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Dominance frontiers&lt;/em&gt; 可以精准地确定我们需要$\bold{\phi}$ 函数的地方:  如果节点A定义了某个变量, then that definition and that definition alone (or redefinitions) will reach every node A dominates. 只有当我们离开这些节点并进入&lt;em&gt;dominance frontiers&lt;/em&gt; 时,我们必须考虑其他流是否引入了相同变量的另外一个定义.此外, 控制流图中不需要处理其他 $\bold{\phi}$ 函数, 我们可以做到 no less.&lt;/p&gt;

&lt;p&gt;一个算法可以用来计算&lt;em&gt;dominance frontier set&lt;/em&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for each node b
   dominance_frontier(b) := {}
for each node b
    if the number of immediate predecessors of b ≥ 2
        for each p in immediate predecessors of b
            runner := p
            while runner ≠ idom(b)
                dominance_frontier(runner) := dominance_frontier(runner) ∪ { b }
                runner := idom(runner)
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>Dominator(graph Theory)</title>
      <link>https://l0phtg.github.io/post/dominatorgraph-theory/</link>
      <pubDate>Sat, 06 Apr 2019 18:00:53 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/dominatorgraph-theory/</guid>
      
        <description>&lt;p&gt;translate from : &lt;a href=&#34;https://en.wikipedia.org/wiki/Dominator_(graph_theory)&#34;&gt;https://en.wikipedia.org/wiki/Dominator_(graph_theory)&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;最近在学习SSA(Static Single Assignment)时, 遇到了${dominance frontier}$的概念, 所以google之, 简单翻译了一下wikipedia上对Dominator内容的介绍.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;dominator-graph-theory&#34;&gt;Dominator (graph theory)&lt;/h1&gt;

&lt;p&gt;在计算机科学中, 在控制流图中, 如果从入口点到节点 $\bold{n}$ 的每条路径都经过节点 $\bold{d}$, 则称节点 $\bold{d}$ dominates 节点 $\bold{n}$&lt;/p&gt;

&lt;p&gt;被写作 $\bold{d}$ dom $\bold{n}$ (or $\bold{d} \gg \bold {n}$).&lt;/p&gt;

&lt;p&gt;另外我们定义, 每个节点都 dominates 它自身.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/llvm/300px-Dominator_control_flow_graph.svg.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这里有一些相关的概念:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;节点 $\bold{d}$ &lt;em&gt;strictly dominates&lt;/em&gt; (严格支配) 节点 $\bold {n} $ : $\bold{d}$ dominates $\bold{n}$ 并且 $\bold{d} $ 与 $\bold{n}$ 不相等.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;节点 $\bold{n}$ 的 &lt;em&gt;immediate dominator&lt;/em&gt; (直接支配者) or &lt;strong&gt;idom&lt;/strong&gt; : 一个节点严格支配 $\bold{n}$ 但是不严格支配其他严格支配$\bold{n}$ 的节点. 除了入口点之外, 每一个节点都有一个直接支配者.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;节点 $\bold{d}$ 的 &lt;em&gt;dominance frontier&lt;/em&gt; :  所有节点$\bold{n}$ 的集合, 使得 $\bold{d}$ 支配 $\bold{n}$ 的 immediate predecessor. 但是 $\bold{d} $ 不严格支配节点 $\bold{n}$ . 这是一组 $\bold{d&amp;rsquo;s}$ dominance 停止的节点集合.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一个 &lt;em&gt;dominator tree&lt;/em&gt; : 一颗树, 这棵树每个节点的子节点是它直接支配的节点. 因为直接支配者是独一无二的, 所以它是一棵树. 开始节点是树的根节点.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;$\color{black}{dom}$&lt;/th&gt;
&lt;th&gt;$\color{Gray}{1}$&lt;/th&gt;
&lt;th&gt;$\color{Red}{2}$&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;$\color{black}{dom}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$\color{Gray}{2}$&lt;/td&gt;
&lt;td&gt;$\color{Red}{3}$&lt;/td&gt;
&lt;td&gt;$\color{Red}{4}$&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;$\color{Red}{6}$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;$\color{black}{dom}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$\color{Gray}{3}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;$\color{black}{dom}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$\color{Gray}{4}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;$\color{black}{dom}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$\color{Gray}{5}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;$\color{black}{dom}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$\color{Gray}{6}$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;与 domination关系相对应&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$灰色的节点\color{Gray}{灰色的节点}$ 是 非严格 dominated&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$红色的节点\color{Red}{红色的节点}$ 是 直接 dominated&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;dominator tree:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/llvm/300px-Dominator_tree.svg.png&#34; alt=&#34;dominator tree&#34; /&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>如果你冲动删除了python</title>
      <link>https://l0phtg.github.io/post/%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%86%B2%E5%8A%A8%E5%88%A0%E9%99%A4%E4%BA%86python/</link>
      <pubDate>Tue, 02 Apr 2019 21:12:17 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%86%B2%E5%8A%A8%E5%88%A0%E9%99%A4%E4%BA%86python/</guid>
      
        <description>&lt;p&gt;在你经历了痛苦的pip安装, 各种报错之后. 一气之前, 你决定卸载python, 重新安装. 那么, 既然要卸载, 就要卸载的彻底!&lt;/p&gt;

&lt;p&gt;所以你输入了下面的几行命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#hahaha
$sudo apt remove python
$sudo apt remove python3
$sudo apt remove pip
$sudo apt remove pip3
#一定删除的不彻底, 我要彻底删除
$sudo apt autoremove -f 
看到要删除600+M, 毅然决然的按了 y.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;Bingo 然后你看到了我这篇文章.
&lt;/p&gt;

&lt;h1 id=&#34;一-基础知识&#34;&gt;一、基础知识&lt;/h1&gt;

&lt;h2 id=&#34;1-重新安装python和pip&#34;&gt;1. 重新安装python和pip&lt;/h2&gt;

&lt;h3 id=&#34;1-1-安装python&#34;&gt;1.1 安装python&lt;/h3&gt;

&lt;p&gt;由于ubuntu16.04默认安装的python版本是 &lt;strong&gt;python2.7&lt;/strong&gt;  和 &lt;strong&gt;python3.5&lt;/strong&gt; .&lt;/p&gt;

&lt;p&gt;所以&lt;strong&gt;为了满足系统的需要&lt;/strong&gt;, 我们&lt;strong&gt;需要重新安装python2.7 和 python3.5&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;安装方式很简单:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#安装python2.7和python3.5
$sudo apt install python  # 默认安装的python2.7
$sudo apt install python3 # 默认安装的python3.5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除此之外, 我们还需要安装一些&lt;strong&gt;python的dev库&lt;/strong&gt; ,  因为系统和很多软件运行时都依赖它(这也是我们删除python 并 autoremove后, 发现系统gg的一部分原因)&lt;/p&gt;

&lt;p&gt;安装方式同样很简单:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#安装dev库
$sudo apt install libpython2.7 libpython2.7-dev
$sudo apt install libpython3.5 libpython3.5-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: 虽然系统的apt源不直接提供python3.6以及更高版本的python程序. 但是&lt;strong&gt;提供了python全版本的libdev库&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;所以, 如果你想要安装&lt;strong&gt;libpython3.6&lt;/strong&gt;的话, 也是可以的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#安装python3.6的dev库
$sudo apt install libpython3.6 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是如果想要安装&lt;strong&gt;python3.6&lt;/strong&gt;及以上的包, 该怎么办呢?&lt;/p&gt;

&lt;p&gt;方法有很多, 这里推荐&lt;strong&gt;源安装的方式&lt;/strong&gt; :&lt;/p&gt;

&lt;p&gt;可以参考(&lt;a href=&#34;https://linuxize.com/post/how-to-install-python-3-7-on-ubuntu-18-04/&#34;&gt;https://linuxize.com/post/how-to-install-python-3-7-on-ubuntu-18-04/&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;具体操作:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 安装python3.6 above
$sudo apt update
$sudo apt install software-properties-common

$sudo add-apt-repository ppa:deadsnakes/ppa   #加入python源, 并按[enter]确认

$sudo apt update      # 之后重新更新我们的源库

# 现在就可以安装python的其他版本了
$sudo apt install python3.6       # 例如你想安装python3.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/life/python-install.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;1-2-安装pip&#34;&gt;1.2 安装pip&lt;/h3&gt;

&lt;p&gt;安装pip, 这里只推荐一种方式:&lt;/p&gt;

&lt;p&gt;参照官方安装文档: &lt;a href=&#34;https://pip.pypa.io/en/stable/installing/&#34;&gt;https://pip.pypa.io/en/stable/installing/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首先, 下载&lt;strong&gt;get-pip.py&lt;/strong&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#使用curl命令(如果未安装, 先{sudo apt install curl}) 来下载get-pip.py  
$curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py # 下载get-pip.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后, 安装&lt;strong&gt;你需要的pip版本&lt;/strong&gt; , (注意: 这里有&lt;strong&gt;全局安装&lt;/strong&gt;和&lt;strong&gt;user安装&lt;/strong&gt; 两种方式) :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#安装pip3.6
$ sudo python3.6 get-pip.py    # 全局安装

$ python3.6 get-pip.py --user  # user安装
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-pip使用&#34;&gt;2. pip使用&lt;/h2&gt;

&lt;h3 id=&#34;2-1-全局安装package和user安装package&#34;&gt;2.1 全局安装package和user安装package&lt;/h3&gt;

&lt;p&gt;我们在使用pip 安装 &lt;strong&gt;package&lt;/strong&gt; 时, 有两种选择:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;全局安装&lt;/strong&gt; package, 对所有系统用户生效&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; 
$sudo pip2.7 install {package}   # python2.7使用pip2.7安装package 
$sudo pip3.5 install {package}   # python3.5使用pip3.5安装package 
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;user安装&lt;/strong&gt; package, 只对user(当前用户生效)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#
$pip2.7 install --user {package} 
$pip3.5 install --user {package}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相信&lt;strong&gt;sudo&lt;/strong&gt;和&lt;strong&gt;&amp;ndash;user&lt;/strong&gt;大家一眼就可以看到.&lt;/p&gt;

&lt;p&gt;那么除了这两个地方的不同, 还有哪些不同值得我们了解的呢?&lt;/p&gt;

&lt;h3 id=&#34;2-2-两种安装package方式的不同&#34;&gt;2.2 两种安装package方式的不同&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;dist-packages&lt;/strong&gt; : 这是我们package安装后的存放目录.&lt;/p&gt;

&lt;p&gt;肯定地, &lt;strong&gt;全局安装&lt;/strong&gt;和 &lt;strong&gt;user安装&lt;/strong&gt; 的&lt;strong&gt;package存放路径是不同的&lt;/strong&gt; .&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;全局安装&lt;/strong&gt;时的&lt;strong&gt;package存放路径&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 
$sudo pip3.6 --version
pip 19.0.3 from /usr/local/lib/python3.6/dist-packages/pip (python 3.6)
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;user安装&lt;/strong&gt;时的&lt;strong&gt;package存放路径&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#
$ pwd             # 查看当前绝对路径
/home/l0phtg

$ pip3.6 install --user neovim  # 注意这里显示的路径是相对路径
Requirement already satisfied: neovim in ./.local/lib/python3.6/site-packages (0.3.1)
Requirement already satisfied: pynvim&amp;gt;=0.3.1 in ./.local/lib/python3.6/site-packages (from neovim) (0.3.2)
Requirement already satisfied: msgpack&amp;gt;=0.5.0 in ./.local/lib/python3.6/site-packages (from pynvim&amp;gt;=0.3.1-&amp;gt;neovim) (0.6.1)
Requirement already satisfied: greenlet in ./.local/lib/python3.6/site-packages (from pynvim&amp;gt;=0.3.1-&amp;gt;neovim) (0.4.15)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即&lt;strong&gt;user安装python3.6的package时&lt;/strong&gt;, package 默认存放在了 &lt;strong&gt;~/.local/lib/python3.6/site-packages&lt;/strong&gt; .路径下.&lt;/p&gt;

&lt;h1 id=&#34;二-安装被你意外删掉的库&#34;&gt;二、 安装被你意外删掉的库&lt;/h1&gt;

&lt;p&gt;在安装了前面所需的python2.7, python3.5, pip2.7, pip3.5, libpython2.7,  libpython2.7-dev, libpython3.5, libpython3.5-dev 之后, 你需要安装ubuntu系统的一些库.&lt;/p&gt;

&lt;p&gt;ubuntu系统所需的库为&lt;strong&gt;ubuntu-minimal, ubuntu-standard, ubuntu-desktop&lt;/strong&gt; .&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$sudo apt install ubuntu-minimal ubuntu-standard ubuntu-desktop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时, 系统就已经可以&lt;strong&gt;正常启动, 并正常进入和显示桌面&lt;/strong&gt; 了.&lt;/p&gt;

&lt;p&gt;最后,  因为你的操作, 可能导致&lt;strong&gt;一些三方应用不能启动&lt;/strong&gt; , 这时你只能自行重装了.&lt;/p&gt;

&lt;p&gt;我这里已经知道的影响到的三方软件为: Chrome浏览器, wps.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>本科应届生安全岗面试总结</title>
      <link>https://l0phtg.github.io/post/%E6%9C%AC%E7%A7%91%E5%BA%94%E5%B1%8A%E7%94%9F%E5%AE%89%E5%85%A8%E5%B2%97%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 02 Apr 2019 11:24:31 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/%E6%9C%AC%E7%A7%91%E5%BA%94%E5%B1%8A%E7%94%9F%E5%AE%89%E5%85%A8%E5%B2%97%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</guid>
      
        <description>&lt;p&gt;很久没有更新博客了, 主要原因是因为现在笔记都记在了有道云笔记中. 并且 很多篇文章都只写了一半, 也不想发出来.&lt;/p&gt;

&lt;p&gt;近期时间充裕, 应该会保持每周一更, 将以前写的或者近期学到的知识总结一下发在博客里.&lt;/p&gt;

&lt;p&gt;本篇文章是19年春节写的, 主要记录了自己在18年的几次面试记录, 和大学期间的一些学习经历.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;个人简介&#34;&gt;个人简介&lt;/h1&gt;

&lt;p&gt;L0phTg&lt;/p&gt;

&lt;p&gt;学习方向: 二进制, 移动安全.&lt;/p&gt;

&lt;p&gt;专业: 信息安全.&lt;/p&gt;

&lt;p&gt;签约: xiaojukeji.&lt;/p&gt;

&lt;h2 id=&#34;学习经历&#34;&gt;学习经历&lt;/h2&gt;

&lt;h3 id=&#34;大一&#34;&gt;大一&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;在未加入实验室之前, 我处于&amp;rdquo;野生, 放养&amp;rdquo;的状态
(就是没有目的的学习, 乱七八糟买了很多计算机类的书, 应该大多数人都经历过这个阶段, 其实在这个阶段就是要多了解熟悉各个计算机专业方向, 所以也没有必要一直苦恼, 分清主次, 打好基础就对了.)&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;大一主要学习了一段时间c/c++,( 此处推荐  &lt;code&gt;&amp;lt;&amp;lt; c语言程序设计现代方法&amp;gt;&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;&amp;lt; c++Primer&amp;gt;&amp;gt;&lt;/code&gt; ). 由于当时看到很多人推荐 &lt;code&gt;&amp;lt;&amp;lt;深入理解计算机系统&amp;gt;&amp;gt;&lt;/code&gt;, 所以耐不住诱惑, 就买了一本来看, 我的汇编知识最初就是在这本书上看到的.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当然其实大一虽然没有过多接触信息安全领域的专业知识, 但是由于一直在微博, 知乎关注着很多安全届大佬, 对安全领域也有了基本的概念与印象, 知道安全基本分为web和二进制等之类, 也了解到安全届有heige和tk两位妇科圣手, 这些多少都给无聊的大学生活增添了许多乐趣.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;关于安全学习的方向其实确定起来不是那么容易的, 最初了解到的是余弦、heige，所以多少想从事web安全领域. 但是在最终确定学习方向的时候, 还是考虑了自己的实际情况, 自身学习路线与兴趣爱好.  在大一暑假, 总结了一下自己大一看过的书有关于c/c++的, 汇编的, 和w32的, 以及阅读了 &lt;code&gt;&amp;lt;&amp;lt;加密与解密&amp;gt;&amp;gt;&lt;/code&gt;, 而且熟悉了linux下的基本操作. 至于web方向的试探, 只是停留在w3c上看过一点h5. 所以, 理所当然的就决定了之后走二进制这条路线.(方向领域的确定还是要根据自己实际情况考虑, 如果不考研, 且决定大三要找工作的话)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;移动安全领域入门, 是在大二, 至于是发生了什么导致自己想要向android安全靠拢的, 保密.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;大二&#34;&gt;大二&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;大二在历经艰辛进入实验室后, 生活就比较顺风顺水了, 就抱着一本 &lt;code&gt;&amp;lt;&amp;lt; android软件安全与逆向分析&amp;gt;&amp;gt;&lt;/code&gt;看了一个学期, 大二上就是这么过的.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;大二下主要是接触了一些android逆向与脱壳, 跟着f8left的视频, 自己尝试着去调试.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;大二暑期尝试去绿盟实习, 无奈面试失败. (失败+1)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;大三&#34;&gt;大三&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;大三由于面临着找工作这个大难题, 所以想着做些什么能够让自己的简历有亮眼之处. 所以就想着写些项目.
所以大三上和寒假就一直在coding. 主要写了两个项目: 一个ptrace相关, 一个arm相关.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;大三下就是春招， 阿里腾讯面试失败. (失败+2)  (面试失败对自己的打击是很大的, 所以失败后自己也在反思总结, 然后期待之后的公司面试能够顺利通过, 具体面试体验等看下一部分)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;之后面试小米. (成功+1) 面试小米成功之后, 就直接去了小米实习, 几个月的实习生活中, 学习到了很多. (具体看之后的实习经历)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;大四&#34;&gt;大四&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;大四秋招.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;我的面试经历其实并不顺畅, 但是之后的内容不会写的太具体, 只写一些主要的, 希望对大家有所帮助.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;拿到offer之后. 追剧, 玩游戏, 看直播&amp;hellip;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;面试准备&#34;&gt;面试准备&lt;/h1&gt;

&lt;p&gt;其实面试的准备内容是根据自己的面试岗位变化的. 例如游戏安全偏c/c++, app安全可能会涉及java. 但是自己擅长的一定要多做准备. 可以根据每次面试自己的发挥, 以及面试官的提问重点, 来针对性的复习和学习.&lt;/p&gt;

&lt;p&gt;移动安全岗位问到的相关内容包括(简历上写的基本都可能会问到):
c/c++,
java,
smali,
android逆向,
简单数据结构和算法,
简单加密算法, 分组加密的模式
hook等.&lt;/p&gt;

&lt;h1 id=&#34;面试经历&#34;&gt;面试经历&lt;/h1&gt;

&lt;h2 id=&#34;春招&#34;&gt;春招&lt;/h2&gt;

&lt;p&gt;春招印象最深的是腾讯的几次面试:&lt;/p&gt;

&lt;p&gt;第一次面的是tx游戏安全, 由于自己当时对hook没有了解, 并且在最后回答c++方向的问题时, 表现不好, 所以gg. ( 但是这次面试失败后, 就疯狂恶补了hook方向的内容. 这也使得自己在秋招面试一些公司时, 得以不在hook方向被打出gg)&lt;/p&gt;

&lt;p&gt;还有一次也是tx的另一个二进制部门, 面试失败的原因, 我归结为自己没有对一些安全知识做过总结. 所以在面试时, 发挥不好. (经常性的总结自己学过的知识, 是挺重要的. 这次面试失败之后, 就开了个有道云笔记会员, 硬广一波, 主要优势 跨平台. hhhhaaa.)&lt;/p&gt;

&lt;p&gt;小米面试, 是我春招的结尾, 一周面了三面技术面, 体验最好.
一面组长面, 对我写的一个项目问了有40min, 注意, 一个项目, 问到我怀疑人生. 二面: 智力面? 问了几个算法, 回答的一般, 但还是挺过去了. 终面(boss面): 自己在经历过春招的几场面试失败后, 对android安全做了一些系统的总结. 所以boss在问到对android安全的认识和了解的时候, 以及linker模块的时候,  把自己系统总结过的表达出来, 就通过面试了.&lt;/p&gt;

&lt;h2 id=&#34;秋招&#34;&gt;秋招&lt;/h2&gt;

&lt;p&gt;在经历过春招之后, 秋招相对来说轻松一些. 因为自己相对来说有了更多的经验, 也基本不会惨死在基础知识上(但还是有), 就算参加有些公司的面试, 即使失败了, 也没有那么多的抱怨和后悔.&lt;/p&gt;

&lt;h2 id=&#34;实习经历&#34;&gt;实习经历&lt;/h2&gt;

&lt;p&gt;实习时间(2018-4-15~~2018-8.30).&lt;/p&gt;

&lt;p&gt;实习单位: 小米MIUI系统组.&lt;/p&gt;

&lt;p&gt;在小米实习的日子, 是非常开心快乐的, 我也慢慢地从一个路人变成了一个米粉. 在实习期间, 学习到了很多:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;刷机.&lt;/li&gt;
&lt;li&gt;gdb调试android系统和应用.&lt;/li&gt;
&lt;li&gt;对android底层的art虚拟机有了一定的了解.&lt;/li&gt;
&lt;li&gt;method hook.&lt;/li&gt;
&lt;li&gt;总结了很多android加固方法.&lt;/li&gt;
&lt;li&gt;实现了一个加固demo.&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>我的zsh和vim配置</title>
      <link>https://l0phtg.github.io/post/%E6%88%91%E7%9A%84zsh%E5%92%8Cvim%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Wed, 24 Oct 2018 00:14:31 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/%E6%88%91%E7%9A%84zsh%E5%92%8Cvim%E9%85%8D%E7%BD%AE/</guid>
      
        <description>&lt;p&gt;总结了一下自己的vim配置和zsh配置&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/customConfig/myVimPreview.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;zsh配置&#34;&gt;zsh配置&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/robbyrussell/oh-my-zsh&#34;&gt;https://github.com/robbyrussell/oh-my-zsh&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;powerline字体设置&#34;&gt;powerline字体设置&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://dwijaybane.wordpress.com/2017/12/04/oh-my-zsh-and-powerline-fonts-setup-for-awesome-terminal-in-ubuntu-16-04/&#34;&gt;https://dwijaybane.wordpress.com/2017/12/04/oh-my-zsh-and-powerline-fonts-setup-for-awesome-terminal-in-ubuntu-16-04/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;我的插件&#34;&gt;我的插件&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;plugins=(git autojump web-search last-working-dir zsh-syntax-highlighting colored-man-pages extract zsh-proxychains-ng adb pip npm python)
#plugins=(git autojump last-working-dir adb pip npm python)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;vim配置&#34;&gt;vim配置&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;当你使用&lt;code&gt;vim&lt;/code&gt;时, 可以在&lt;code&gt;~/.vimrc&lt;/code&gt;中编写你的vim配置文件.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当你使用&lt;code&gt;neovim&lt;/code&gt;时, 可以在&lt;code&gt;~/.config/nvim/init.vim&lt;/code&gt;中编写你的vim配置文件.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;插件&#34;&gt;插件&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;插件管理&lt;code&gt;vim-plug&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;tagbar&lt;/li&gt;
&lt;li&gt;airline&lt;/li&gt;
&lt;li&gt;vimfilter&lt;/li&gt;
&lt;li&gt;vim-bufabline buffer窗口&lt;/li&gt;
&lt;li&gt;fzf和ag 搜索&lt;/li&gt;
&lt;li&gt;括号补全&amp;rsquo;Raimondi/delimitMate&amp;rsquo;&lt;/li&gt;
&lt;li&gt;include补全 neoinclude&lt;/li&gt;
&lt;li&gt;语法补全jedi-vim(python)&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;vim-plug-vim插件管理工具&#34;&gt;&lt;code&gt;vim-plug&lt;/code&gt; vim插件管理工具&lt;/h4&gt;

&lt;p&gt;README: &lt;a href=&#34;https://github.com/junegunn/vim-plug&#34;&gt;https://github.com/junegunn/vim-plug&lt;/a&gt;.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;安装&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;a. 当你使用&lt;code&gt;vim&lt;/code&gt;时.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -fLo ~/.vim/autoload/plug.vim --create-dirs \
    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;b. 当你使用`neovim时.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -fLo ~/.local/share/nvim/site/autoload/plug.vim --create-dirs \
    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;使用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;a. 可以使用git链接&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Plug &#39;https://github.com/junegunn/vim-github-dashboard.git&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;b. 使用git&lt;code&gt;UserName/Project&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Plug &#39;junegunn/vim-easy-align&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多可以参考文档.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;安装插件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;只是把要安装的插件写在配置文件中是不够的, 还需要安装.&lt;/p&gt;

&lt;p&gt;写好配置文件后, 重新打开vim, 运行&lt;code&gt;PlugInstall&lt;/code&gt;.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;例子:(我的部分配置)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;call plug#begin()

Plug &#39;NLKNguyen/papercolor-theme&#39;
Plug &#39;vim-airline/vim-airline&#39;
Plug &#39;vim-airline/vim-airline-themes&#39;
Plug &#39;Shougo/denite.nvim&#39;
Plug &#39;Shougo/unite.vim&#39;
Plug &#39;Shougo/vimfiler&#39;
Plug &#39;majutsushi/tagbar&#39;
Plug &#39;ap/vim-buftabline&#39;
Plug &#39;Shougo/deoplete.nvim&#39;, { &#39;do&#39;: &#39;:UpdateRemotePlugins&#39; }
Plug &#39;rip-rip/clang_complete&#39;
Plug &#39;SirVer/ultisnips&#39;           &amp;quot; 代码片段补全  模板补全
Plug &#39;honza/vim-snippets&#39;
Plug &#39;zchee/deoplete-jedi&#39;

Plug &#39;scrooloose/nerdcommenter&#39;   &amp;quot; 自动注释   &amp;lt;leader&amp;gt;cc  注释当先选中文本  
Plug &#39;ctrlpvim/ctrlp.vim&#39;

Plug &#39;lvht/tagbar-markdown&#39;       &amp;quot; markdown  tagbar显示

Plug &#39;~/.fzf&#39;
Plug &#39;junegunn/fzf.vim&#39;

call plug#end()
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;tagbar&#34;&gt;&lt;code&gt;tagbar&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;README: &lt;a href=&#34;https://github.com/majutsushi/tagbar&#34;&gt;https://github.com/majutsushi/tagbar&lt;/a&gt;.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;安装&lt;code&gt;ctags&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;$sudo apt install ctags
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;vim中配置&lt;code&gt;tagbar&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;call plug#begin()
Plug &#39;majutsushi/tagbar&#39;
call plug#end()

let g:tagbar_width=30
let g:tagbar_left=1

&amp;quot;映射F2快捷键为打开tagbar
nnoremap &amp;lt;F2&amp;gt; :TagbarToggle &amp;lt;CR&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;airline-主题&#34;&gt;&lt;code&gt;airline&lt;/code&gt; 主题&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/vim-airline/vim-airline&#34;&gt;https://github.com/vim-airline/vim-airline&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;call plug#begin()

Plug &#39;NLKNguyen/papercolor-theme&#39;           // 这是我自己的主题
Plug &#39;vim-airline/vim-airline&#39;
Plug &#39;vim-airline/vim-airline-themes&#39;

call plug#end()

let g:airline_theme=&#39;papercolor&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;vimfilter-文件树&#34;&gt;&lt;code&gt;vimfilter&lt;/code&gt; 文件树&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;call plug#begin()
Plug &#39;Shougo/vimfiler&#39;
call plug#end()

&amp;quot;我设置的打开vimfilter的对应快捷键为F3
nnoremap &amp;lt;F3&amp;gt; :VimFilerExplorer -split -direction=rightbelow &amp;lt;CR&amp;gt;          
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;vim-bufabline-buffer窗口&#34;&gt;&lt;code&gt;vim-bufabline&lt;/code&gt; buffer窗口&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;call plug#begin()
Plug &#39;ap/vim-buftabline&#39;
call plug#end()

&amp;quot;映射对应的快捷键为打开对应的buffer
nmap &amp;lt;leader&amp;gt;1 &amp;lt;Plug&amp;gt;BufTabLine.Go(1)
nmap &amp;lt;leader&amp;gt;2 &amp;lt;Plug&amp;gt;BufTabLine.Go(2)
nmap &amp;lt;leader&amp;gt;3 &amp;lt;Plug&amp;gt;BufTabLine.Go(3)
nmap &amp;lt;leader&amp;gt;4 &amp;lt;Plug&amp;gt;BufTabLine.Go(4)
nmap &amp;lt;leader&amp;gt;5 &amp;lt;Plug&amp;gt;BufTabLine.Go(5)
nmap &amp;lt;leader&amp;gt;6 &amp;lt;Plug&amp;gt;BufTabLine.Go(6)
nmap &amp;lt;leader&amp;gt;7 &amp;lt;Plug&amp;gt;BufTabLine.Go(7)
nmap &amp;lt;leader&amp;gt;8 &amp;lt;Plug&amp;gt;BufTabLine.Go(8)
nmap &amp;lt;leader&amp;gt;9 &amp;lt;Plug&amp;gt;BufTabLine.Go(9)
nmap &amp;lt;leader&amp;gt;0 &amp;lt;Plug&amp;gt;BufTabLine.Go(10)

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;fzf-和-ag&#34;&gt;fzf 和 ag&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/customConfig/fileContentSearch.png&#34; alt=&#34;目录下的全部文件内容搜索&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;下载安装fzf&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf
~/.fzf/install
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;vim 中配置fzf&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;插件使用&lt;code&gt;vim-plug&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Plug &#39;~/.fzf&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;ag安装&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ubuntu&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$sudo apt-get install silversearcher-ag
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;快捷键映射&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在我的vim中, &lt;leader&gt;映射为了&lt;code&gt;space&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;noremap &amp;lt;leader&amp;gt;sff :Files&amp;lt;CR&amp;gt;
noremap &amp;lt;leader&amp;gt;ssf :Lines&amp;lt;CR&amp;gt;
noremap &amp;lt;leader&amp;gt;sbf :BLines&amp;lt;CR&amp;gt; 
noremap &amp;lt;leader&amp;gt;ss  :Ag&amp;lt;CR&amp;gt;

noremap &amp;lt;leader&amp;gt;gls :GFiles&amp;lt;CR&amp;gt;
noremap &amp;lt;leader&amp;gt;gss :GFiles?&amp;lt;CR&amp;gt;   

noremap &amp;lt;leader&amp;gt;btag :Tags&amp;lt;CR&amp;gt;
noremap &amp;lt;leader&amp;gt;stag :BTags&amp;lt;CR&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;使用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;:BTags&lt;/code&gt; 可以在当前目录下build tags, &lt;code&gt;前提系统已经ctags&lt;/code&gt;(apt install ctags)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;:Tags&lt;/code&gt; 可以搜索tag. 在搜索前, 要先build tags. (可以自行阅读fzf doc, 应该可以在vim启动时自动build tags).&lt;/p&gt;

&lt;p&gt;当前文件内容搜索:
&lt;img src=&#34;https://l0phtg.github.io/customConfig/singleFileContentSearch.png&#34; alt=&#34;当前文件内容搜索&#34; /&gt;
当前目录的文件搜索:
&lt;img src=&#34;https://l0phtg.github.io/customConfig/searchFile.png&#34; alt=&#34;当前目录的文件搜索&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;括号补全-raimondi-delimitmate&#34;&gt;括号补全&amp;rsquo;Raimondi/delimitMate&amp;rsquo;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;call plug#begin()
Plug &#39;Raimondi/delimitMate&#39;       &amp;quot; 补全, \&amp;quot; \( 等.
call plug#end()
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;c-c-llvm头文件补全-neoinclude&#34;&gt;c/c++/llvm头文件补全 neoinclude&lt;/h4&gt;

&lt;p&gt;头文件补全需要设置头文件path, (&lt;strong&gt;注意, 是vim配置文件中的path, 而不是系统环境变量的path&lt;/strong&gt;)&lt;/p&gt;

&lt;p&gt;我使用的是nvim, 配置文件是~/config/nvim/init.vim&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot; ~/.config/nvim/init.vim

set path=.,/usr/include/c++/5,/usr/include,/home/l0phtg/tools/llvm-project/llvm/include

call plug#begin()
Plug &#39;Shougo/neoinclude.vim&#39;
call plug#end()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;我的配置&#34;&gt;我的配置&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;set nu

let mapleader= &#39; &#39;
let g:mapleader = &#39; &#39;


syntax on

filetype on

filetype indent on

filetype plugin on

filetype plugin indent on

&amp;quot; 标签页
set tabpagemax=20
set showtabline=2

&amp;quot; 设置文件浏览器目录为当前目录
set bsdir=buffer


&amp;quot; 突出显示当前行
set cursorline

&amp;quot; 突出显示当前列
&amp;quot; set cursorcolumn

&amp;quot; 括号配对情况, 跳转并高亮匹配的括号
set showmatch
&amp;quot;
set matchtime=2

&amp;quot; 相对行号: 行号变成相对
set relativenumber number

set encoding=utf-8

set fileencodings=ucs-bom,utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1
set helplang=cn

set rtp+=~/.fzf                  &amp;quot; fzf 

set path=.,/usr/include/c++/5,/usr/include,/home/l0phtg/tools/llvm-project/llvm/include



&amp;quot;plug插件

call plug#begin()

Plug &#39;NLKNguyen/papercolor-theme&#39;
Plug &#39;vim-airline/vim-airline&#39;
Plug &#39;vim-airline/vim-airline-themes&#39;

Plug &#39;Shougo/denite.nvim&#39;
Plug &#39;Shougo/unite.vim&#39;
Plug &#39;Shougo/vimfiler&#39;


Plug &#39;Shougo/deoplete.nvim&#39;, { &#39;do&#39;: &#39;:UpdateRemotePlugins&#39; }

Plug &#39;Shougo/neoinclude.vim&#39;

Plug &#39;majutsushi/tagbar&#39;
&amp;quot;&amp;quot;Plug &#39;https://github.com/fholgado/minibufexpl.vim.git&#39;
Plug &#39;ap/vim-buftabline&#39;


Plug &#39;justmao945/vim-clang&#39;
&amp;quot;Plug &#39;Valloric/YouCompleteMe&#39;     &amp;quot; YCM补全

&amp;quot;Plug &#39;SirVer/ultisnips&#39;           &amp;quot; 代码片段补全  模板补全

&amp;quot;Plug &#39;zchee/deoplete-jedi&#39;       &amp;quot; Python补全

Plug &#39;Raimondi/delimitMate&#39;       &amp;quot; 不全, \&amp;quot; \( 等.

Plug &#39;scrooloose/nerdcommenter&#39;   &amp;quot; 自动注释   &amp;lt;leader&amp;gt;cc  注释当先选中文本  &amp;lt;leader&amp;gt;cu 取消选中文本块的注释

Plug &#39;lvht/tagbar-markdown&#39;       &amp;quot; markdown  tagbar显示

Plug &#39;~/.fzf&#39;
Plug &#39;junegunn/fzf.vim&#39;

call plug#end()

set background=dark
colorscheme PaperColor

let g:airline_theme=&#39;papercolor&#39;


&amp;quot; 设置tagbar
let g:tagbar_width=30
let g:tagbar_left=1


&amp;quot; 配置fzf  和 ag
noremap &amp;lt;leader&amp;gt;sff :Files&amp;lt;CR&amp;gt;
noremap &amp;lt;leader&amp;gt;ssf :Lines&amp;lt;CR&amp;gt;
noremap &amp;lt;leader&amp;gt;sbf :BLines&amp;lt;CR&amp;gt; 
noremap &amp;lt;leader&amp;gt;ss  :Ag&amp;lt;CR&amp;gt;

noremap &amp;lt;leader&amp;gt;gls :GFiles&amp;lt;CR&amp;gt;
noremap &amp;lt;leader&amp;gt;gss :GFiles?&amp;lt;CR&amp;gt;   

noremap &amp;lt;leader&amp;gt;btag :Tags&amp;lt;CR&amp;gt;
noremap &amp;lt;leader&amp;gt;stag :BTags&amp;lt;CR&amp;gt;


&amp;quot; 配置vimbuftabline
let g:buftabline_numbers=2

noremap &amp;lt;leader&amp;gt;&amp;lt;Tab&amp;gt; :bnext&amp;lt;CR&amp;gt;

nmap &amp;lt;leader&amp;gt;1 &amp;lt;Plug&amp;gt;BufTabLine.Go(1)
nmap &amp;lt;leader&amp;gt;2 &amp;lt;Plug&amp;gt;BufTabLine.Go(2)
nmap &amp;lt;leader&amp;gt;3 &amp;lt;Plug&amp;gt;BufTabLine.Go(3)
nmap &amp;lt;leader&amp;gt;4 &amp;lt;Plug&amp;gt;BufTabLine.Go(4)
nmap &amp;lt;leader&amp;gt;5 &amp;lt;Plug&amp;gt;BufTabLine.Go(5)
nmap &amp;lt;leader&amp;gt;6 &amp;lt;Plug&amp;gt;BufTabLine.Go(6)
nmap &amp;lt;leader&amp;gt;7 &amp;lt;Plug&amp;gt;BufTabLine.Go(7)
nmap &amp;lt;leader&amp;gt;8 &amp;lt;Plug&amp;gt;BufTabLine.Go(8)
nmap &amp;lt;leader&amp;gt;9 &amp;lt;Plug&amp;gt;BufTabLine.Go(9)
nmap &amp;lt;leader&amp;gt;0 &amp;lt;Plug&amp;gt;BufTabLine.Go(10)

&amp;quot; 设置 deoplete.nvim
let g:deoplete#enable_at_startup = 1

&amp;quot;设置Tab为补全
inoremap &amp;lt;expr&amp;gt; &amp;lt;Tab&amp;gt; pumvisible() ? &amp;quot;\&amp;lt;C-n&amp;gt;&amp;quot; : &amp;quot;\&amp;lt;Tab&amp;gt;&amp;quot;                
&amp;quot;inoremap &amp;lt;expr&amp;gt; &amp;lt;S-Tab&amp;gt; pumvisible() ? &amp;quot;\&amp;lt;C-p&amp;gt;&amp;quot; : &amp;quot;\&amp;lt;S-Tab&amp;gt;&amp;quot;
&amp;quot;inoremap &amp;lt;expr&amp;gt; &amp;lt;cr&amp;gt; pumvisible() ? &amp;quot;\&amp;lt;C-y&amp;gt;&amp;quot; : &amp;quot;\&amp;lt;cr&amp;gt;&amp;quot;


&amp;quot; 设置vim-clang
let g:clang_cpp_options = &#39;-std=c++11&#39;
let g:clang_check_syntax_auto = 1
let g:clang_cpp_completeopt = &#39;menuone,longest&#39;



&amp;quot;快捷键只在常规模式下有用 nnoremap
&amp;quot;设置 F3 为打开vimfiler
&amp;quot;设置 &amp;quot; &amp;quot;fs 为保存文件
&amp;quot;function vimfilertoRight()
&amp;quot;endfunction

nnoremap &amp;lt;F2&amp;gt; :TagbarToggle &amp;lt;CR&amp;gt;
nnoremap &amp;lt;F3&amp;gt; :VimFilerExplorer -split -direction=rightbelow &amp;lt;CR&amp;gt;          
nnoremap &amp;lt;leader&amp;gt;fs :w &amp;lt;CR&amp;gt;
nnoremap &amp;lt;leader&amp;gt;fS :wall &amp;lt;CR&amp;gt;

nnoremap &amp;lt;leader&amp;gt;qq :wq &amp;lt;CR&amp;gt;
&amp;quot;vim windows窗口左右
nnoremap &amp;lt;C-h&amp;gt; &amp;lt;C-w&amp;gt;h &amp;lt;CR&amp;gt;
nnoremap &amp;lt;C-l&amp;gt; &amp;lt;C-w&amp;gt;l &amp;lt;CR&amp;gt;
nnoremap &amp;lt;C-j&amp;gt; &amp;lt;C-w&amp;gt;j &amp;lt;CR&amp;gt;
nnoremap &amp;lt;C-k&amp;gt; &amp;lt;C-w&amp;gt;k &amp;lt;CR&amp;gt;

&amp;quot;分割窗口
nnoremap &amp;lt;leader&amp;gt;wj :split&amp;lt;CR&amp;gt;
nnoremap &amp;lt;leader&amp;gt;wl :vsplit&amp;lt;CR&amp;gt;


&amp;quot;set hidden &amp;quot; 避免必须保存才可以跳转buffer

&amp;quot; my settings 对vimfiler的配置
let g:vimfiler_as_default_explorer = 1
let g:vimfiler_safe_mode_by_default = 0
let g:vimfiler_tree_leaf_icon = &#39; &#39;
let g:vimfiler_tree_opened_icon = &#39;▾&#39;
let g:vimfiler_tree_closed_icon = &#39;▸&#39;
let g:vimfiler_enable_auto_cd = 1
let g:vimfiler_file_icon = &#39;-&#39;
let g:vimfiler_marked_file_icon = &#39;✓&#39;
let g:vimfiler_readonly_file_icon = &#39;✗&#39;
let g:vimfiler_time_format = &#39;%m-%d-%y %H:%M:%S&#39;
let g:vimfiler_expand_jump_to_first_child = 0
let g:vimfiler_ignore_pattern = &#39;\.git\|\.DS_Store\|\.pyc&#39;


&amp;quot; 文件类型设置 FileType Settings
set sw=4
set ts=4
autocmd FileType markdown set tabstop=4 shiftwidth=4 expandtab ai
autocmd FileType c++ set tabstop=4 shiftwidth=4 expandtab ai
autocmd FileType c set tabstop=4 shiftwidth=4 expandtab ai

autocmd FileType python set tabstop=4 shiftwidth=4 expandtab ai
autocmd FileType ruby,javascript,html,css,xml set tabstop=2 shiftwidth=2 softtabstop=2 expandtab ai


&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>Pixel1 源码编译</title>
      <link>https://l0phtg.github.io/post/pixel1-%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/</link>
      <pubDate>Tue, 02 Oct 2018 15:38:56 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/pixel1-%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/</guid>
      
        <description>&lt;p&gt;记录自己Pixel1刷机流程.&lt;/p&gt;

&lt;p&gt;相关网站&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Requirements
https://source.android.google.cn/setup/build/requirements.html#binaries

https://source.android.com/setup/build/running

buile numbers
https://source.android.com/setup/start/build-numbers

https://source.android.com/setup/build/downloading

驱动
https://developers.google.com/android/drivers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;ota-image&#34;&gt;ota, image&lt;/h2&gt;

&lt;p&gt;刷机使用. 不需要编译源码, 直接刷机.&lt;/p&gt;

&lt;p&gt;下载刷机包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https://developers.google.com/android/images

https://developers.google.com/android/ota
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;刷入:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$sudo ./flash_all.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;源码下载&#34;&gt;源码下载&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-6.0.1_r77
repo sync -j8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;适用于pixel 的:
NZH54D android-7.1.2_r33
OPM4.171019.021.P1 android-8.1.0_r38&lt;/p&gt;

&lt;p&gt;repo init -u &lt;a href=&#34;https://aosp.tuna.tsinghua.edu.cn/platform/manifest&#34;&gt;https://aosp.tuna.tsinghua.edu.cn/platform/manifest&lt;/a&gt; -b android-7.1.2_r33&lt;/p&gt;

&lt;p&gt;repo init -u &lt;a href=&#34;https://aosp.tuna.tsinghua.edu.cn/platform/manifest&#34;&gt;https://aosp.tuna.tsinghua.edu.cn/platform/manifest&lt;/a&gt; -b android-8.1.0_r38&lt;/p&gt;

&lt;h2 id=&#34;编译&#34;&gt;编译&lt;/h2&gt;

&lt;p&gt;直接编译userdebug版本, 方便我们调试&lt;/p&gt;

&lt;p&gt;安装jdk&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo add-apt-repository ppa:openjdk-r/ppa  
sudo apt-get update   
sudo apt-get install openjdk-7-jdk  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译,&lt;code&gt;如果要刷真机的话, 需要提前下载驱动到源码目录, 并解压之后运行.sh, ACCEPT后释放出来驱动相关文件.(https://developers.google.com/android/drivers)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$source ./build/envsetup.sh
$lunch
编译全部源码
$make -j12 
编译某个module
$make -j12 libart_32
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入系统&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这里不需要sudo 
$fastboot flashall -w
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;root&#34;&gt;root&lt;/h2&gt;

&lt;p&gt;root无源码的机型.
1. 解锁boot
2. 刷入twrp
3. 装入supersu.apk
4. 重启&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gist.github.com/rhyttr/931f5f14f40793a45170809bec6ca62a&#34;&gt;https://gist.github.com/rhyttr/931f5f14f40793a45170809bec6ca62a&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Download latest Android image, &amp;quot;hammerhead&amp;quot; for Nexus 5 (GSM/LTE)
https://developers.google.com/android/nexus/images#hammerhead

# Download latest TWRP
https://dl.twrp.me/hammerhead/

# Download latest SuperSu
https://download.chainfire.eu/supersu

Enable USB debugging.
Reboot into bootloader (power off, volume down + power on or sudo adb reboot-bootloader)
# Wait for boot loader to start
# Install factory ROM:
unzip hammerhead-m4b30z-factory-625c027b.zip
cd hammerhead-m4b30z
unzip image-hammerhead-m4b30z.zip
fastboot flash bootloader bootloader-hammerhead-hhz20h.img
fastboot reboot-bootloader #or power off/start bootloader
fastboot flash radio radio-hammerhead-m8974a-2.0.50.2.30.img
fastboot flash boot boot.img
fastboot flash cache cache.img
fastboot flash system system.img
# add params -S 256M if remaining memory is not enough . eg: sudo fastboot flash -S 256M system system.img
fastboot flash recovery recovery.img
fastboot reboot

# Wait boot to finish for application upgrade.
adb push SR1-SuperSU-v2.82-SR1-20170608224931.zip /sdcard/
adb reboot-bootloader

# [Wait for bootloader to start]
adb start-server
fastboot flash recovery twrp-3.1.1-0-hammerhead.img
fastboot reboot-bootloader
# on the screen, Navigate into Recovery mode (Reboot) -&amp;gt; Install -&amp;gt; zip, select SR3-SuperSU-v2.79-SR3-20170114223742.zip -&amp;gt; Swipe to confirm Flash
# Reboot System
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;调试&#34;&gt;调试&lt;/h2&gt;

&lt;p&gt;更改system分区读写权限&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$adb disable verity
$mount -o remount,rw /system
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;emulator测试&#34;&gt;emulator测试&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;列出创建avd&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;emulator -list-avd
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;emulator 启动avd&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$emulator -avd PixelN
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使&lt;code&gt;system&lt;/code&gt;分区可写&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$emulator -writable-system -avd PixelN
启动之后
$adb remount
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;n. help&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ emulator -help
ndroid Emulator usage: emulator [options] [-qemu args]
 options:
   -list-avds                      list available AVDs
   -sysdir &amp;lt;dir&amp;gt;                   search for system disk images in &amp;lt;dir&amp;gt;
   -system &amp;lt;file&amp;gt;                  read initial system image from &amp;lt;file&amp;gt;
   -vendor &amp;lt;file&amp;gt;                  read initial vendor image from &amp;lt;file&amp;gt;
   -writable-system                make system &amp;amp; vendor image writable after &#39;adb remount&#39;
   -datadir &amp;lt;dir&amp;gt;                  write user data into &amp;lt;dir&amp;gt;
   -kernel &amp;lt;file&amp;gt;                  use specific emulated kernel
   -ramdisk &amp;lt;file&amp;gt;                 ramdisk image (default &amp;lt;system&amp;gt;/ramdisk.img
   -image &amp;lt;file&amp;gt;                   obsolete, use -system &amp;lt;file&amp;gt; instead
   -initdata &amp;lt;file&amp;gt;                same as &#39;-init-data &amp;lt;file&amp;gt;&#39;
   -data &amp;lt;file&amp;gt;                    data image (default &amp;lt;datadir&amp;gt;/userdata-qemu.img
   -encryption-key &amp;lt;file&amp;gt;          read initial encryption key image from &amp;lt;file&amp;gt;
   -logcat-output &amp;lt;file&amp;gt;           output file of logcat(default none)
   -partition-size &amp;lt;size&amp;gt;          system/data partition size in MBs
   -cache &amp;lt;file&amp;gt;                   cache partition image (default is temporary file)
   -cache-size &amp;lt;size&amp;gt;              cache partition size in MBs
   -no-cache                       disable the cache partition
   -nocache                        same as -no-cache
   -sdcard &amp;lt;file&amp;gt;                  SD card image (default &amp;lt;datadir&amp;gt;/sdcard.img
   -quit-after-boot &amp;lt;timeout&amp;gt;      qeuit emulator after guest boots completely, or after timeout in seconds
   -snapstorage &amp;lt;file&amp;gt;             file that contains all state snapshots (default &amp;lt;datadir&amp;gt;/snapshots.img)
   -no-snapstorage                 do not mount a snapshot storage file (this disables all snapshot functionality)
   -snapshot &amp;lt;name&amp;gt;                name of snapshot within storage file for auto-start and auto-save (default &#39;default-boot&#39;)
   -no-snapshot                    perform a full boot and do not auto-save, but qemu vmload and vmsave operate on snapstorage
   -no-snapshot-save               do not auto-save to snapshot on exit: abandon changed state
   -no-snapshot-load               do not auto-start from snapshot: perform a full boot
   -snapshot-list                  show a list of available snapshots
   -no-snapshot-update-time        do not try to correct snapshot time on restore
   -wipe-data                      reset the user data image (copy it from initdata)
   -avd &amp;lt;name&amp;gt;                     use a specific android virtual device
   -skindir &amp;lt;dir&amp;gt;                  search skins in &amp;lt;dir&amp;gt; (default &amp;lt;system&amp;gt;/skins)
   -skin &amp;lt;name&amp;gt;                    select a given skin
   -no-skin                        deprecated: create an AVD with no skin instead
   -noskin                         same as -no-skin
   -memory &amp;lt;size&amp;gt;                  physical RAM size in MBs
   -cores &amp;lt;number&amp;gt;                 Set number of CPU cores to emulator
   -accel &amp;lt;mode&amp;gt;                   Configure emulation acceleration
   -no-accel                       Same as &#39;-accel off&#39;
   -ranchu                         Use new emulator backend instead of the classic one
   -engine &amp;lt;engine&amp;gt;                Select engine. auto|classic|qemu2
   -netspeed &amp;lt;speed&amp;gt;               maximum network download/upload speeds
   -netdelay &amp;lt;delay&amp;gt;               network latency emulation
   -netfast                        disable network shaping
   -code-profile &amp;lt;name&amp;gt;            enable code profiling
   -show-kernel                    display kernel messages
   -shell                          enable root shell on current terminal
   -no-jni                         disable JNI checks in the Dalvik runtime
   -nojni                          same as -no-jni
   -logcat &amp;lt;tags&amp;gt;                  enable logcat output with given tags
   -use-system-libs                Use system libstdc++ instead of bundled one
   -bluetooth &amp;lt;vendorid:productid&amp;gt; forward bluetooth to vendorid:productid
   -no-audio                       disable audio support
   -noaudio                        same as -no-audio
   -audio &amp;lt;backend&amp;gt;                use specific audio backend
   -radio &amp;lt;device&amp;gt;                 redirect radio modem interface to character device
   -port &amp;lt;port&amp;gt;                    TCP port that will be used for the console
   -ports &amp;lt;consoleport&amp;gt;,&amp;lt;adbport&amp;gt;  TCP ports used for the console and adb bridge
   -onion &amp;lt;image&amp;gt;                  use overlay PNG image over screen
   -onion-alpha &amp;lt;%age&amp;gt;             specify onion-skin translucency
   -onion-rotation 0|1|2|3         specify onion-skin rotation
   -dpi-device &amp;lt;dpi&amp;gt;               specify device&#39;s resolution in dpi (default 165)
   -scale &amp;lt;scale&amp;gt;                  scale emulator window (deprecated)
   -http-proxy &amp;lt;proxy&amp;gt;             make TCP connections through a HTTP/HTTPS proxy
   -timezone &amp;lt;timezone&amp;gt;            use this timezone instead of the host&#39;s default
   -dns-server &amp;lt;servers&amp;gt;           use this DNS server(s) in the emulated system
   -net-tap &amp;lt;interface&amp;gt;            use this TAP interface for networking
   -net-tap-script-up &amp;lt;script&amp;gt;     script to run when the TAP interface goes up
   -net-tap-script-down &amp;lt;script&amp;gt;   script to run when the TAP interface goes down
   -cpu-delay &amp;lt;cpudelay&amp;gt;           throttle CPU emulation
   -no-boot-anim                   disable animation for faster boot
   -no-window                      disable graphical window display
   -no-sim                         device has no SIM card
   -lowram                         device is a low ram device
   -version                        display emulator version number
   -report-console &amp;lt;socket&amp;gt;        report console port to remote socket
   -gps &amp;lt;device&amp;gt;                   redirect NMEA GPS to character device
   -shell-serial &amp;lt;device&amp;gt;          specific character device for root shell
   -tcpdump &amp;lt;file&amp;gt;                 capture network packets to file
   -bootchart &amp;lt;timeout&amp;gt;            enable bootcharting
   -charmap &amp;lt;file&amp;gt;                 use specific key character map
   -studio-params &amp;lt;file&amp;gt;           used by Android Studio to provide parameters
   -prop &amp;lt;name&amp;gt;=&amp;lt;value&amp;gt;            set system property on boot
   -shared-net-id &amp;lt;number&amp;gt;         join the shared network, using IP address 10.1.2.&amp;lt;number&amp;gt;
   -nand-limits &amp;lt;nlimits&amp;gt;          enforce NAND/Flash read/write thresholds
   -gpu &amp;lt;mode&amp;gt;                     set hardware OpenGLES emulation mode
   -camera-back &amp;lt;mode&amp;gt;             set emulation mode for a camera facing back
   -camera-front &amp;lt;mode&amp;gt;            set emulation mode for a camera facing front
   -webcam-list                    lists web cameras available for emulation
   -screen &amp;lt;mode&amp;gt;                  set emulated screen mode
   -selinux &amp;lt;disabled|permissive&amp;gt;  Set SELinux to either disabled or permissive mode
   -unix-pipe &amp;lt;path&amp;gt;               Add &amp;lt;path&amp;gt; to the list of allowed Unix pipes
   -fixed-scale                    Use fixed 1:1 scale for the initial emulator window.
   -wait-for-debugger              Pause on launch and wait for a debugger process to attach before resuming
   -skip-adb-auth                  Skip adb authentication dialogue
   -metrics-to-console             Enable usage metrics and print the messages to stdout
   -metrics-to-file &amp;lt;file&amp;gt;         Enable usage metrics and write the messages into specified file
   -feature &amp;lt;name|-name&amp;gt;           Force-enable or disable (-name) the features
   -sim-access-rules-file &amp;lt;file&amp;gt;   Use SIM access rules from specified file
   -phone-number-prefix &amp;lt;string&amp;gt;   Number to use as the emulator&#39;s phone number prefix

    -qemu args...                  pass arguments to qemu
    -qemu -h                       display qemu help

    -verbose                       same as &#39;-debug-init&#39;
    -debug &amp;lt;tags&amp;gt;                  enable/disable debug messages
    -debug-&amp;lt;tag&amp;gt;                   enable specific debug messages
    -debug-no-&amp;lt;tag&amp;gt;                disable specific debug messages

    -help                          print this help
    -help-&amp;lt;option&amp;gt;                 print option-specific help

    -help-disk-images              about disk images
    -help-debug-tags               debug tags for -debug &amp;lt;tags&amp;gt;
    -help-char-devices             character &amp;lt;device&amp;gt; specification
    -help-environment              environment variables
    -help-virtual-device           virtual device management
    -help-sdk-images               about disk images when using the SDK
    -help-build-images             about disk images when building Android
    -help-all                      prints all help content
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>Hugo搭建博客</title>
      <link>https://l0phtg.github.io/post/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Wed, 19 Sep 2018 20:04:10 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</guid>
      
        <description>&lt;p&gt;博客半年多没更新了. 正好最近时间比较多, 想着把博客更新下, 再把几篇平时总结的文章上传在Blog里面.&lt;/p&gt;

&lt;p&gt;以前使用hexo搭的, 最近发现了好多人在用&lt;code&gt;hugo&lt;/code&gt;, 自己使用hugo重新搭建了一下, 简单方便, 好感指数五颗星.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gohugo.io/getting-started/quick-start/&#34;&gt;https://gohugo.io/getting-started/quick-start/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;hugo 搭建&lt;/p&gt;

&lt;h2 id=&#34;linux平台安装hugo&#34;&gt;linux平台安装hugo&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;源码安装&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;安装go:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/doc/install?download=go1.11.linux-amd64.tar.gz&#34;&gt;https://golang.org/doc/install?download=go1.11.linux-amd64.tar.gz&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$tar -C /usr/local -xzf go1.11.linux-amd64.tar.gz
$ vim /etc/profile
export PATH=$PATH:/usr/local/go/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下载源码安装hugo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir $HOME/src
cd $HOME/src
git clone https://github.com/gohugoio/hugo.git
cd hugo
go install
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;apt安装&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$sudo apt install hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;

&lt;h3 id=&#34;创建new-site&#34;&gt;创建New site&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$hugo new site quickstart
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;创建md&#34;&gt;创建md&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$hugo new posts/my-first-post.md
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;预览&#34;&gt;预览&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$hugo server -D 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Navigate to your new site at &lt;a href=&#34;http://localhost:1313/&#34;&gt;http://localhost:1313/&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;个性化主题&#34;&gt;个性化主题&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://themes.gohugo.io/&#34;&gt;https://themes.gohugo.io/&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;网站配置&#34;&gt;网站配置&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;config.toml&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;baseURL = &amp;quot;https://example.org/&amp;quot;
languageCode = &amp;quot;en-us&amp;quot;
title = &amp;quot;My New Hugo Site&amp;quot;
theme = &amp;quot;ananke&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;post到github-pages上&#34;&gt;post到github pages上&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;升级git&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Debian/Ubuntu
For the latest stable version for your release of Debian/Ubuntu

# apt-get install git
For Ubuntu, this PPA provides the latest stable upstream Git version
# add-apt-repository ppa:git-core/ppa # apt update; apt install git
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;github上创建USER_NAME.github.io的repo.&lt;/li&gt;
&lt;li&gt;clone repo到public目录&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git submodule add -b master git@github.com:&amp;lt;USERNAME&amp;gt;/&amp;lt;USERNAME&amp;gt;.github.io.git public
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;push&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;depl4oy.sh&lt;/code&gt;如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

echo -e &amp;quot;\033[0;32mDeploying updates to GitHub...\033[0m&amp;quot;

# Build the project.
hugo # if using a theme, replace with `hugo -t &amp;lt;YOURTHEME&amp;gt;`

# Go To Public folder
cd public
# Add changes to git.
git add .

# Commit changes.
msg=&amp;quot;rebuilding site `date`&amp;quot;
if [ $# -eq 1 ]
  then msg=&amp;quot;$1&amp;quot;
fi
git commit -m &amp;quot;$msg&amp;quot;

# Push source and build repos.
git push origin master

# Come Back up to the Project Root
cd ..
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;内容编写&#34;&gt;内容编写&lt;/h2&gt;

&lt;h3 id=&#34;文档模板&#34;&gt;文档模板&lt;/h3&gt;

&lt;p&gt;默认是&lt;code&gt;archetypes /default.md&lt;/code&gt;. new 文档时, 根据这个文档创建.&lt;/p&gt;

&lt;p&gt;我的&lt;code&gt;default.md&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;---
title: &amp;quot;{{ replace .TranslationBaseName &amp;quot;-&amp;quot; &amp;quot; &amp;quot; | title }}&amp;quot;
date: {{ .Date }}
lastmod: {{ .Date }}
draft: true
keywords: []
description: &amp;quot;&amp;quot;
tags: []
categories: []
author: &amp;quot;&amp;quot;

# You can also close(false) or open(true) something for this content.
# P.S. comment can only be closed
comment: false
toc: true
autoCollapseToc: false
# You can also define another contentCopyright. e.g. contentCopyright: &amp;quot;This is another copyright.&amp;quot;
#contentCopyright: false
reward: false
mathjax: false
---

&amp;lt;!--more--&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;插入图片&#34;&gt;插入图片&lt;/h3&gt;

&lt;p&gt;图片放在static目录下&lt;/p&gt;

&lt;p&gt;例如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;目录下的文件:
- static
   - deepin
      - desktop.png
      - splitScreen.png
      - vimMarkdownPreview.png
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用的时候:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;![desktop](/deepin/desktop.png)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;文章摘要&#34;&gt;文章摘要&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;!--more--&amp;gt;&lt;/code&gt;前面的会成为文章的摘要, 在首页显示.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
title : &amp;quot;hihi&amp;quot;
tags :  &amp;quot;blog&amp;quot;
---

&amp;lt;!--more--&amp;gt;

正文
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;显示toc&#34;&gt;显示toc&lt;/h3&gt;

&lt;p&gt;toc : true&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
title: &amp;quot;Iqiyi开源hook框架XHook分析&amp;quot;
date: 2018-09-19T02:19:05+08:00
lastmod: 2018-09-19T02:19:05+08:00
draft: false
keywords: []
description: &amp;quot;&amp;quot;
tags: [&amp;quot;hook&amp;quot;]
categories: [&amp;quot;hook&amp;quot;]
author: &amp;quot;&amp;quot;

# You can also close(false) or open(true) something for this content.
# P.S. comment can only be closed
comment: false
toc: true
autoCollapseToc: false
# You can also define another contentCopyright. e.g. contentCopyright: &amp;quot;This is another copyright.&amp;quot;
contentCopyright: false
reward: false
mathjax: false
---
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;语法高亮&#34;&gt;语法高亮&lt;/h3&gt;

&lt;h4 id=&#34;chroma&#34;&gt;Chroma&lt;/h4&gt;

&lt;p&gt;hugo &lt;strong&gt;使用chroma默认进行语法高亮, 垃圾, 不好用, 推荐highlight.js&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pygmentsCodefences = true #高亮markdown的代码块
pygmentsCodefencesGuessSyntax = true #高亮markdown中没有标注语言的代码块
pygmentsStyle = &#39;manni&#39; #高亮主题
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有些主题的默认css设置了background. 会导致highlight时出现字体白色阴影. 此时我们需要将它的background-color删掉或者覆盖掉.&lt;/p&gt;

&lt;p&gt;我使用的主题是&lt;code&gt;jane&lt;/code&gt;, 默认css样式是&lt;code&gt;/themes/jane/static/dist/jane.min.css&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;#jane.min.css
 code{padding:0 7px;background:#f8f5ec;border-radius:4px;color:#c7254e}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把该块删掉.&lt;/p&gt;

&lt;p&gt;这要就可以解决阴影的问题了.&lt;strong&gt;可能自己的主题版本太老了, 可以pull一下最新版本, 这个问题应该会被修复了&lt;/strong&gt; .&lt;/p&gt;

&lt;h4 id=&#34;highlight-js&#34;&gt;highlight.js&lt;/h4&gt;

&lt;p&gt;添加&lt;strong&gt;主题css&lt;/strong&gt;和&lt;strong&gt;highlight.pack.js&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;customCSS = [&#39;styles/dracula.css]
customJS = [&#39;highlight.pack.js]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;body&lt;/strong&gt;中添加&lt;strong&gt;script&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;script&amp;gt;hljs.initHighlightingOnLoad();&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;显示最后更新日期&#34;&gt;显示最后更新日期&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;enableGitInfo = true    # 开启gitinfo

[frontmatter]
date = [&amp;quot;date&amp;quot;, &amp;quot;publishDate&amp;quot;, &amp;quot;lastmod&amp;quot;]
lastmod = [&amp;quot;:git&amp;quot;, &amp;quot;lastmod&amp;quot;, &amp;quot;date&amp;quot;, &amp;quot;publishDate&amp;quot;]
publishDate = [&amp;quot;publishDate&amp;quot;, &amp;quot;date&amp;quot;]
expiryDate = [&amp;quot;expiryDate&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要实现该功能需要有&lt;strong&gt;commit记录&lt;/strong&gt; , 所以需要&lt;strong&gt;添加我们的.md到git版本控制工具&lt;/strong&gt; 中. 请阅读下面的&lt;strong&gt;博客搭建心得&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&#34;数学公式&#34;&gt;数学公式&lt;/h3&gt;

&lt;h4 id=&#34;如何开启mathjax&#34;&gt;如何开启mathjax&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;/layout/partical&lt;/code&gt;目录下创建&lt;code&gt;mathjax_support.html&lt;/code&gt;, 写入:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;
  src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML&amp;quot;&amp;gt;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;支持内联&#34;&gt;支持内联&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;/layouts/partials/custom_head.html&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;script type=&amp;quot;text/x-mathjax-config&amp;quot;&amp;gt;
  MathJax.Hub.Config({tex2jax: {inlineMath: [[&#39;$&#39;,&#39;$&#39;], [&#39;\\(&#39;,&#39;\\)&#39;]]}});  // 内联公式
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;支持color&#34;&gt;支持color&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;/layouts/partials/custom_head.html&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;&amp;lt;script type=&amp;quot;text/x-mathjax-config&amp;quot;&amp;gt;
  MathJax.Hub.Config({                                                      // support color
  showProcessingMessages: false,
  jax: [&amp;quot;input/TeX&amp;quot;, &amp;quot;output/HTML-CSS&amp;quot;],
  TeX: {
    TagSide: &amp;quot;left&amp;quot;,
    Macros: {
      RR: &#39;{\\bf R}&#39;,
      bold: [&#39;{\\bf #1}&#39;,1]
    }
  }
});
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mermaid&#34;&gt;mermaid&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;mermaid&lt;/code&gt;支持画流程图, 甘特图等.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/knsv/mermaid/releases&#34;&gt;https://github.com/knsv/mermaid/releases&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;和使用&lt;code&gt;highlight.js&lt;/code&gt;的方法类似:&lt;/p&gt;

&lt;p&gt;添加&lt;code&gt;mermaid.css&lt;/code&gt; 和 &lt;code&gt;mermaid.min.js&lt;/code&gt; .&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;customCSS = [&#39;styles/dracula.css&#39;, &#39;mermaid.css&#39;]            # if [&#39;custom.css&#39;], load &#39;/static/css/custom.css&#39; file
customJS = [&#39;highlight.pack.js&#39;,&#39;mermaid.min.js&#39;]             # if [&#39;custom.js&#39;], load &#39;/static/js/custom.js&#39; file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;script.html&lt;/code&gt;中添加&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script&amp;gt; mermaid.initialize({ startOnLoad: true });&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;使用-1&#34;&gt;使用&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;&amp;lt;div class=&amp;quot;mermaid&amp;quot;&amp;gt;
graph TD
    Start --&amp;gt; Stop
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成:&lt;/p&gt;

&lt;div class=&#34;mermaid&#34;&gt;
graph TD
    Start --&gt; Stop
&lt;/div&gt;

&lt;h1 id=&#34;博客搭建心得&#34;&gt;博客搭建心得&lt;/h1&gt;

&lt;p&gt;注意到, 在上文我们&lt;strong&gt;post网站到github pages&lt;/strong&gt; 上时,  是将&lt;strong&gt;public目录作为submodule&lt;/strong&gt;  push的. (push 的就是public目录的内容 ).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/life/blog-public.png&#34; alt=&#34;blog-public&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们可以将当前的hugo 目录, 按上图来说就是&lt;strong&gt;quickstart目录&lt;/strong&gt; 作为我们的博客代码编写目录添加到&lt;strong&gt;quickstart的git版本控制中&lt;/strong&gt; .&lt;/p&gt;

&lt;p&gt;我添加到git仓库中的文件有: &lt;strong&gt;config.toml, content/ , deploy.sh&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/life/blog-ls-files.png&#34; alt=&#34;blog-ls-files&#34; /&gt;&lt;/p&gt;

&lt;p&gt;添加到版本控制的目的: 可以将它提交到我们的&lt;strong&gt;github&lt;/strong&gt;或者 &lt;strong&gt;gitee&lt;/strong&gt;上, &lt;strong&gt;方便跨平台编辑, 也可以当作一个备份&lt;/strong&gt; .&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Iqiyi开源hook框架XHook分析</title>
      <link>https://l0phtg.github.io/post/iqiyi%E5%BC%80%E6%BA%90hook%E6%A1%86%E6%9E%B6xhook%E5%88%86%E6%9E%90/</link>
      <pubDate>Sun, 19 Aug 2018 02:19:05 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/iqiyi%E5%BC%80%E6%BA%90hook%E6%A1%86%E6%9E%B6xhook%E5%88%86%E6%9E%90/</guid>
      
        <description>&lt;p&gt;Got Hook 可以使用dlsym得到目标函数的地址, 然后遍历got表进行Hook.&lt;/p&gt;

&lt;p&gt;但是有时候我们不能通过dlsym得到函数地址. 这时我们需要怎么办呢? iqiyi的xhook很好的解决了这个问题, (可以参考linker的实现, &lt;strong&gt;有问题, 看源码&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;通过找到目标函数地址存放在got表中位置, 只要找到了目标symbol在got表中的offset, 想要修改或者得到目标函数的实际地址就轻松多了.&lt;/p&gt;

&lt;p&gt;symbol -&amp;gt; symid -&amp;gt; 在got表中的offset  -&amp;gt; 目标函数实际地址&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;阅读readme&#34;&gt;阅读Readme&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/iqiyi/xHook/blob/master/README.zh-CN.md&#34;&gt;https://github.com/iqiyi/xHook/blob/master/README.zh-CN.md&lt;/a&gt;
&lt;a href=&#34;https://github.com/iqiyi/xHook/blob/master/docs/overview/android_plt_hook_overview.zh-CN.md&#34;&gt;https://github.com/iqiyi/xHook/blob/master/docs/overview/android_plt_hook_overview.zh-CN.md&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//监测内存泄露
xhook_register(&amp;quot;.*\\.so$&amp;quot;, &amp;quot;malloc&amp;quot;,  my_malloc,  NULL);
xhook_register(&amp;quot;.*\\.so$&amp;quot;, &amp;quot;calloc&amp;quot;,  my_calloc,  NULL);
xhook_register(&amp;quot;.*\\.so$&amp;quot;, &amp;quot;realloc&amp;quot;, my_realloc, NULL);
xhook_register(&amp;quot;.*\\.so$&amp;quot;, &amp;quot;free&amp;quot;,    my_free,    NULL);

//监控 sockets 生命周期
xhook_register(&amp;quot;.*\\.so$&amp;quot;, &amp;quot;getaddrinfo&amp;quot;, my_getaddrinfo, NULL);
xhook_register(&amp;quot;.*\\.so$&amp;quot;, &amp;quot;socket&amp;quot;,      my_socket,      NULL);
xhook_register(&amp;quot;.*\\.so$&amp;quot;, &amp;quot;setsockopt&amp;quot;   my_setsockopt,  NULL);
xhook_register(&amp;quot;.*\\.so$&amp;quot;, &amp;quot;bind&amp;quot;,        my_bind,        NULL);
xhook_register(&amp;quot;.*\\.so$&amp;quot;, &amp;quot;listen&amp;quot;,      my_listen,      NULL);
xhook_register(&amp;quot;.*\\.so$&amp;quot;, &amp;quot;connect&amp;quot;,     my_connect,     NULL);
xhook_register(&amp;quot;.*\\.so$&amp;quot;, &amp;quot;shutdown&amp;quot;,    my_shutdown,    NULL);
xhook_register(&amp;quot;.*\\.so$&amp;quot;, &amp;quot;close&amp;quot;,       my_close,       NULL);

//过滤出和保存部分安卓 log 到本地文件
xhook_register(&amp;quot;.*\\.so$&amp;quot;, &amp;quot;__android_log_write&amp;quot;,  my_log_write,  NULL);
xhook_register(&amp;quot;.*\\.so$&amp;quot;, &amp;quot;__android_log_print&amp;quot;,  my_log_print,  NULL);
xhook_register(&amp;quot;.*\\.so$&amp;quot;, &amp;quot;__android_log_vprint&amp;quot;, my_log_vprint, NULL);
xhook_register(&amp;quot;.*\\.so$&amp;quot;, &amp;quot;__android_log_assert&amp;quot;, my_log_assert, NULL);

//追踪某些调用 (忽略 linker 和 linker64)
xhook_register(&amp;quot;^/system/.*$&amp;quot;, &amp;quot;mmap&amp;quot;,   my_mmap,   NULL);
xhook_register(&amp;quot;^/vendor/.*$&amp;quot;, &amp;quot;munmap&amp;quot;, my_munmap, NULL);
xhook_ignore  (&amp;quot;.*/linker$&amp;quot;,   &amp;quot;mmap&amp;quot;);
xhook_ignore  (&amp;quot;.*/linker$&amp;quot;,   &amp;quot;munmap&amp;quot;);
xhook_ignore  (&amp;quot;.*/linker64$&amp;quot;, &amp;quot;mmap&amp;quot;);
xhook_ignore  (&amp;quot;.*/linker64$&amp;quot;, &amp;quot;munmap&amp;quot;);

//防御某些注入攻击
xhook_register(&amp;quot;.*com\\.hacker.*\\.so$&amp;quot;, &amp;quot;malloc&amp;quot;,  my_malloc_always_return_NULL, NULL);
xhook_register(&amp;quot;.*/libhacker\\.so$&amp;quot;,     &amp;quot;connect&amp;quot;, my_connect_with_recorder,     NULL);

//修复某些系统 bug
xhook_register(&amp;quot;.*some_vendor.*/libvictim\\.so$&amp;quot;, &amp;quot;bad_func&amp;quot;, my_nice_func, NULL);

//忽略 libwebviewchromium.so 的所有 hook 信息
xhook_ignore(&amp;quot;.*/libwebviewchromium.so$&amp;quot;, NULL);

//现在执行 hook!
xhook_refresh(1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现重点为下面几个函数:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;xhook_register&lt;/li&gt;
&lt;li&gt;xhook_ignore&lt;/li&gt;
&lt;li&gt;xhook_refresh&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;接下来依次分析&lt;/p&gt;

&lt;h1 id=&#34;分析&#34;&gt;分析&lt;/h1&gt;

&lt;h2 id=&#34;xhook-register-hook函数注册&#34;&gt;xhook_register Hook函数注册&lt;/h2&gt;

&lt;h3 id=&#34;函数申明&#34;&gt;函数申明&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int xhook_register(const char *pathname_regex_str, const char *symbol,
                   void *new_func, void **old_func) XHOOK_EXPORT;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;函数实现分析&#34;&gt;函数实现分析&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int xhook_register(const char *pathname_regex_str, const char *symbol,
                   void *new_func, void **old_func)
{
    return xh_core_register(pathname_regex_str, symbol, new_func, old_func);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;xh-core-register&#34;&gt;xh_core_register&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int xh_core_register(const char *pathname_regex_str, const char *symbol,
                     void *new_func, void **old_func)
{
    xh_core_hook_info_t *hi;
    regex_t              regex;

    if(NULL == pathname_regex_str || NULL == symbol || NULL == new_func) return XH_ERRNO_INVAL;

    if(xh_core_inited)
    {
        XH_LOG_ERROR(&amp;quot;do not register hook after refresh(): %s, %s&amp;quot;, pathname_regex_str, symbol);
        return XH_ERRNO_INVAL;
    }

    if(0 != regcomp(&amp;amp;regex, pathname_regex_str, REG_NOSUB)) return XH_ERRNO_INVAL;

    if(NULL == (hi = malloc(sizeof(xh_core_hook_info_t)))) return XH_ERRNO_NOMEM;
    if(NULL == (hi-&amp;gt;symbol = strdup(symbol)))
    {
        free(hi);
        return XH_ERRNO_NOMEM;
    }
#if XH_CORE_DEBUG
    if(NULL == (hi-&amp;gt;pathname_regex_str = strdup(pathname_regex_str)))
    {
        free(hi-&amp;gt;symbol);
        free(hi);
        return XH_ERRNO_NOMEM;
    }
#endif
    hi-&amp;gt;pathname_regex = regex;
    hi-&amp;gt;new_func = new_func;
    hi-&amp;gt;old_func = old_func;
    
    pthread_mutex_lock(&amp;amp;xh_core_mutex);
    TAILQ_INSERT_TAIL(&amp;amp;xh_core_hook_info, hi, link); // 核心
    pthread_mutex_unlock(&amp;amp;xh_core_mutex);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;xh-elf-init&#34;&gt;xh_elf_init:&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;设置 load_bias, elf_header, Program header地址.&lt;/li&gt;
&lt;li&gt;找到第一个PT_LOAD段&lt;/li&gt;
&lt;li&gt;找到dynamic_header. 之后解析dynamic segment, 找到strtab, symtab, rel.plt, .rel,等&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int xh_elf_init(xh_elf_t *self, uintptr_t base_addr, const char *pathname)
{
    if(0 == base_addr || NULL == pathname) return XH_ERRNO_INVAL;

    //always reset
    memset(self, 0, sizeof(xh_elf_t));
    
    self-&amp;gt;pathname = pathname;
    self-&amp;gt;base_addr = (ElfW(Addr))base_addr;
    self-&amp;gt;ehdr = (ElfW(Ehdr) *)base_addr;
    self-&amp;gt;phdr = (ElfW(Phdr) *)(base_addr + self-&amp;gt;ehdr-&amp;gt;e_phoff); //segmentation fault sometimes

    //find the first load-segment with offset 0
    ElfW(Phdr) *phdr0 = xh_elf_get_first_segment_by_type_offset(self, PT_LOAD, 0);
    if(NULL == phdr0)
    {
        XH_LOG_ERROR(&amp;quot;Can NOT found the first load segment. %s&amp;quot;, pathname);
        return XH_ERRNO_FORMAT;
    }

#if XH_ELF_DEBUG
    if(0 != phdr0-&amp;gt;p_vaddr)
        XH_LOG_DEBUG(&amp;quot;first load-segment vaddr NOT 0 (vaddr: %p). %s&amp;quot;,
                     (void *)(phdr0-&amp;gt;p_vaddr), pathname);
#endif

    //save load bias addr
    if(self-&amp;gt;base_addr &amp;lt; phdr0-&amp;gt;p_vaddr) return XH_ERRNO_FORMAT;
    self-&amp;gt;bias_addr = self-&amp;gt;base_addr - phdr0-&amp;gt;p_vaddr;
    
    //find dynamic-segment
    ElfW(Phdr) *dhdr = xh_elf_get_first_segment_by_type(self, PT_DYNAMIC);
    if(NULL == dhdr)
    {
        XH_LOG_ERROR(&amp;quot;Can NOT found dynamic segment. %s&amp;quot;, pathname);
        return XH_ERRNO_FORMAT;
    }

    //parse dynamic-segment
    self-&amp;gt;dyn          = (ElfW(Dyn) *)(self-&amp;gt;bias_addr + dhdr-&amp;gt;p_vaddr);
    self-&amp;gt;dyn_sz       = dhdr-&amp;gt;p_memsz;
    ElfW(Dyn) *dyn     = self-&amp;gt;dyn;
    ElfW(Dyn) *dyn_end = self-&amp;gt;dyn + (self-&amp;gt;dyn_sz / sizeof(ElfW(Dyn)));
    uint32_t  *raw;
    for(; dyn &amp;lt; dyn_end; dyn++)
    {
        switch(dyn-&amp;gt;d_tag) //segmentation fault sometimes
        {
        case DT_NULL:
            //the end of the dynamic-section
            dyn = dyn_end;
            break;
        case DT_STRTAB:
            {
                self-&amp;gt;strtab = (const char *)(self-&amp;gt;bias_addr + dyn-&amp;gt;d_un.d_ptr);
                if((ElfW(Addr))(self-&amp;gt;strtab) &amp;lt; self-&amp;gt;base_addr) return XH_ERRNO_FORMAT;
                break;
            }
        case DT_SYMTAB:
            {
                self-&amp;gt;symtab = (ElfW(Sym) *)(self-&amp;gt;bias_addr + dyn-&amp;gt;d_un.d_ptr);
                if((ElfW(Addr))(self-&amp;gt;symtab) &amp;lt; self-&amp;gt;base_addr) return XH_ERRNO_FORMAT;
                break;
            }
        case DT_PLTREL:
            //use rel or rela?
            self-&amp;gt;is_use_rela = (dyn-&amp;gt;d_un.d_val == DT_RELA ? 1 : 0);
            break;
        case DT_JMPREL:
            {
                self-&amp;gt;relplt = (ElfW(Addr))(self-&amp;gt;bias_addr + dyn-&amp;gt;d_un.d_ptr);
                if((ElfW(Addr))(self-&amp;gt;relplt) &amp;lt; self-&amp;gt;base_addr) return XH_ERRNO_FORMAT;
                break;
            }
        case DT_PLTRELSZ:
            self-&amp;gt;relplt_sz = dyn-&amp;gt;d_un.d_val;
            break;
        case DT_REL:
        case DT_RELA:
            {
                self-&amp;gt;reldyn = (ElfW(Addr))(self-&amp;gt;bias_addr + dyn-&amp;gt;d_un.d_ptr);
                if((ElfW(Addr))(self-&amp;gt;reldyn) &amp;lt; self-&amp;gt;base_addr) return XH_ERRNO_FORMAT;
                break;
            }
        case DT_RELSZ:
        case DT_RELASZ:
            self-&amp;gt;reldyn_sz = dyn-&amp;gt;d_un.d_val;
            break;
        case DT_ANDROID_REL:
        case DT_ANDROID_RELA:
            {
                self-&amp;gt;relandroid = (ElfW(Addr))(self-&amp;gt;bias_addr + dyn-&amp;gt;d_un.d_ptr);
                if((ElfW(Addr))(self-&amp;gt;relandroid) &amp;lt; self-&amp;gt;base_addr) return XH_ERRNO_FORMAT;
                break;
            }
        case DT_ANDROID_RELSZ:
        case DT_ANDROID_RELASZ:
            self-&amp;gt;relandroid_sz = dyn-&amp;gt;d_un.d_val;
            break;
        case DT_HASH:
            {
                raw = (uint32_t *)(self-&amp;gt;bias_addr + dyn-&amp;gt;d_un.d_ptr);
                if((ElfW(Addr))raw &amp;lt; self-&amp;gt;base_addr) return XH_ERRNO_FORMAT;
                self-&amp;gt;bucket_cnt  = raw[0];
                self-&amp;gt;chain_cnt   = raw[1];
                self-&amp;gt;bucket      = &amp;amp;raw[2];
                self-&amp;gt;chain       = &amp;amp;(self-&amp;gt;bucket[self-&amp;gt;bucket_cnt]);
                break;
            }
        case DT_GNU_HASH:
            {
                raw = (uint32_t *)(self-&amp;gt;bias_addr + dyn-&amp;gt;d_un.d_ptr);
                if((ElfW(Addr))raw &amp;lt; self-&amp;gt;base_addr) return XH_ERRNO_FORMAT;
                self-&amp;gt;bucket_cnt  = raw[0];
                self-&amp;gt;symoffset   = raw[1];
                self-&amp;gt;bloom_sz    = raw[2];
                self-&amp;gt;bloom_shift = raw[3];
                self-&amp;gt;bloom       = (ElfW(Addr) *)(&amp;amp;raw[4]);
                self-&amp;gt;bucket      = (uint32_t *)(&amp;amp;(self-&amp;gt;bloom[self-&amp;gt;bloom_sz]));
                self-&amp;gt;chain       = (uint32_t *)(&amp;amp;(self-&amp;gt;bucket[self-&amp;gt;bucket_cnt]));
                self-&amp;gt;is_use_gnu_hash = 1;
                break;
            }
        default:
            break;
        }
    }

    //check android rel/rela
    if(0 != self-&amp;gt;relandroid)
    {
        const char *rel = (const char *)self-&amp;gt;relandroid;
        if(self-&amp;gt;relandroid_sz &amp;lt; 4 ||
           rel[0] != &#39;A&#39; ||
           rel[1] != &#39;P&#39; ||
           rel[2] != &#39;S&#39; ||
           rel[3] != &#39;2&#39;)
        {
            XH_LOG_ERROR(&amp;quot;android rel/rela format error\n&amp;quot;);
            return XH_ERRNO_FORMAT;
        }
        
        self-&amp;gt;relandroid += 4;
        self-&amp;gt;relandroid_sz -= 4;
    }

    //check elf info
    if(0 != xh_elf_check(self))
    {
        XH_LOG_ERROR(&amp;quot;elf init check failed. %s&amp;quot;, pathname);
        return XH_ERRNO_FORMAT;
    }
    
#if XH_ELF_DEBUG
    xh_elf_dump(self);
#endif

    XH_LOG_INFO(&amp;quot;init OK: %s (%s %s PLT:%u DYN:%u ANDROID:%u)\n&amp;quot;, self-&amp;gt;pathname,
                self-&amp;gt;is_use_rela ? &amp;quot;RELA&amp;quot; : &amp;quot;REL&amp;quot;,
                self-&amp;gt;is_use_gnu_hash ? &amp;quot;GNU_HASH&amp;quot; : &amp;quot;ELF_HASH&amp;quot;,
                self-&amp;gt;relplt_sz, self-&amp;gt;reldyn_sz, self-&amp;gt;relandroid_sz);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;xh-refresh&#34;&gt;xh_refresh&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;xh_refresh -&amp;gt; xh_core_refresh -&amp;gt; xh_core_init_once

                              -&amp;gt; xh_core_refresh_impl 
   

xh_core_refresh_impl -&amp;gt; xh_core_check_elf_header
                     -&amp;gt; xh_core_hook             -&amp;gt; xh_core_hook_impl
                     
                     
xh_core_hook_impl    -&amp;gt; xh_elf_init
                     -&amp;gt; xh_elf_hook
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;xh-elf-hook&#34;&gt;xh_elf_hook&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;xh_elf_find_symidx_by_name    //find symbol index by symbol name&lt;/li&gt;
&lt;li&gt;replace.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    //find symbol index by symbol name
    if(0 != (r = xh_elf_find_symidx_by_name(self, symbol, &amp;amp;symidx))) return 0;
    
    //replace for .rel(a).plt
    if(0 != self-&amp;gt;relplt)
    {
        xh_elf_plain_reloc_iterator_init(&amp;amp;plain_iter, self-&amp;gt;relplt, self-&amp;gt;relplt_sz, self-&amp;gt;is_use_rela);
        while(NULL != (rel_common = xh_elf_plain_reloc_iterator_next(&amp;amp;plain_iter)))
        {
            if(0 != (r = xh_elf_find_and_replace_func(self,
                                                      (self-&amp;gt;is_use_rela ? &amp;quot;.rela.plt&amp;quot; : &amp;quot;.rel.plt&amp;quot;), 1,
                                                      symbol, new_func, old_func,
                                                      symidx, rel_common, &amp;amp;found))) return r;
            if(found) break;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;xh-elf-find-symidx-by-name&#34;&gt;xh_elf_find_symidx_by_name&lt;/h4&gt;

&lt;p&gt;其中: 寻找symidx, 遍历symtab,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static int xh_elf_find_symidx_by_name(xh_elf_t *self, const char *symbol, uint32_t *symidx)
{
    if(self-&amp;gt;is_use_gnu_hash)
        return xh_elf_gnu_hash_lookup(self, symbol, symidx);
    else
        return xh_elf_hash_lookup(self, symbol, symidx);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;xh-elf-find-and-replace-func&#34;&gt;xh_elf_find_and_replace_func&lt;/h4&gt;

&lt;p&gt;rel, rela表中存放这r_offset, 和symidx.&lt;/p&gt;

&lt;p&gt;真正替换的流程在&lt;strong&gt;xh_elf_find_and_replace_func&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static int xh_elf_find_and_replace_func(xh_elf_t *self, const char *section,
                                        int is_plt, const char *symbol,
                                        void *new_func, void **old_func,
                                        uint32_t symidx, void *rel_common,
                                        int *found)
{
    ElfW(Rela)    *rela;
    ElfW(Rel)     *rel;
    ElfW(Addr)     r_offset;
    size_t         r_info;
    size_t         r_sym;
    size_t         r_type;
    ElfW(Addr)     addr;
    int            r;

    if(NULL != found) *found = 0;
    
    if(self-&amp;gt;is_use_rela)
    {
        rela = (ElfW(Rela) *)rel_common;
        r_info = rela-&amp;gt;r_info;
        r_offset = rela-&amp;gt;r_offset;
    }
    else
    {
        rel = (ElfW(Rel) *)rel_common;
        r_info = rel-&amp;gt;r_info;
        r_offset = rel-&amp;gt;r_offset;
    }

    //check sym
    r_sym = XH_ELF_R_SYM(r_info);
    if(r_sym != symidx) return 0;

    //check type
    r_type = XH_ELF_R_TYPE(r_info);
    if(is_plt &amp;amp;&amp;amp; r_type != XH_ELF_R_GENERIC_JUMP_SLOT) return 0;
    if(!is_plt &amp;amp;&amp;amp; (r_type != XH_ELF_R_GENERIC_GLOB_DAT &amp;amp;&amp;amp; r_type != XH_ELF_R_GENERIC_ABS)) return 0;

    //we found it
    XH_LOG_INFO(&amp;quot;found %s at %s offset: %p\n&amp;quot;, symbol, section, (void *)r_offset);
    if(NULL != found) *found = 1;

    //do replace
    addr = self-&amp;gt;bias_addr + r_offset;
    if(addr &amp;lt; self-&amp;gt;base_addr) return XH_ERRNO_FORMAT;
    if(0 != (r = xh_elf_replace_function(self, symbol, addr, new_func, old_func)))
    {
        XH_LOG_ERROR(&amp;quot;replace function failed: %s at %s\n&amp;quot;, symbol, section);
        return r;
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>InlineHook学习分析</title>
      <link>https://l0phtg.github.io/post/inlinehook%E5%AD%A6%E4%B9%A0%E5%88%86%E6%9E%90/</link>
      <pubDate>Thu, 05 Apr 2018 02:14:31 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/inlinehook%E5%AD%A6%E4%B9%A0%E5%88%86%E6%9E%90/</guid>
      
        <description>&lt;p&gt;分析开源的inlineHook代码, 总结inlineHook的原理与实现.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;本文首发于&lt;strong&gt;看雪论坛&lt;/strong&gt;, 转载请注明出处.&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;最近在面试某大厂的安全岗位时，面试官问到了一些有关hook的知识, 在简单分析了下F8大牛的开源代码之后, 有了这篇文章.&lt;/p&gt;

&lt;h2 id=&#34;参考文章和项目代码&#34;&gt;参考文章和项目代码&lt;/h2&gt;

&lt;p&gt;文章:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://ele7enxxh.com/Android-Arm-Inline-Hook.html
http://gslab.qq.com/portal.php?mod=view&amp;amp;aid=168
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;项目:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https://github.com/ele7enxxh/Android-Inline-Hook
https://github.com/F8LEFT/FAInHook
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使用方法&#34;&gt;使用方法&lt;/h2&gt;

&lt;p&gt;MainActivity:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static {
        System.loadLibrary(&amp;quot;FHook&amp;quot;);
    }
    
public native String stringFromJNI();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们会将会测试Hook 这个&amp;rdquo;stringFromJNI()&amp;ldquo;函数.&lt;/p&gt;

&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;

&lt;h4 id=&#34;使用&#34;&gt;使用&lt;/h4&gt;

&lt;p&gt;在native层, 我们的main.cpp中&lt;/p&gt;

&lt;p&gt;会在JNI_OnLoad中有一个init函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;jstring stringFromJNI(
        JNIEnv *env,
        jobject ) {
     doInHook();
    // doGotHook();
    return env-&amp;gt;NewStringUTF(getStr());
}

JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void *reserved) {
    JNIEnv* env = nullptr;
    jint resultstr = -1;
    if (vm-&amp;gt;GetEnv((void **) &amp;amp;env, JNI_VERSION_1_6) != JNI_OK) {
        return -1;
    }

    auto jclazz = env-&amp;gt;FindClass(&amp;quot;com/example/l0phtg/hookstudyf8/MainActivity&amp;quot;);
    JNINativeMethod natives[] = {
            {&amp;quot;stringFromJNI&amp;quot;, &amp;quot;()Ljava/lang/String;&amp;quot;, (void*)stringFromJNI}};
    env-&amp;gt;RegisterNatives(jclazz, natives, 1);
    env-&amp;gt;DeleteLocalRef(jclazz);

    init();

    return JNI_VERSION_1_6;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Hook.cpp我们来看一下init函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool init() {
    auto hook = FAInHook::instance();
    hook-&amp;gt;registerHook((Elf_Addr)getStr,
                       (Elf_Addr)inlCallback,
                       (Elf_Addr*)&amp;amp;inlCallbackSrc);
    auto lib = dlopen(&amp;quot;libFHook.so&amp;quot;, RTLD_NOW);
    gotCallbackSrc = (const char* (*)())dlsym(lib, &amp;quot;_Z6getStrv&amp;quot;);
    dlclose(lib);

    return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到, 我们实例化了一个FAInHook对象, &lt;code&gt;new FAInHook()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;并调用了&lt;code&gt;registerHook&lt;/code&gt;函数来注册对getStr的hook.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;
FAInHook *FAInHook::instance() {
    static FAInHook* mIns = nullptr;
    if(mIns == nullptr) {
        mIns = new FAInHook();
    }
    return mIns;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们在使用是还会用到的&lt;code&gt;doInHook&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bool doInHook() {
    static bool isHooked = false;
    if (isHooked) {
        isHooked = false;
        FAInHook::instance()-&amp;gt;unhookAll();
    } else {
        isHooked = true;
        FAInHook::instance()-&amp;gt;hookAll();
    }
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;现在可以看到, 我们主要的任务就是分析&lt;code&gt;registerHook&lt;/code&gt;和&lt;code&gt;doInHook&lt;/code&gt;这两个函数的实现.&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;registerhook函数&#34;&gt;registerHook函数&lt;/h4&gt;

&lt;p&gt;我们现在主要分析&lt;code&gt;registerHook&lt;/code&gt;函数.&lt;/p&gt;

&lt;p&gt;先来分析参数:
在Hook之前我们首先要注册这个函数&lt;/p&gt;

&lt;p&gt;函数申明:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    HOOK_STATUS registerHook(Elf_Addr orginalFunAddr, Elf_Addr newFunAddr,
                             Elf_Addr* callOrigin);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数(原始函数地址, 新函数地址, 调用原始函数).&lt;/p&gt;

&lt;p&gt;函数主要流程:
1. 注册函数信息, 计算hook stub.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;首先判断`originFunAddr`和`newFunAddr`是否是函数地址.

auto info = getHookInfo(originFunAddr); 得到函数信息

然后判断函数是否已经被Hook. 
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;检查判断指令类型(thumb or arm or x86 &amp;hellip;)&lt;/li&gt;
&lt;li&gt;createStub(info)     创建stub, 就是thumb下创建ldr.w pc, [pc],   addr 来执行跳转到newFuncAddr功能&lt;/li&gt;
&lt;li&gt;createCallOriginalStub(info) 创建originalFunAddr的stub, 主要会涉及一些对pc相关指令的处理.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;//  register hook
FAInHook::HOOK_STATUS FAInHook::registerHook(
        Elf_Addr orginalFunAddr, Elf_Addr newFunAddr, Elf_Addr *callOrigin) {
    // register hook information, calc hook stub at the same time.
    if(!FAHook::MemHelper::isFunctionAddr((void *) orginalFunAddr)
       || !FAHook::MemHelper::isFunctionAddr((void *) newFunAddr)) {
        return FERROR_NOT_EXECUTABLE;
    }

    auto info = getHookInfo(orginalFunAddr);
    if(nullptr != info) {
        auto hookStatus = info-&amp;gt;getHookStatus();
        if(FAHook::HOOKED == hookStatus) {
            return FERROR_ALREADY_HOOKED;
        } else if(FAHook::REGISTERED == hookStatus) {
            delHookInfo(info);
        }
    }

    // check for FunctionType
    auto type = FAHook::Instruction::getFunctionType(orginalFunAddr);
    if(FAHook::ERRTYPE == type) {
        return FERROR_UNKNOWN;
    }

    info = new FAHook::HookInfo((void *) orginalFunAddr, (void *) newFunAddr);
    info-&amp;gt;setOriginalFunctionType(type);

    FAHook::Instruction* instruction = nullptr;
    switch(type) {
#if defined(__arm__)
        case FAHook::ARM:
            instruction = new FAHook::ArmInstruction();
            break;
        case FAHook::THUMB:
            instruction = new FAHook::ThumbInstruction();
            break;
#elif defined(__aarch64__)
        case FAHook::ARM64:
            instruction = new FAHook::Arm64Instruction();
            break;
#elif defined(__i386__) || defined(__x86_64__)
        case FAHook::X86:
        case FAHook::X64:
            instruction = new FAHook::IntelInstruction();
            break;
#elif defined(__mips64__)
            case FAHook::MIPS64:
            instruction = new FAHook::Mips64Instruction();
            break;
#elif defined(__mips__)
        case FAHook::MIPS:
            instruction = new FAHook::MipsInstruction();
            break;
#endif
        default:
            assert(false &amp;amp;&amp;amp; &amp;quot;not support abi&amp;quot;);
            return FERROR_UNKNOWN;
            break;
    }

    if(!instruction-&amp;gt;createStub(info)
       || !instruction-&amp;gt;createBackStub(info)
       || (callOrigin != nullptr) ?
            !instruction-&amp;gt;createCallOriginalStub(info) : false  // want a callback
       ) {
        delete instruction;
        delete info;
        return FERROR_MEMORY;
    }

    addHookInfo(info);
    info-&amp;gt;setHookStatus(FAHook::REGISTERED);

    if(callOrigin != nullptr) {
        *callOrigin = (Elf_Addr) info-&amp;gt;getCallOriginalIns();
    }

    delete instruction;
    return FERROR_SUCCESS;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;判断该地址是否是函数地址&#34;&gt;判断该地址是否是函数地址&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;打开&lt;code&gt;/proc/self/maps&lt;/code&gt;， 读取每行的信息, 用strstr根据权限做出判断.(r-x, 表示可读可执行, 即为code)()&lt;/li&gt;
&lt;li&gt;addr &amp;gt;= startAddr &amp;amp;&amp;amp; addr &amp;lt;= endAddr&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;bool FAHook::MemHelper::isFunctionAddr(void *addr) {
    char buf[MAX_BUF];
    auto fp = fopen(maps, &amp;quot;r&amp;quot;);
    if(nullptr == fp) {
        return false;
    }

    while(fgets(buf, MAX_BUF, fp)) {
        if(strstr(buf, &amp;quot;r-xp&amp;quot;) != nullptr) {
            void* startAddr = (void*)strtoul(strtok(buf, &amp;quot;-&amp;quot;), nullptr, 16);
            void* endAddr = (void*)strtoul(strtok(nullptr, &amp;quot; &amp;quot;), nullptr, 16);
            if(addr &amp;gt;= startAddr &amp;amp;&amp;amp; addr &amp;lt;= endAddr) {
                fclose(fp);
                return true;
            }
        }
    }
    fclose(fp);
    FLOGE(this functionAddr is not a function!);
    return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;得到hook地址的信息-是否已经hook&#34;&gt;得到Hook地址的信息, 是否已经Hook.&lt;/h5&gt;

&lt;p&gt;hook_map是一个std::map&lt;Elf_Addr, FAInHook::HookInfo*&gt;的map类型. find函数会返回返回一个迭代器, 可以用&lt;code&gt;it-&amp;gt;first&lt;/code&gt;和&lt;code&gt;it-&amp;gt;second&lt;/code&gt;来访问它的成员(key和value). 这个过程其实对已经注册过的hook函数的处理.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FAHook::HookInfo *FAInHook::getHookInfo(Elf_Addr origFunAddr) {
    auto it = hook_map.find(origFunAddr);
    if(it == hook_map.end()) {
        return nullptr;
    }
    return it-&amp;gt;second;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;得到originlfunaddr的指令类型&#34;&gt;得到originlFunAddr的指令类型,&lt;/h5&gt;

&lt;p&gt;auto type = FAHook::Instruction::getFunctionType(orginalFunAddr);&lt;/p&gt;

&lt;p&gt;下面是&lt;code&gt;getFunctionAddr&lt;/code&gt;的实现, 可以看到. 判断指令类型的方式, 是通过自己定义宏来实现的. 当然, 在Arm指令中, 我们还要是否该指令为thumb指令.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;static FunctionType getFunctionType(Elf_Addr functionAddr) {
#if defined(__arm__)
            if(0 == functionAddr) {
                return ERRTYPE;
            } else if((functionAddr &amp;amp; 3) == 0) {
                return ARM;
            } else {
                return THUMB;
            }
#elif defined(__aarch64__)
            return ARM64;
#elif defined(__i386__)
            return X86;
#elif defined(__x86_64__)
            return X64;
#elif defined(__mips64__)  /* mips64el-* toolchain defines __mips__ too */
            return MIPS64;
#elif defined(__mips__)
            return MIPS;
#endif
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;接下来-我们分析最重要的过程&#34;&gt;接下来, 我们分析最重要的过程:&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;info = new HookInfo(originFunAddr, newFunAddr);&lt;/li&gt;
&lt;li&gt;info.setOriginalFunctionType(type);   设置指令类型为(Arm或者thumb)&lt;/li&gt;
&lt;li&gt;instruction = new FAHook::ArmInstruction();        new arm或者thumb指令. 我发现无构造函数.&lt;/li&gt;
&lt;li&gt;instruction-&amp;gt;createStub(info);        创建stub.(stub为 jump stub来jump到newFuncAddr)&lt;/li&gt;
&lt;li&gt;instruction-&amp;gt;createCallOriginalStub(info)    创建原函数的call back stub.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在看&lt;code&gt;HookInfo.h&lt;/code&gt;时, 我们可以看到&lt;code&gt;FAHook&lt;/code&gt;是一个&lt;code&gt;namespace&lt;/code&gt;, 而里面主要包含了一个&lt;code&gt;HookInfo&lt;/code&gt;的类:&lt;/p&gt;

&lt;p&gt;我们先来分析它的构造函数:&lt;/p&gt;

&lt;p&gt;这里运用了c++中的构造函数初始化列表来初始化类成员.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        HookInfo(void* originalAddr, void* hookAddr)
            : original_addr_(originalAddr), hook_addr_(hookAddr),
              original_stub_back_(nullptr), back_len_(0), call_original_ins_(nullptr),
              hook_status_(ERRSTATUS),
              original_function_type_(ERRTYPE), hook_function_type_(ERRTYPE){}
              

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分析&lt;code&gt;createStub(info)&lt;/code&gt;
我们这里分析&lt;code&gt;FAHook::ThumbInstrution::createStub(FAHook::HookInfo *info)&lt;/code&gt;:
1. 将地址按4字节对齐.
2. 保存我们的stub指令, (方便之后path)指令为: &lt;code&gt;LDR.W PC, [PC]&lt;/code&gt;. 可参考(&lt;a href=&#34;http://ele7enxxh.com/Android-Arm-Inline-Hook.html&#34;&gt;http://ele7enxxh.com/Android-Arm-Inline-Hook.html&lt;/a&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bool FAHook::ThumbInstruction::createStub(FAHook::HookInfo *info) {
    auto stubSize = 0;
    uint8_t *stub = nullptr;

    uint32_t addr = (uint32_t)info-&amp;gt;getOriginalAddr();
    auto clearBit0 = addr &amp;amp; 0xFFFFFFFE;

    if (clearBit0 % 4 != 0) {                       // need to align 4, just patch with nop
        stub = new uint8_t[10];
        ((uint16_t*)stub)[stubSize++] = 0xBF00;     //NOP
    } else {
        stub = new uint8_t[8];
    }
    ((uint16_t*)stub)[stubSize++] = 0xF8DF;
    ((uint16_t*)stub)[stubSize++] = 0xF000; // LDR.W PC, [PC]
    ((uint16_t*)stub)[stubSize++] = (uint32_t)info-&amp;gt;getHookAddr() &amp;amp; 0xFFFF;
    ((uint16_t*)stub)[stubSize++] = (uint32_t)info-&amp;gt;getHookAddr() &amp;gt;&amp;gt; 16;

    info-&amp;gt;setJumpStubLen(stubSize * 2);
    info-&amp;gt;setJumpStubBack(stub);
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;下面分析-createcalloriginalstub-hookinfo-info&#34;&gt;下面分析 &lt;code&gt;createCallOriginalStub(HookInfo *info)&lt;/code&gt;:&lt;/h5&gt;

&lt;p&gt;thumbInstruction.cpp的实现:&lt;/p&gt;

&lt;p&gt;基础知识:&lt;/p&gt;

&lt;p&gt;reinterpret_cast&lt;uint16_t*&gt;   为类型转换&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;处理ldr.w指令.&lt;/li&gt;
&lt;li&gt;调用createExecMemory(length);              // 分配buffer空间&lt;/li&gt;
&lt;li&gt;修正pc相关指令. (ldr liternal.  b.  b.  bl.  cbz. ldrw. add)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;为什么要修正pc相关指令?&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;举例分析: b &amp;lt;label&amp;gt;:
指令编码分析: [15:12] 1101 [11:8] cond [7:0] imm8
解析时: imm32 = ZeroExtend(imm8:&#39;0&#39;, 32); 
        BranchWritePC(PC+imm32)
可以看到, b指令的指令编码中, 存放的立即数为imm8, 而真实的跳转地址为(pc + imm32).
由于我们是要inlineHook, 所以我们的hook函数执行完成之后还有继续执行我们原来的函数,那么我们就要执行被patch掉的那些指令（我们已经将这些指令保存了下来），但由于存放这些指令的内存是我们mmap出来的,所以我们 要想能够在这里成功运行pc相关指令的话, 我们需要将pc相关的指令转换为其它pc无关的指令。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;inlineHook原理图, 来源于gslab.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://gslab.qq.com/data/attachment/portal/201605/04/165921tz43a3sm4vi2s4s4.png&#34; alt=&#34;inlineHook原理图 ---  来源于gslab&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool FAHook::ThumbInstruction::createCallOriginalStub(FAHook::HookInfo *info) {
    uint16_t *area(reinterpret_cast&amp;lt;uint16_t *&amp;gt;(getOriginalAddr(info)));    // 起始地址


    uint16_t *trail(reinterpret_cast&amp;lt;uint16_t *&amp;gt;(
                            reinterpret_cast&amp;lt;uintptr_t &amp;gt;(area) + info-&amp;gt;getJumpStubLen())); // 结束地址

    if(T$pcrel$ldrw(area[0]) &amp;amp;&amp;amp;  // 第一条指令
        area[1] == 0xF000   // 判断第一条指令是否为 ldr pc, [pc]  
            ) {
        uint32_t *arm(reinterpret_cast&amp;lt;uint32_t *&amp;gt;(area));
        info-&amp;gt;setCallOriginalIns(reinterpret_cast&amp;lt;uint8_t *&amp;gt;(arm[1]));
        return true;
    }

    size_t required((trail - area) * sizeof(uint16_t)); // required == 需要patch多少字节

    size_t used(0);
    while (used &amp;lt; required)
        used += MSGetInstructionWidthThumb(reinterpret_cast&amp;lt;uint8_t *&amp;gt;(area) + used);
    used = (used + sizeof(uint16_t) - 1) / sizeof(uint16_t) * sizeof(uint16_t);

    size_t blank((used - required) / sizeof(uint16_t));

    uint16_t backup[used / sizeof(uint16_t)];
    memcpy(backup, area, used);


    size_t length(used);
    for (unsigned offset(0); offset != used / sizeof(uint16_t); ++offset)
        if (T$pcrel$ldr(backup[offset]))
            length += 3 * sizeof(uint16_t);
        else if (T$pcrel$b(backup[offset]))
            length += 6 * sizeof(uint16_t);
        else if (T2$pcrel$b(backup + offset)) {
            length += 5 * sizeof(uint16_t);
            ++offset;
        } else if (T$pcrel$bl(backup + offset)) {
            length += 5 * sizeof(uint16_t);
            ++offset;
        } else if (T$pcrel$cbz(backup[offset])) {
            length += 16 * sizeof(uint16_t);
        } else if (T$pcrel$ldrw(backup[offset])) {
            length += 4 * sizeof(uint16_t);
            ++offset;
        } else if (T$pcrel$add(backup[offset]))
            length += 6 * sizeof(uint16_t);
        else if (T$32bit$i(backup[offset]))
            ++offset;

        unsigned pad((length &amp;amp; 0x2) == 0 ? 0 : 1);
        length += (pad + 2) * sizeof(uint16_t) + 2 * sizeof(uint32_t);

    uint16_t *buffer = (uint16_t *) MemHelper::createExecMemory(length);
    if(buffer == nullptr) {
        return false;
    }

    size_t start(pad), end(length / sizeof(uint16_t));
    uint32_t *trailer(reinterpret_cast&amp;lt;uint32_t *&amp;gt;(buffer + end));
    for (unsigned offset(0); offset != used / sizeof(uint16_t); ++offset) {
        if (T$pcrel$ldr(backup[offset])) {
            union {
                uint16_t value;

                struct {
                    uint16_t immediate : 8;
                    uint16_t rd : 3;
                    uint16_t : 5;
                };
            } bits = {backup[offset+0]};

            buffer[start+0] = T$ldr_rd_$pc_im_4$(bits.rd, T$Label(start+0, end-2) / 4);
            buffer[start+1] = T$ldr_rd_$rn_im_4$(bits.rd, bits.rd, 0);

            // XXX: this code &amp;quot;works&amp;quot;, but is &amp;quot;wrong&amp;quot;: the mechanism is more complex than this
            *--trailer = ((reinterpret_cast&amp;lt;uint32_t&amp;gt;(area + offset) + 4) &amp;amp; ~0x2) + bits.immediate * 4;

            start += 2;
            end -= 2;
        } else if (T$pcrel$b(backup[offset])) {
            union {
                uint16_t value;

                struct {
                    uint16_t imm8 : 8;
                    uint16_t cond : 4;
                    uint16_t /*1101*/ : 4;
                };
            } bits = {backup[offset+0]};

            intptr_t jump(bits.imm8 &amp;lt;&amp;lt; 1);
            jump |= 1;
            jump &amp;lt;&amp;lt;= 23;
            jump &amp;gt;&amp;gt;= 23;

            buffer[start+0] = T$b$_$im(bits.cond, (end-6 - (start+0)) * 2 - 4);

            *--trailer = reinterpret_cast&amp;lt;uint32_t&amp;gt;(area + offset) + 4 + jump;
            *--trailer = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);
            *--trailer = T$nop &amp;lt;&amp;lt; 16 | T$bx(A$pc);

            start += 1;
            end -= 6;
        } else if (T2$pcrel$b(backup + offset)) {
            union {
                uint16_t value;

                struct {
                    uint16_t imm6 : 6;
                    uint16_t cond : 4;
                    uint16_t s : 1;
                    uint16_t : 5;
                };
            } bits = {backup[offset+0]};

            union {
                uint16_t value;

                struct {
                    uint16_t imm11 : 11;
                    uint16_t j2 : 1;
                    uint16_t a : 1;
                    uint16_t j1 : 1;
                    uint16_t : 2;
                };
            } exts = {backup[offset+1]};

            intptr_t jump(1);
            jump |= exts.imm11 &amp;lt;&amp;lt; 1;
            jump |= bits.imm6 &amp;lt;&amp;lt; 12;

            if (exts.a) {
                jump |= bits.s &amp;lt;&amp;lt; 24;
                jump |= (~(bits.s ^ exts.j1) &amp;amp; 0x1) &amp;lt;&amp;lt; 23;
                jump |= (~(bits.s ^ exts.j2) &amp;amp; 0x1) &amp;lt;&amp;lt; 22;
                jump |= bits.cond &amp;lt;&amp;lt; 18;
                jump &amp;lt;&amp;lt;= 7;
                jump &amp;gt;&amp;gt;= 7;
            } else {
                jump |= bits.s &amp;lt;&amp;lt; 20;
                jump |= exts.j2 &amp;lt;&amp;lt; 19;
                jump |= exts.j1 &amp;lt;&amp;lt; 18;
                jump &amp;lt;&amp;lt;= 11;
                jump &amp;gt;&amp;gt;= 11;
            }

            buffer[start+0] = T$b$_$im(exts.a ? A$al : bits.cond, (end-6 - (start+0)) * 2 - 4);

            *--trailer = reinterpret_cast&amp;lt;uint32_t&amp;gt;(area + offset) + 4 + jump;
            *--trailer = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);
            *--trailer = T$nop &amp;lt;&amp;lt; 16 | T$bx(A$pc);

            ++offset;
            start += 1;
            end -= 6;
        } else if (T$pcrel$bl(backup + offset)) {
            union {
                uint16_t value;

                struct {
                    uint16_t immediate : 10;
                    uint16_t s : 1;
                    uint16_t : 5;
                };
            } bits = {backup[offset+0]};

            union {
                uint16_t value;

                struct {
                    uint16_t immediate : 11;
                    uint16_t j2 : 1;
                    uint16_t x : 1;
                    uint16_t j1 : 1;
                    uint16_t : 2;
                };
            } exts = {backup[offset+1]};

            int32_t jump(0);
            jump |= bits.s &amp;lt;&amp;lt; 24;
            jump |= (~(bits.s ^ exts.j1) &amp;amp; 0x1) &amp;lt;&amp;lt; 23;
            jump |= (~(bits.s ^ exts.j2) &amp;amp; 0x1) &amp;lt;&amp;lt; 22;
            jump |= bits.immediate &amp;lt;&amp;lt; 12;
            jump |= exts.immediate &amp;lt;&amp;lt; 1;
            jump |= exts.x;
            jump &amp;lt;&amp;lt;= 7;
            jump &amp;gt;&amp;gt;= 7;

            buffer[start+0] = T$push_r(1 &amp;lt;&amp;lt; A$r7);
            buffer[start+1] = T$ldr_rd_$pc_im_4$(A$r7, ((end-2 - (start+1)) * 2 - 4 + 2) / 4);
            buffer[start+2] = T$mov_rd_rm(A$lr, A$r7);
            buffer[start+3] = T$pop_r(1 &amp;lt;&amp;lt; A$r7);
            buffer[start+4] = T$blx(A$lr);

            *--trailer = reinterpret_cast&amp;lt;uint32_t&amp;gt;(area + offset) + 4 + jump;

            ++offset;
            start += 5;
            end -= 2;
        } else if (T$pcrel$cbz(backup[offset])) {
            union {
                uint16_t value;

                struct {
                    uint16_t rn : 3;
                    uint16_t immediate : 5;
                    uint16_t : 1;
                    uint16_t i : 1;
                    uint16_t : 1;
                    uint16_t op : 1;
                    uint16_t : 4;
                };
            } bits = {backup[offset+0]};

            intptr_t jump(1);
            jump |= bits.i &amp;lt;&amp;lt; 6;
            jump |= bits.immediate &amp;lt;&amp;lt; 1;

            //jump &amp;lt;&amp;lt;= 24;
            //jump &amp;gt;&amp;gt;= 24;

            unsigned rn(bits.rn);
            unsigned rt(rn == A$r7 ? A$r6 : A$r7);

            buffer[start+0] = T$push_r(1 &amp;lt;&amp;lt; rt);
            buffer[start+1] = T1$mrs_rd_apsr(rt);
            buffer[start+2] = T2$mrs_rd_apsr(rt);
            buffer[start+3] = T$cbz$_rn_$im(bits.op, rn, (end-10 - (start+3)) * 2 - 4);
            buffer[start+4] = T1$msr_apsr_nzcvqg_rn(rt);
            buffer[start+5] = T2$msr_apsr_nzcvqg_rn(rt);
            buffer[start+6] = T$pop_r(1 &amp;lt;&amp;lt; rt);

            *--trailer = reinterpret_cast&amp;lt;uint32_t&amp;gt;(area + offset) + 4 + jump;
            *--trailer = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);
            *--trailer = T$nop &amp;lt;&amp;lt; 16 | T$bx(A$pc);
            *--trailer = T$nop &amp;lt;&amp;lt; 16 | T$pop_r(1 &amp;lt;&amp;lt; rt);
            *--trailer = T$msr_apsr_nzcvqg_rn(rt);

#if 0
            if ((start &amp;amp; 0x1) == 0)
                buffer[start++] = T$nop;
            buffer[start++] = T$bx(A$pc);
            buffer[start++] = T$nop;

            uint32_t *arm(reinterpret_cast&amp;lt;uint32_t *&amp;gt;(buffer + start));
            arm[0] = A$add(A$lr, A$pc, 1);
            arm[1] = A$ldr_rd_$rn_im$(A$pc, A$pc, (trailer - arm) * sizeof(uint32_t) - 8);
#endif

            start += 7;
            end -= 10;
        } else if (T$pcrel$ldrw(backup[offset])) {
            union {
                uint16_t value;

                struct {
                    uint16_t : 7;
                    uint16_t u : 1;
                    uint16_t : 8;
                };
            } bits = {backup[offset+0]};

            union {
                uint16_t value;

                struct {
                    uint16_t immediate : 12;
                    uint16_t rt : 4;
                };
            } exts = {backup[offset+1]};

            buffer[start+0] = T1$ldr_rt_$rn_im$(exts.rt, A$pc, T$Label(start+0, end-2));
            buffer[start+1] = T2$ldr_rt_$rn_im$(exts.rt, A$pc, T$Label(start+0, end-2));

            buffer[start+2] = T1$ldr_rt_$rn_im$(exts.rt, exts.rt, 0);
            buffer[start+3] = T2$ldr_rt_$rn_im$(exts.rt, exts.rt, 0);

            // XXX: this code &amp;quot;works&amp;quot;, but is &amp;quot;wrong&amp;quot;: the mechanism is more complex than this
            *--trailer = ((reinterpret_cast&amp;lt;uint32_t&amp;gt;(area + offset) + 4) &amp;amp; ~0x2) + (bits.u == 0 ? -exts.immediate : exts.immediate);

            ++offset;
            start += 4;
            end -= 2;
        } else if (T$pcrel$add(backup[offset])) {
            union {
                uint16_t value;

                struct {
                    uint16_t rd : 3;
                    uint16_t rm : 3;
                    uint16_t h2 : 1;
                    uint16_t h1 : 1;
                    uint16_t : 8;
                };
            } bits = {backup[offset+0]};

            if (bits.h1) {
                return false;
            }

            unsigned rt(bits.rd == A$r7 ? A$r6 : A$r7);

            buffer[start+0] = T$push_r(1 &amp;lt;&amp;lt; rt);
            buffer[start+1] = T$mov_rd_rm(rt, (bits.h1 &amp;lt;&amp;lt; 3) | bits.rd);
            buffer[start+2] = T$ldr_rd_$pc_im_4$(bits.rd, T$Label(start+2, end-2) / 4);
            buffer[start+3] = T$add_rd_rm((bits.h1 &amp;lt;&amp;lt; 3) | bits.rd, rt);
            buffer[start+4] = T$pop_r(1 &amp;lt;&amp;lt; rt);
            *--trailer = reinterpret_cast&amp;lt;uint32_t&amp;gt;(area + offset) + 4;

            start += 5;
            end -= 2;
        } else if (T$32bit$i(backup[offset])) {
            buffer[start++] = backup[offset];
            buffer[start++] = backup[++offset];
        } else {
            buffer[start++] = backup[offset];
        }
    }

    buffer[start++] = T$bx(A$pc);
    buffer[start++] = T$nop;

    uint32_t *transfer = reinterpret_cast&amp;lt;uint32_t *&amp;gt;(buffer + start);
    transfer[0] = A$ldr_rd_$rn_im$(A$pc, A$pc, 4 - 8);
    transfer[1] = reinterpret_cast&amp;lt;uint32_t&amp;gt;(area + used / sizeof(uint16_t)) + 1;

    info-&amp;gt;setCallOriginalIns(reinterpret_cast&amp;lt;uint8_t *&amp;gt;(buffer + pad) + 1);

    return true;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;msgetinstructionwiththumb&#34;&gt;MSGetInstructionWithThumb&lt;/h5&gt;

&lt;p&gt;调用    used += MSGetInstructionWithThumb(reinterpret_cast&lt;uint8_t *&gt;(area) + used);
MSGetInstructionWithThumb: 参数为(uint16_t*).
返回结果: 为这条指令是多少字节的指令.(4 or 2)&lt;/p&gt;

&lt;p&gt;T$32bit$i的作用: (指令(ic) &amp;amp; 1110 0000 0000 0000) &amp;amp;&amp;amp; (ic &amp;amp; 0001 1000 0000 0000 != 0x0000);
第一个判断为确定高位3个bit(即bit[15], bit[14], bit[13])为1. 第二个判断为确保bit[12], bit[11]有值(即至少这两位有 1 位为 1).&lt;/p&gt;

&lt;p&gt;&lt;code&gt;其实就是判断是该thumb指令是否为thumb32指令,&lt;/code&gt;
&lt;code&gt;thumb32指令的判断依据是 b[15:11] 为 0b11101或0b11110或0b11111.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;MSGetInstructionWithThumb:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;        static size_t MSGetInstructionWidthThumb(void *start) {
            uint16_t *thumb(reinterpret_cast&amp;lt;uint16_t *&amp;gt;(start));   //
            return T$32bit$i(thumb[0]) ? 4 : 2;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;T$32bit$i:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;        static inline bool T$32bit$i(uint16_t ic) {
            return ((ic &amp;amp; 0xe000) == 0xe000 &amp;amp;&amp;amp; (ic &amp;amp; 0x1800) != 0x0000);
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;分析memhelper类&#34;&gt;分析MemHelper类&lt;/h4&gt;

&lt;p&gt;有4个方法:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;static bool isFunctionAddr(void* addr);&lt;/li&gt;
&lt;li&gt;static bool unProtectMemory(void* addr, uint32_t size);  remove 写保护&lt;/li&gt;
&lt;li&gt;static bool protectMemory(void* addr, uint32_t size);    add    写保护&lt;/li&gt;
&lt;li&gt;static void* createExecMemory(uint32_t size);            创建一个可执行的内存&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有4个field:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;std::vector&lt;void*&gt; all_memory_page;&lt;/li&gt;
&lt;li&gt;void* current_page = nullptr;&lt;/li&gt;
&lt;li&gt;uint32_t page_ptr  = 0;&lt;/li&gt;
&lt;li&gt;static uint32_t page_size;      // 构造函数&lt;code&gt;page_size = sysconf(_SC_PAGESIZE).&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们现在分析一下&lt;code&gt;createExecMemory(uint32_t size)&lt;/code&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;可以看到, 分配内存的操作是通过&lt;code&gt;mmap&lt;/code&gt;实现的.&lt;/li&gt;
&lt;li&gt;all_memory_page是一个vector, 每个单位保存一个指针, 指向mmap的内存.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;createExecMemory:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void *FAHook::MemHelper::createExecMemory(uint32_t size) {
    if(size &amp;amp; 1) {
        size ++;
    }
    if(size &amp;gt; page_size) {
        return nullptr;
    }
    if(gMemHelper.current_page != nullptr &amp;amp;&amp;amp; page_size - gMemHelper.page_ptr_ &amp;gt;= size) {
        auto funPtr = (void*)((size_t)gMemHelper.current_page + gMemHelper.page_ptr_);
        gMemHelper.page_ptr_ += size;
        // Align 4
        while(gMemHelper.page_ptr_ &amp;amp; 0x3) {
            gMemHelper.page_ptr_ ++;
        }
        return funPtr;
    }
    // scroll to next page
    auto newPage = mmap(nullptr, page_size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANONYMOUS | MAP_PRIVATE, 0, 0);
    if(newPage != MAP_FAILED) {
        gMemHelper.alloc_memory_page_.push_back(newPage);

        gMemHelper.current_page = newPage;
        gMemHelper.page_ptr_ = 0;
        return createExecMemory(size);
    }
    return nullptr;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;分析doinhook&#34;&gt;分析doInHook&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;主要操作: FAInHook::instance()-&amp;gt;hookAll();&lt;/li&gt;
&lt;li&gt;FAInHook::instance()-&amp;gt;unHookAll();&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool doInHook() {
    static bool isHooked = false;
    if (isHooked) {
        isHooked = false;
        FAInHook::instance()-&amp;gt;unhookAll();
    } else {
        isHooked = true;
        FAInHook::instance()-&amp;gt;hookAll();
    }
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;hookAll():&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void FAInHook::hookAll() {
    for(auto it: hook_map) {
        if(it.second-&amp;gt;getHookStatus() == FAHook::REGISTERED) {
            Hook(it.second);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进而转到Hook函数
1. 调用`enableJumpStub(info)
2. info-&amp;gt;setHookStatus(FAHook::HOOKED)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bool FAInHook::Hook(FAHook::HookInfo *info) {
    if(!FAHook::Instruction::enableJumpStub(info)) {
        return false;
    }
    info-&amp;gt;setHookStatus(FAHook::HOOKED);
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分析&lt;code&gt;enableJumpStub(info)&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bool FAHook::Instruction::enableJumpStub(FAHook::HookInfo *info) {
    auto origAddr = getOriginalAddr(info);
    auto len = info-&amp;gt;getJumpStubLen();
    auto stubAddr = info-&amp;gt;getJumpStubBack();
    return patchMemory(origAddr, stubAddr, len);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到, 在得到了&lt;code&gt;origAddr&lt;/code&gt;和&lt;code&gt;stubAddr&lt;/code&gt;和&lt;code&gt;len&lt;/code&gt;之后,我们会进入到patch函数&lt;code&gt;patchMemory&lt;/code&gt;, 根据我们前面的分析, 它会patch原函数的入口指令的前(8 or 10?)个字节.&lt;/p&gt;

&lt;p&gt;patchMemory:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bool FAHook::Instruction::patchMemory(void *dest, void *src, uint32_t len) {
    if(dest == nullptr || src == nullptr || len == 0) {
        return false;
    }
    if(!MemHelper::unProtectMemory(dest, len)) {
        return false;
    }

    memcpy(dest, src, len);
    MemHelper::protectMemory(dest, len);
#ifdef __arm__
    cacheflush((Elf_Addr)dest, (Elf_Addr)dest + len, 0);
#endif
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先会调用&lt;code&gt;unProtectMemory&lt;/code&gt;函数来将对应内存修改为(rwx), 然后调用&lt;code&gt;memcpy&lt;/code&gt;来修改内存, 最后调用&lt;code&gt;protectMemory&lt;/code&gt;来修改对应内存为(r-x).&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;现在我们就基本对该项目进行了简单的分析, 我这里总结一下:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;registerHook
主要操作其实就是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;createStub:  创建代理(这个代理就是要执行跳转到我们的&lt;code&gt;newFuncAddr&lt;/code&gt;函数)&lt;/li&gt;
&lt;li&gt;createCallOriginalStub:  call back代理(这个代理就是执行回调, 回调我们的&lt;code&gt;originalFunAddr&lt;/code&gt;.) 主要涉及处理pc相关指令(原因在文中已经有介绍).
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;doInHook&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;主要就是patchMemory. patch我们originalFunAddr的函数起始处的几个指令为&lt;code&gt;stubInstruction&lt;/code&gt;.之后函数涉及pc相关指令的修复, 方便继续执行原函数.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;unHook&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;也是patchMemory.
就是将我们原函数的原始指令进行复原.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
      
    </item>
    
    <item>
      <title>装机日志-deepin</title>
      <link>https://l0phtg.github.io/post/%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97-deepin/</link>
      <pubDate>Thu, 28 Dec 2017 11:47:58 +0000</pubDate>
      
      <guid>https://l0phtg.github.io/post/%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97-deepin/</guid>
      
        <description>&lt;p&gt;17年使用了一段时间deepin系统, 这里简单记录一些使用心得(现在已转ubuntu.&lt;/p&gt;

&lt;p&gt;主要就是&lt;strong&gt;装机的过程&lt;/strong&gt;, 以及&lt;strong&gt;装机后的效果展示&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/deepin/desktop.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;最近一直在码代码和写.md, 深刻体会到在windows上办公有多么艰难. 安装了一下&lt;code&gt;spacevim/neovim&lt;/code&gt;后, 意识到了高效率的办公会给人带来很大的乐趣. 所以, 在遇到了很多与环境配置相关的问题(却解决不了之后), 毅然决定更换系统.&lt;/p&gt;

&lt;h2 id=&#34;选择&#34;&gt;选择&lt;/h2&gt;

&lt;p&gt;犹豫了一天到底是该装&lt;code&gt;Ubuntu16.04&lt;/code&gt;还是&lt;code&gt;deepin&lt;/code&gt;(&lt;code&gt;导致上课前, 忘了给舍友刷卡...&lt;/code&gt;).最终还是经不住deepin&lt;code&gt;绚丽的UI设计&lt;/code&gt;的诱惑, 决定尝试一下&lt;code&gt;deepin&lt;/code&gt;.(&lt;strong&gt;没错, 颜值在我心中就是这么重要&lt;/strong&gt;)&lt;/p&gt;

&lt;h2 id=&#34;装机过程&#34;&gt;装机过程&lt;/h2&gt;

&lt;p&gt;装机过程很简单, 下载好官方的镜像源, 之后检验一下&lt;strong&gt;md5&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$checksum  

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后用&lt;strong&gt;官方的启动盘制作工具&lt;/strong&gt;把U盘装入deepin, 重启时插入U盘, 设置为U盘启动就可以了.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重点来了&lt;/strong&gt;, 因为我不想用windows10了, 所以直接把系统装在c盘中, 因为原来的系统有&lt;strong&gt;3个分区, 所以装机时不用格式化 D 盘 和 E 盘&lt;/strong&gt;(&lt;code&gt;我的E盘有7/8个虚拟机文件, 在装好deepin后, 依然可以正常使用&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;装机总结:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;deepin系统装入c盘.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;D盘, E盘可以不用格式化.(当然, 如果电脑里没啥重要文件的, skip it)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;下来就是激动人心的时刻了&#34;&gt;下来就是激动人心的时刻了&lt;/h2&gt;

&lt;p&gt;先放几张图:&lt;/p&gt;

&lt;p&gt;桌面&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/deepin/desktop.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;分屏&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/deepin/splitScreen.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们最爱的vim&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/deepin/vimMarkdownPreview.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当然, 还有很多其它的不错的设计, 这里就不多放图了.&lt;/p&gt;

&lt;h3 id=&#34;配置nvim-spacevim&#34;&gt;配置nvim/spacevim&lt;/h3&gt;

&lt;p&gt;依赖项:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;python支持: 建议先&lt;code&gt;pip install neovim&lt;/code&gt;和&lt;code&gt;pip3 install neovim&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;font支持: (读者可以自行查看readme进行安装) git地址: &lt;code&gt;https://github.com/powerline/fonts.git&lt;/code&gt; , 用来更好的显示vim界面(字体, 状态栏&amp;hellip;).&lt;/li&gt;
&lt;li&gt;tagbar支持: 安装 &lt;code&gt;ctags&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo apt install ctags
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;安装&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;neovim安装: &lt;code&gt;sudo apt install neovim&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Spacevim安装: (读者可以自行查看readme进行安装) git地址: &lt;code&gt;https://github.com/SpaceVim/SpaceVim&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;init.nvim(来, 放出我们的口号: &lt;strong&gt;打造属于自己的编辑器&lt;/strong&gt;, 这个文件是用户配置文件, 读者可以自行配置)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我这里只是对自己的需求进行了简单的配置:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;配置markdown预览:(因为它默认预览采用的插件是&lt;code&gt;iamcoo/MarkdownPreview.vim&lt;/code&gt;, 所以根据该插件作者的说明进行配置)&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;默认预览浏览器为&lt;code&gt;google-chrome&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;let g:mkdp_path_to_chrome = &#39;google-chrome&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;映射预览为&lt;code&gt;F4&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nmap &amp;lt;silent&amp;gt; &amp;lt;F4&amp;gt; &amp;lt;Plug&amp;gt;MarkdownPreview        &amp;quot; for normal mode
imap &amp;lt;silent&amp;gt; &amp;lt;F4&amp;gt; &amp;lt;Plug&amp;gt;MarkdownPreview        &amp;quot; for insert mode
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;设置状态栏分隔符为箭头:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;let g:spacevim_statusline_separator = &#39;arrow&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;配置zsh-oh-my-zsh&#34;&gt;配置zsh/oh-my-zsh&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;安装zsh&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt install zsh
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;安装oh-my-zsh&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sh -c &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体的配置看个人喜好.&lt;/p&gt;

&lt;h3 id=&#34;安装tools&#34;&gt;安装tools&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/PikachuHy/..&#34;&gt;https://github.com/PikachuHy/..&lt;/a&gt;.       &lt;code&gt;一位大佬写的net工具,  大家懂得&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;总之, &lt;code&gt;deepin&lt;/code&gt;还是带给我很大的惊喜的.  &lt;code&gt;deepin终端&lt;/code&gt;, &lt;code&gt;深度截图&lt;/code&gt;, 还可以愉快的使用网络, 开心的在linux下办公hahahahaha.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>thumb指令虚拟化学习(一)</title>
      <link>https://l0phtg.github.io/post/thumb%E6%8C%87%E4%BB%A4%E8%99%9A%E6%8B%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B8%80/</link>
      <pubDate>Tue, 24 Oct 2017 20:23:30 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/thumb%E6%8C%87%E4%BB%A4%E8%99%9A%E6%8B%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B8%80/</guid>
      
        <description>&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/thumb-vmp/thumb16.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上半年接触过一些 &lt;strong&gt;app加固&lt;/strong&gt; 的知识, 对 &lt;strong&gt;vm&lt;/strong&gt; 这块一直空有兴趣而没有了解过;  最近, 阅读了几篇文章, &lt;code&gt;有所启发&lt;/code&gt;, 所以决定学习一下 &lt;strong&gt;vm&lt;/strong&gt; 这块的一些操作.&lt;/p&gt;

&lt;p&gt;主要内容分为:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;环境搭建&lt;/li&gt;
&lt;li&gt;提取指令&lt;/li&gt;
&lt;li&gt;capstone处理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;阅读资料&#34;&gt;阅读资料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/knownsec/KCon/blob/master/2017/%5BKCon%202017%5D0827_3_%E9%99%88%E6%84%89%E9%91%AB_%E7%AC%AC%E4%BA%94%E4%BB%A3%E5%8A%A0%E5%9B%BA%E6%8A%80%E6%9C%AFARM%20VMP%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%BA%94%E7%94%A8.pdf&#34;&gt;Kcon2017 第五代加固技术ARM VMP原理与应用&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/2014asm/p/6534897.html&#34;&gt;ARM平台指令虚拟化探索&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;环境搭建&#34;&gt;环境搭建:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;需要安装python的capstone模块, 可以直接使用pip安装. (另外: &lt;strong&gt;强烈建议下载capstone源码, 以便随时阅读&lt;/strong&gt;.)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
    sudo apt install libcapstone3
    sudo apt install libcapstone-dev
    pip install capstone

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ida/radare2 &lt;code&gt;在本节中, 提取指令的时候会用到&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;arm官方文档(&lt;a href=&#34;https://yurichev.com/mirrors/ARMv8-A_Architecture_Reference_Manual_(Issue_A.a).pdf&#34;&gt;https://yurichev.com/mirrors/ARMv8-A_Architecture_Reference_Manual_(Issue_A.a).pdf&lt;/a&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;本篇文章大致分为如下几个部分&#34;&gt;本篇文章大致分为如下几个部分:&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;手动提取编译好的可执行文件中的 &lt;strong&gt;你想要加密的函数&lt;/strong&gt;, 并转换为 &lt;strong&gt;16进制的格式&lt;/strong&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;初步了解 &lt;strong&gt;capstone&lt;/strong&gt; 中的 &lt;strong&gt;对Arm指令进行处理的操作函数&lt;/strong&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;了解 &lt;strong&gt;thumb指令编码&lt;/strong&gt; , &lt;code&gt;此处研究thumb的原因是: 在提出函数的bytes时, 发现自定义的函数, 都被转换成了thumb指令的格式, 所以笔者先研究thumb;  当然, 要知道, thumb并不是独立于arm存在的, thumb的存在是为了提高效率&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;设计自己的一套 &lt;strong&gt;指令集&lt;/strong&gt; , &lt;code&gt;很简单的一套指令集, 能模拟常见的thumb指令, 例如 push, pop, str, ldr, add, sub, mov, cmp, blx ...&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;写代码, &lt;code&gt;此处参考了capstone源码中的/bindings/python/capstone/* 中的有关代码, 初学py, 代码写的差, 有什么建议还请多多交流)&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;提取指令&#34;&gt;提取指令.&lt;/h3&gt;

&lt;p&gt;我们提取的是下面程序中的 &lt;strong&gt;judge&lt;/strong&gt; 函数.&lt;/p&gt;

&lt;h4 id=&#34;用ida提取&#34;&gt;用ida提取:&lt;/h4&gt;

&lt;p&gt;我们将会在这篇文章中用到的程序:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

char key[16] = {&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;q&#39;, &#39;r&#39;, &#39;c&#39;, &#39;o&#39;, &#39;b&#39;, &#39;g&#39;, &#39;s&#39;, &#39;k&#39;};

int judge(const char *s)
{
    int ret = 1;
    char c[16] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;q&#39;, &#39;s&#39;, &#39;e&#39;, &#39;r&#39;, &#39;b&#39;, &#39;h&#39;, &#39;u&#39;, &#39;n&#39;};
    int i;
    for (i = 0; i &amp;lt; 16; i++)
    {
        switch(i % 4)   
        {
        case 0: 
            if (s[i]  == c[i])
                continue;
            break;  
        case 1:
            if (s[i] + 1 == c[i])
                continue;
            break;
        case 2:
            if (s[i] + 2 == c[i])
                continue;
            break;
        case 3:
            if (s[i] + 3 == c[i])
                continue; 
            break;
        } 
        ret = 0; 
    }
    return ret;
}

int main(int argc, char *argv[])
{
    printf(&amp;quot;hello World\n&amp;quot;);
    char a[16];
    scanf(&amp;quot;%s&amp;quot;, a);

    if (judge(a) == 1)
        printf(&amp;quot;ok&amp;quot;);
    else
        printf(&amp;quot;error&amp;quot;);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用ndk-build编译成armv7a可执行程序后, 放入ida中, 用idc脚本提::&lt;/p&gt;

&lt;p&gt;idc脚本, start为judge函数的起始地址, end为judge函数的结束地址.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;idc.idc&amp;gt;

static main() {
    auto start, end, fd, i, inst;
    fd = fopen(&amp;quot;D:\\idaResult\\armOpcodeByte.txt&amp;quot;, &amp;quot;wt+&amp;quot;);
    start = 0x863c;
    end = 0x86BA;
    
    for(i = start; i &amp;lt; end; i++) {
        inst = Byte(i);
        fprintf(fd, &amp;quot;\\x%02x&amp;quot;, inst);
    }
    fclose(fd);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提取出来后的结果:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;\x1f\x49\xf0\xb5\x79\x44\x09\x68\x87\xb0\x07\x46\x0b\x68\x01\xaa\x0d\x46\x16\x46\x05\x93\x1b\x4b\x7b\x44\x03\xf1\x10\x0e\x18\x68\x08\x33\x53\xf8\x04\x1c\x73\x45\x14\x46\x03\xc4\x22\x46\xf6\xd1\x3a\x46\x00\x23\x01\x20\x03\xf0\x03\x01\x02\x29\x09\xd0\x03\x29\x0a\xd0\x01\x29\x02\xd0\x14\x78\xf1\x5c\x08\xe0\x11\x78\x01\x31\x04\xe0\x11\x78\x02\x31\x01\xe0\x11\x78\x03\x31\xf4\x5c\x01\x33\xa1\x42\x18\xbf\x00\x20\x10\x2b\x02\xf1\x01\x02\xe3\xd1\x05\x9a\x2b\x68\x9a\x42\x01\xd0\xff\xf7\x0a\xef\x07\xb0\xf0\xbd
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;用radare2提取&#34;&gt;用radare2提取&lt;/h4&gt;

&lt;p&gt;(才发现原来radare2 v2.0都已经发布了)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;对r2语法不做讲解了, 网上也有了一些文章, 大家可以去看&lt;/code&gt;.  笔者本身也不是很熟悉~&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;username-l0phtg@L0phTg:armeabi-v7a$ r2 test
 -- Interpret radare2 scripts with &#39;. &amp;lt;path-to-script&amp;gt;&#39;. Similar to the bash source alias command.
[0x000085a0]&amp;gt; aa
[x] Analyze all flags starting with sym. and entry0 (aa)
[0x000085a0]&amp;gt; afl~judge
0x0000863c   17 126          sym.judge
[0x000085a0]&amp;gt; 0x863c
[0x0000863c]&amp;gt; pcp 126
import struct
buf = struct.pack (&amp;quot;126B&amp;quot;, *[
0x1f,0x49,0xf0,0xb5,0x79,0x44,0x09,0x68,0x87,0xb0,0x07,
0x46,0x0b,0x68,0x01,0xaa,0x0d,0x46,0x16,0x46,0x05,0x93,
0x1b,0x4b,0x7b,0x44,0x03,0xf1,0x10,0x0e,0x18,0x68,0x08,
0x33,0x53,0xf8,0x04,0x1c,0x73,0x45,0x14,0x46,0x03,0xc4,
0x22,0x46,0xf6,0xd1,0x3a,0x46,0x00,0x23,0x01,0x20,0x03,
0xf0,0x03,0x01,0x02,0x29,0x09,0xd0,0x03,0x29,0x0a,0xd0,
0x01,0x29,0x02,0xd0,0x14,0x78,0xf1,0x5c,0x08,0xe0,0x11,
0x78,0x01,0x31,0x04,0xe0,0x11,0x78,0x02,0x31,0x01,0xe0,
0x11,0x78,0x03,0x31,0xf4,0x5c,0x01,0x33,0xa1,0x42,0x18,
0xbf,0x00,0x20,0x10,0x2b,0x02,0xf1,0x01,0x02,0xe3,0xd1,
0x05,0x9a,0x2b,0x68,0x9a,0x42,0x01,0xd0,0xff,0xf7,0x0a,
0xef,0x07,0xb0,0xf0,0xbd])
[0x0000863c]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;了解capstone中对arm指令进行操作的函数-接口&#34;&gt;了解capstone中对arm指令进行操作的函数 &lt;code&gt;接口&lt;/code&gt;&lt;/h3&gt;

&lt;h4 id=&#34;从源代码中提供的-example-来初步了解capstone提供给我们的可用的-接口-的使用&#34;&gt;从源代码中提供的&lt;code&gt;example&lt;/code&gt;, 来初步了解capstone提供给我们的可用的&lt;code&gt;接口&lt;/code&gt;的使用&lt;/h4&gt;

&lt;p&gt;我们参考的主要是 &lt;code&gt;/bindings/python/test_arm.py&lt;/code&gt; 和 &lt;code&gt;/bindings/python/test_detail.py&lt;/code&gt;这两个文件:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;test_arm.py   &lt;code&gt;源代码过多, 这里就不全部都放上来了&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python

# Capstone Python bindings, by Nguyen Anh Quynnh &amp;lt;aquynh@gmail.com&amp;gt;

from __future__ import print_function
from capstone import *
from capstone.arm import *
from xprint import to_hex, to_x, to_x_32

ARM_CODE = b&amp;quot;\xED\xFF\xFF\xEB\x04\xe0\x2d\xe5\x00\x00\x00\x00\xe0\x83\x22\xe5\xf1\x02\x03\x0e\x00\x00\xa0\xe3\x02\x30\xc1\xe7\x00\x00\x53\xe3\x00\x02\x01\xf1\x05\x40\xd0\xe8\xf4\x80\x00\x00&amp;quot;
THUMB_CODE = b&amp;quot;\x70\x47\x00\xf0\x10\xe8\xeb\x46\x83\xb0\xc9\x68\x1f\xb1\x30\xbf\xaf\xf3\x20\x84&amp;quot;

all_tests = (
        (CS_ARCH_ARM, CS_MODE_ARM, ARM_CODE, &amp;quot;ARM&amp;quot;, None),
        (CS_ARCH_ARM, CS_MODE_THUMB, THUMB_CODE, &amp;quot;Thumb&amp;quot;, None),
        )

def print_insn_detail(insn):
    # print address, mnemonic and operands
    print(&amp;quot;0x%x:\t%s\t%s&amp;quot; % (insn.address, insn.mnemonic, insn.op_str))

    # &amp;quot;data&amp;quot; instruction generated by SKIPDATA option has no detail
    if insn.id == 0:
        return

    if len(insn.operands) &amp;gt; 0:
        print(&amp;quot;\top_count: %u&amp;quot; % len(insn.operands))
        c = 0
        for i in insn.operands:
            if i.type == ARM_OP_REG:
                print(&amp;quot;\t\toperands[%u].type: REG = %s&amp;quot; % (c, insn.reg_name(i.reg)))
            if i.type == ARM_OP_IMM:
                print(&amp;quot;\t\toperands[%u].type: IMM = 0x%s&amp;quot; % (c, to_x_32(i.imm)))
...............................
            if i.type == ARM_OP_MEM:
                print(&amp;quot;\t\toperands[%u].type: MEM&amp;quot; % c)
                if i.mem.base != 0:
                    print(&amp;quot;\t\t\toperands[%u].mem.base: REG = %s&amp;quot; \
                        % (c, insn.reg_name(i.mem.base)))
                if i.mem.index != 0:
                    print(&amp;quot;\t\t\toperands[%u].mem.index: REG = %s&amp;quot; \
                        % (c, insn.reg_name(i.mem.index)))
                if i.mem.scale != 1:
                    print(&amp;quot;\t\t\toperands[%u].mem.scale: %u&amp;quot; \
                        % (c, i.mem.scale))
                if i.mem.disp != 0:
                    print(&amp;quot;\t\t\toperands[%u].mem.disp: 0x%s&amp;quot; \
                        % (c, to_x_32(i.mem.disp)))
...............................
            c += 1

    if insn.update_flags:
        print(&amp;quot;\tUpdate-flags: True&amp;quot;)
    if insn.writeback:
        print(&amp;quot;\tWrite-back: True&amp;quot;)
    if not insn.cc in [ARM_CC_AL, ARM_CC_INVALID]:
        print(&amp;quot;\tCode condition: %u&amp;quot; % insn.cc)
...............................

### Test class Cs
def test_class():

    for (arch, mode, code, comment, syntax) in all_tests:
        print(&amp;quot;*&amp;quot; * 16)
        print(&amp;quot;Platform: %s&amp;quot; % comment)
        print(&amp;quot;Code: %s&amp;quot; % to_hex(code))
        print(&amp;quot;Disasm:&amp;quot;)

        try:
            md = Cs(arch, mode)
            if syntax:
                md.syntax = syntax
            md.detail = True
            for insn in md.disasm(code, 0x80001000):
                print_insn_detail(insn)
                print ()
            print (&amp;quot;0x%x:\n&amp;quot; % (insn.address + insn.size))
        except CsError as e:
            print(&amp;quot;ERROR: %s&amp;quot; % e)


if __name__ == &#39;__main__&#39;:
    test_class()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;观察&lt;code&gt;test_arm.py&lt;/code&gt;, 我们可以看到的重要的一些操作有:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;md = Cs(arch, mode)
for insn in md.disasm(code, 0x80001000):
    print_insn_detail(insn)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先通过&lt;code&gt;md = Cs(arch, mode)&lt;/code&gt;来选择我们的架构, 然后调用&lt;code&gt;md.disasm&lt;/code&gt;返回 指令(insn) (这里Cs.disasm就是一个生成器, 参看py语法)
然后打印&lt;code&gt;insn&lt;/code&gt;的细节(助记符, 操作数, 以及每个操作数的类型等)&lt;/p&gt;

&lt;p&gt;打印的时候(这里我只列举了部分操作):
- 我们可以发现 &lt;strong&gt;针对指令&lt;/strong&gt; 调用了 &lt;strong&gt;insn.address&lt;/strong&gt;, &lt;strong&gt;insn.mnemonic&lt;/strong&gt;,  &lt;strong&gt;insn.op_str&lt;/strong&gt;, &lt;strong&gt;insn.operands&lt;/strong&gt;, &lt;strong&gt;insn.update_flags&lt;/strong&gt;, &lt;strong&gt;insn.cc&lt;/strong&gt;&amp;hellip;..
- 针对 &lt;strong&gt;操作数&lt;/strong&gt; 调用了 &lt;strong&gt;i.type&lt;/strong&gt;, &lt;strong&gt;i.reg&lt;/strong&gt;, &lt;strong&gt;i.mem&lt;/strong&gt;&amp;hellip;.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;test_detail.py (省略了一些和上面test_arm.py相似的代码)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;..........
def print_detail(insn):
    print(&amp;quot;0x%x:\t%s\t%s  // insn-ID: %u, insn-mnem: %s&amp;quot; \
        % (insn.address, insn.mnemonic, insn.op_str, insn.id, \
        insn.insn_name()))

    # &amp;quot;data&amp;quot; instruction generated by SKIPDATA option has no detail
    if insn.id == 0:
        return

    if len(insn.regs_read) &amp;gt; 0:
        print(&amp;quot;\tImplicit registers read: &amp;quot;, end=&#39;&#39;),
        for m in insn.regs_read:
            print(&amp;quot;%s &amp;quot; % insn.reg_name(m), end=&#39;&#39;),
        print()

    if len(insn.regs_write) &amp;gt; 0:
        print(&amp;quot;\tImplicit registers modified: &amp;quot;, end=&#39;&#39;),
        for m in insn.regs_write:
            print(&amp;quot;%s &amp;quot; % insn.reg_name(m), end=&#39;&#39;),
        print()

    if len(insn.groups) &amp;gt; 0:
        print(&amp;quot;\tThis instruction belongs to groups: &amp;quot;, end=&#39;&#39;),
        for m in insn.groups:
            print(&amp;quot;%s &amp;quot; % insn.group_name(m), end=&#39;&#39;),
        print()``
        ....................................

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;操作很明显:
&lt;strong&gt;insn.regs_read&lt;/strong&gt;, &lt;strong&gt;insn.regs_write&lt;/strong&gt;, &lt;strong&gt;insn.groups&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&#34;观察源代码中的-bindings-python-capstone-init-py-来了解-cs-和-csinsn-的实现&#34;&gt;观察源代码中的&lt;code&gt;/bindings/python/capstone/__init__.py&lt;/code&gt;来了解&lt;strong&gt;CS&lt;/strong&gt; 和 &lt;strong&gt;CsInsn&lt;/strong&gt; 的实现:&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Cs(object):
    def __init__(self, arch, mode):
        ....
        ....省略


    # Disassemble binary &amp;amp; return disassembled instructions in CsInsn objects   反汇编二进制代码&amp;amp;&amp;amp; 返回反汇编的指令in CsInsn对象中
    def disasm(self, code, offset, count=0):
        all_insn = ctypes.POINTER(_cs_insn)()
        &#39;&#39;&#39;if not _python2:
            print(code)
            code = code.encode()
            print(code)&#39;&#39;&#39;
        # Hack, unicorn&#39;s memory accessors give you back bytearrays, but they
        # cause TypeErrors when you hand them into Capstone.
        if isinstance(code, bytearray):
            code = bytes(code)
        res = _cs.cs_disasm(self.csh, code, len(code), offset, count, ctypes.byref(all_insn))*************
        if res &amp;gt; 0:
            try:
                for i in range(res):
                    yield CsInsn(self, all_insn[i])         ## all_info*********************************** 重点操作
            finally:
                _cs.cs_free(all_insn, res)
        else:
            status = _cs.cs_errno(self.csh)
            if status != CS_ERR_OK:
                raise CsError(status)
            return
            yield
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过观察&lt;strong&gt;Cs&lt;/strong&gt;这个类的实现, 我们发现了它是一个生成器, 一直返回&lt;strong&gt;CsInsn&lt;/strong&gt; 这个类的对象, 现在我们来看一下CsInsn 这个类的实现(从名字可以就可以看出来, 它保存了我们每条指令的性质)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;▼ CsInsn : class
   +__init__ : function
   +id : function           @property
   +address : function      @property // 返回 指令的地址
   +size : function         @property // 返回 大小
   +bytes : function        @property // 返回 字节码 []
   +mnemonic : function     @property // 返回 指令名称(助记符)
   +op_str : function       @property // 返回 操作string
   +regs_read : function    @property // 返回 会被*隐式*读的寄存器[]
   +regs_write : function   @property // 返回 会被*隐式*写的寄存器[]
   +groups : function       @property // 指令的group
   -__gen_detail : function
   -__getattr__ : function
   +errno : function
   +reg_name : function   (self, reg_id)  // 返回寄存器的名称
   +insn_name : function                  // 返回指令名称, 不同于mnemonic
   +group_name : function
   +group : function
   +reg_read : function   (self, reg_id)  // 识别该寄存器会被隐式read
   +reg_write : function  (self, reg_id)  // 识别该寄存器是否会被隐式 write
   +op_count : function
   +op_find : function
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我罗列了一下它的所有操作,  我们下面写代码的时候会用到.&lt;/p&gt;

&lt;h4 id=&#34;这里我们先简单写一个-py-来对上面的部分函数进行应用&#34;&gt;这里我们先简单写一个.py, 来对上面的部分函数进行应用&lt;/h4&gt;

&lt;p&gt;我们可以先看一下输出结果:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;l0phtg@l0phtg-PC:~/blogTest$ python test.py 
0x1000: push    {r4, r6, r7, lr}
id:426  groups:[150, 151]   size:2  
bytes:  0xd0 0xb5 
    op_count: 4
        operands[0].type: REG = r4
        operands[1].type: REG = r6
        operands[2].type: REG = r7
        operands[3].type: REG = lr

0x1002: pop {r4, r6, r7, pc}
id:425  groups:[150, 151]   size:2  
bytes:  0xd0 0xbd 
    op_count: 4
        operands[0].type: REG = r4
        operands[1].type: REG = r6
        operands[2].type: REG = r7
        operands[3].type: REG = pc

0x1004: beq #0x100e
id:17   groups:[150, 151, 1]    size:2  
bytes:  0x3 0xd0 
    op_count: 1
        operands[0].type: IMM = 0x100e

0x1006: movs    r0, #0
id:80   groups:[150, 151]   size:2  
bytes:  0x0 0x20 
    op_count: 2
        operands[0].type: REG = r0
        operands[1].type: IMM = 0x0
    Update-flags: True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每条指令的指令名称, 指令操作数, 操作数类型, 该指令是否更新flag都显示了出来.&lt;/p&gt;

&lt;p&gt;下面的代码(参考test_arm.py的实现)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python2
#-*- coding:utf-8 -*-

import sys
from capstone import *
from capstone.arm import *
from xprint import to_hex, to_x, to_x_32

my_thumb_code = b&amp;quot;\xd0\xb5\xd0\xbd\x03\xd0\x00\x20&amp;quot;


def print_insn_detail(insn):
    print(&amp;quot;0x%x:\t%s\t%s&amp;quot; % (insn.address, insn.mnemonic, insn.op_str))
    print(&amp;quot;id:%d\tgroups:%s\tsize:%x\t&amp;quot; % (insn.id, insn.groups, insn.size))
    sys.stdout.write(&#39;bytes:\t&#39;)
    for i in insn.bytes:
        sys.stdout.write(&amp;quot;%s &amp;quot; % hex(i))
    sys.stdout.write(&#39;\n&#39;)

    if len(insn.operands) &amp;gt; 0:
        print(&amp;quot;\top_count: %u&amp;quot; % len(insn.operands))
        c = 0
        for i in insn.operands:
            if i.type == ARM_OP_REG:
                print(&amp;quot;\t\toperands[%u].type: REG = %s&amp;quot; % (c, insn.reg_name(i.reg)))
            if i.type == ARM_OP_IMM:
                print(&amp;quot;\t\toperands[%u].type: IMM = 0x%s&amp;quot; % (c, to_x_32(i.imm)))
            if i.type == ARM_OP_PIMM:
                print(&amp;quot;\t\toperands[%u].type: P-IMM = %u&amp;quot; % (c, i.imm))
            if i.type == ARM_OP_CIMM:
                print(&amp;quot;\t\toperands[%u].type: C-IMM = %u&amp;quot; % (c, i.imm))
            if i.type == ARM_OP_FP:
                print(&amp;quot;\t\toperands[%u].type: FP = %f&amp;quot; % (c, i.fp))
            if i.type == ARM_OP_SYSREG:
                print(&amp;quot;\t\toperands[%u].type: SYSREG = %u&amp;quot; % (c, i.reg))
            if i.type == ARM_OP_SETEND:
                if i.setend == ARM_SETEND_BE:
                    print(&amp;quot;\t\toperands[%u].type: SETEND = be&amp;quot; % c)
                else:
                    print(&amp;quot;\t\toperands[%u].type: SETEND = le&amp;quot; % c)
            if i.type == ARM_OP_MEM:
                print(&amp;quot;\t\toperands[%u].type: MEM&amp;quot; % c)
                if i.mem.base != 0:
                    print(&amp;quot;\t\t\toperands[%u].mem.base: REG = %s&amp;quot; \
                        % (c, insn.reg_name(i.mem.base)))
                if i.mem.index != 0:
                    print(&amp;quot;\t\t\toperands[%u].mem.index: REG = %s&amp;quot; \
                        % (c, insn.reg_name(i.mem.index)))
                if i.mem.scale != 1:
                    print(&amp;quot;\t\t\toperands[%u].mem.scale: %u&amp;quot; \
                        % (c, i.mem.scale))
                if i.mem.disp != 0:
                    print(&amp;quot;\t\t\toperands[%u].mem.disp: 0x%s&amp;quot; \
                        % (c, to_x_32(i.mem.disp)))

            if i.shift.type != ARM_SFT_INVALID and i.shift.value:
                print(&amp;quot;\t\t\tShift: %u = %u&amp;quot; \
                    % (i.shift.type, i.shift.value))
            if i.vector_index != -1:
                print(&amp;quot;\t\t\toperands[%u].vector_index = %u&amp;quot; %(c, i.vector_index))
            if i.subtracted:
                print(&amp;quot;\t\t\toperands[%u].subtracted = True&amp;quot; %c)

            c += 1

    if insn.update_flags:
        print(&amp;quot;\tUpdate-flags: True&amp;quot;)

def test_class():

    md = Cs(CS_ARCH_ARM, CS_MODE_THUMB)
    md.detail=True
    for insn in md.disasm(my_thumb_code, 0x1000):
        print_insn_detail(insn)
        sys.stdout.write(&#39;\n&#39;)

if __name__ == &#39;__main__&#39;:
    test_class()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;了解-thumb-的指令编码&#34;&gt;了解 thumb 的指令编码:&lt;/h3&gt;

&lt;p&gt;在前面环境搭建的时候, 我向大家推荐了arm的一个文档, 本节主要针对该文档进行分析.&lt;/p&gt;

&lt;p&gt;首先定位到第&lt;code&gt;F3&lt;/code&gt;章节, 观看目录:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Chapter F3

T32 Base Instruction Set Encoding

This chapter introduces the T32 instruction set and describes how it uses the ARM programmers’ model. It contains

the following sections:


• T32 instruction set encoding on page F3-2432.

• 16-bit T32 instruction encoding on page F3-2435.

• 32-bit T32 instruction encoding on page F3-2442.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们在此分析的是&lt;strong&gt;16-bit T32 instruction&lt;/strong&gt;, 再次定位到&lt;code&gt;F3-2435&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/thumb-vmp/thumb16.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>elf文件格式和AndroidLinker加载.so的源码分析</title>
      <link>https://l0phtg.github.io/post/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%92%8Candroidlinker%E5%8A%A0%E8%BD%BD-so%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Sun, 19 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://l0phtg.github.io/post/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%92%8Candroidlinker%E5%8A%A0%E8%BD%BD-so%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      
        <description>&lt;p&gt;最近在学习android应用的加壳和混淆方法, 所以遇到了一些有关.so是如何加载到android中去的问题, 看了一些视频和文章, 所以想在此总结一下.&lt;/p&gt;

&lt;p&gt;本文主要内容:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;elf的文件格式&lt;/li&gt;
&lt;li&gt;分析linker的源码, 主要dlopen流程.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;elf文件格式&#34;&gt;elf文件格式&lt;/h2&gt;

&lt;p&gt;本文只对elf文件格式进行简单的分析, 如果要进行深入的了解, 推荐&lt;code&gt;&amp;lt;&amp;lt;程序员的自我修养&amp;gt;&amp;gt;&lt;/code&gt;中第3章.&lt;/p&gt;

&lt;p&gt;/usr/includ/elf.h中定义了elf文件头结构和相关的常数.&lt;/p&gt;

&lt;p&gt;分析elf文件时, 建议使用&lt;code&gt;010 editor&lt;/code&gt;这款十六进制编辑软件, 运行elf模板后可以清晰的将文件格式显示出来, 大致的显示是(坑, 此处应该用图片的)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;                NAME                           Value            Start       Size        Color       Comment
    struct file                                                 0h          109Ch
        struct elf_header                                       0h          34h
        struct program_header_table                             34h         120h
        struct section_header_table                             1B274h      460h
        struct dynamic_symbol_table                             18Ch        F10h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到, 一个elf文件中包含一个header, 3个table, 我们一个一个的来分析一下.
首先分析&lt;code&gt;Elf header&lt;/code&gt;, 它位于每一个elf文件开始的地方:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct                                                            typedef struct
{                                                                         {
    unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */     unsigned char e_ident[EI_NIDENT];
    Elf32_Half    e_type;         /* Object file type */                    Elf64_Half    e_type;     
    Elf32_Half    e_machine;      /* Architecture */                        Elf64_Half    e_machine;  
    Elf32_Word    e_version;      /* Object file version */                 Elf64_Word    e_version;  
    Elf32_Addr    e_entry;        /* Entry point virtual address */         Elf64_Addr    e_entry;    
    Elf32_Off e_phoff;        /* Program header table file offset */        Elf64_Off e_phoff;        
    Elf32_Off e_shoff;        /* Section header table file offset */        Elf64_Off e_shoff;        
    Elf32_Word    e_flags;        /* Processor-specific flags */            Elf64_Word    e_flags;    
    Elf32_Half    e_ehsize;       /* ELF header size in bytes */            Elf64_Half    e_ehsize;   
    Elf32_Half    e_phentsize;        /* Program header table entry size */ Elf64_Half    e_phentsize;
    Elf32_Half    e_phnum;        /* Program header table entry count */    Elf64_Half    e_phnum;    
    Elf32_Half    e_shentsize;        /* Section header table entry size */ Elf64_Half    e_shentsize;
    Elf32_Half    e_shnum;        /* Section header table entry count */    Elf64_Half    e_shnum;    
    Elf32_Half    e_shstrndx;     /* Section header string table index */   Elf64_Half    e_shstrndx; 
} Elf32_Ehdr;                                                              } Elf64_Ehdr;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到, header中包含了magic number, 文件类型, 目标文件版本, 入口地址(如果为0, 说明此文件为可重定位文件), program header的开始地址(即为在so文件中的offset), section header的开始地址, 标志位, elf头本身的大小, program header和section header的size和数量, 最后是section header中string section在section中的下标.(用010 editor可以看到清楚的看到一个.so文件包含众多的program header 和 section header, 这两个段在做.so混淆时会经常分析)&lt;/p&gt;

&lt;p&gt;现在分析&lt;code&gt;program header&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* Program segment header.  */

typedef struct                                                      typedef struct
{                                                                   {
    Elf32_Word    p_type;         /* Segment type */                    Elf64_Word    p_type;   
    Elf32_Off p_offset;       /* Segment file offset */                 Elf64_Off p_offset;     
    Elf32_Addr    p_vaddr;        /* Segment virtual address */         Elf64_Addr    p_vaddr;  
    Elf32_Addr    p_paddr;        /* Segment physical address */        Elf64_Addr    p_paddr;  
    Elf32_Word    p_filesz;       /* Segment size in file */            Elf64_Word    p_filesz; 
    Elf32_Word    p_memsz;        /* Segment size in memory */          Elf64_Word    p_memsz;  
    Elf32_Word    p_flags;        /* Segment flags */                   Elf64_Word    p_flags;  
    Elf32_Word    p_align;        /* Segment alignment */               Elf64_Word    p_align;  
} Elf32_Phdr;                                                       } Elf64_Phdr;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来分析&lt;code&gt;section header&lt;/code&gt;, section相信了解过汇编的同学都非常熟悉了, 这个section header里面就存放了我们elf中各个段的信息.
看一下section header段描述符的结构:(64位的与32位的结构体大致相同, 只是把类型改为了Elf64的类型)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct
{
    Elf32_Word    sh_name;        /* Section name (string tbl index) 段名*/
    Elf32_Word    sh_type;        /* Section type 段类型*/
    Elf32_Word    sh_flags;       /* Section flags 标志位*/
    Elf32_Addr    sh_addr;        /* Section virtual addr at execution 段虚拟地址*/
    Elf32_Off sh_offset;          /* Section file offset 段偏移*/
    Elf32_Word    sh_size;        /* Section size in bytes 段的长度*/
    Elf32_Word    sh_link;        /* Link to another section 段的链接信息*/
    Elf32_Word    sh_info;        /* Additional section information 段链接的相关信息*/
    Elf32_Word    sh_addralign;   /* Section alignment 段地址对齐*/
    Elf32_Word    sh_entsize;     /* Entry size if section holds table 项的长度*/
} Elf32_Shdr;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后分析动态符号表(&lt;code&gt;symbol table&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct
{
    Elf32_Word    st_name;        /* Symbol name (string tbl index) */
    Elf32_Addr    st_value;       /* Symbol value */
    Elf32_Word    st_size;        /* Symbol size */
    unsigned char st_info;        /* Symbol type and binding */
    unsigned char st_other;       /* Symbol visibility */
    Elf32_Section st_shndx;       /* Section index */
} Elf32_Sym;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;包含的信息有符号名, 符号相对应的值, 符号大小, 符号类型和绑定信息, 符号所在的段.&lt;/p&gt;

&lt;h2 id=&#34;android-linker加载-so的源码分析&#34;&gt;Android Linker加载.so的源码分析&lt;/h2&gt;

&lt;p&gt;Android中的本地文件.so是通过Linker加载到内存中去并且执行的.(本文分析的源码为Android4.4.4)
                &amp;mdash;- 推荐一款好用的源码阅读工具 source Insight&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;java层:  System.LoadLibrary(&amp;quot;function&amp;quot;);
native:         ---&amp;gt;  Dalvik/vm/native/java_lang_Runtime.cpp: Dalvik_java_lang_Runtime_nativeLoad 
                        ---&amp;gt;Dalvik/vm/Native.cpp: dvmLoadNativeCode(const char* fileName, Object* ClassLoader, char** reason)
                                ---&amp;gt;bionic/linker/dlfcn.c: dlopen(const char* pathName, RTLD_LAZY)
                                        ---&amp;gt;bionic/linker/linker.cpp: do_dlopen(const char* name, int flags)
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;核心函数为&lt;code&gt;do_dlopen&lt;/code&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;soinfo* do_dlopen(const char* name, int flags) {  // 函数的参数为
    if ((flags &amp;amp; ~(RTLD_NOW|RTLD_LAZY|RTLD_LOCAL|RTLD_GLOBAL)) != 0) {
        DL_ERR(&amp;quot;invalid flags to dlopen: %x&amp;quot;, flags);
        return NULL;
    }
    set_soinfo_pool_protection(PROT_READ | PROT_WRITE); // 设置so信息池的访问权限为可读可写
    soinfo* si = find_library(name);                    // 找到name函数, 装载so, 并返回指向.soinfo的指针
    if (si != NULL) {
                      si-&amp;gt;CallConstructors();           // 初始化so库
    }
    set_soinfo_pool_protection(PROT_READ);              // 设置so信息池的访问权限为只读
    return si;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;查看&lt;code&gt;find_library&lt;/code&gt;函数可以发现它调用了&lt;code&gt;find_library_internal&lt;/code&gt;函数,&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;static soinfo* find_library(const char* name) {
    soinfo* si = find_library_internal(name);
    if (si != NULL) {
        si-&amp;gt;ref_count++;
    }
    return si;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分析&lt;code&gt;find_library_internal&lt;/code&gt;函数, 发现其主要调用了&lt;code&gt;load_library()&lt;/code&gt;函数和 &lt;code&gt;soinfo_link_image()&lt;/code&gt; 函数.
_&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;static soinfo* find_library_internal(const char* name) {
    if (name == NULL) {
        return somain;
    }
    soinfo* si = find_loaded_library(name);         // 判断.so是否完全加载, 如果加载: 返回有效的指针;如果没有加载, 返回null;
    if (si != NULL) {                               // 如果已经加载，返回
        if (si-&amp;gt;flags &amp;amp; FLAG_LINKED) {
            return si;
        }
        DL_ERR(&amp;quot;OOPS: recursive link to \&amp;quot;%s\&amp;quot;&amp;quot;, si-&amp;gt;name);
        return NULL;
    }

    TRACE(&amp;quot;[ &#39;%s&#39; has not been loaded yet.  Locating...]&amp;quot;, name);  // 打印so还没有加载
    si = load_library(name);        // 加载.so
    if (si == NULL) {
        return NULL;
    }
    // At this point we know that whatever is loaded @ base is a valid ELF
    // shared library whose segments are properly mapped in.
    TRACE(&amp;quot;[ init_library base=0x%08x sz=0x%08x name=&#39;%s&#39; ]&amp;quot;,
            si-&amp;gt;base, si-&amp;gt;size, si-&amp;gt;name);

    if (!soinfo_link_image(si)) {       // 完成.so的重定位
        munmap(reinterpret_cast&amp;lt;void*&amp;gt;(si-&amp;gt;base), si-&amp;gt;size);
        soinfo_free(si);
        return NULL;
    }
    return si;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分析&lt;code&gt;load_library&lt;/code&gt;函数, 会找到elf_read.&lt;code&gt;Load()&lt;/code&gt;方法, 这个方法就是load&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;static soinfo* load_library(const char* name) {
// Open the file.
    int fd = open_library(name);                        // 打开文件, 获取fd
    if (fd == -1) {
        DL_ERR(&amp;quot;library \&amp;quot;%s\&amp;quot; not found&amp;quot;, name);
        return NULL;
    }

    // Read the ELF header and load the segments.
    ElfReader elf_reader(name, fd);                     // 初始化elfReader对象
    if (!elf_reader.Load()) {                           // 通过elfReader对象的Load()方法, 将so文件装载到内存
        return NULL;
    }

    const char* bname = strrchr(name, &#39;/&#39;);
    soinfo* si = soinfo_alloc(bname ? bname + 1 : name);    // 分配so_info结构, 并按照装载结果更新相应的成员变量
    if (si == NULL) {
        return NULL;
    }
    si-&amp;gt;base = elf_reader.load_start();
    si-&amp;gt;size = elf_reader.load_size();
    si-&amp;gt;load_bias = elf_reader.load_bias();
    si-&amp;gt;flags = 0;
    si-&amp;gt;entry = 0;
    si-&amp;gt;dynamic = NULL;
    si-&amp;gt;phnum = elf_reader.phdr_count();
    si-&amp;gt;phdr = elf_reader.loaded_phdr();

    return si;
}

这里放一个ElfReader结构:
class ElfReader {
public:
    ElfReader(const char* name, int fd);
    ~ElfReader();

    bool Load();

    size_t phdr_count() { return phdr_num_; }
    Elf32_Addr load_start() { return reinterpret_cast&amp;lt;Elf32_Addr&amp;gt;(load_start_); }
    Elf32_Addr load_size() { return load_size_; }
    Elf32_Addr load_bias() { return load_bias_; }
    const Elf32_Phdr* loaded_phdr() { return loaded_phdr_; }

private:
    bool ReadElfHeader();
    bool VerifyElfHeader();
    bool ReadProgramHeader();
    bool ReserveAddressSpace();
    bool LoadSegments();
    bool FindPhdr();
    bool CheckPhdr(Elf32_Addr); 

    const char* name_;
    int fd_;    

    Elf32_Ehdr header_;
    size_t phdr_num_;   

    void* phdr_mmap_;
    Elf32_Phdr* phdr_table_;
    Elf32_Addr phdr_size_;  

    // First page of reserved address space.
    void* load_start_;
    // Size in bytes of reserved address space.
    Elf32_Addr load_size_;
    // Load bias.
    Elf32_Addr load_bias_;

    // Loaded phdr.
    const Elf32_Phdr* loaded_phdr_;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里是&lt;code&gt;Load()&lt;/code&gt;函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool ElfReader::Load() {
    return ReadElfHeader() &amp;amp;&amp;amp;                   // 读取
        VerifyElfHeader() &amp;amp;&amp;amp;                // 验证
        ReadProgramHeader() &amp;amp;&amp;amp;              // 读取Program header
        ReserveAddressSpace() &amp;amp;&amp;amp;            // 根据Program header计算so需要的内存size并分配相应的空间
        LoadSegments() &amp;amp;&amp;amp;                   // 将so按照segment为单位装载到内存
        FindPhdr();                     // on 装载到内存的so中找到program header, 方便以后链接过程use
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;首先是&lt;code&gt;ReadElfHeader&lt;/code&gt;()函数, 发现其是直接调用&lt;code&gt;read&lt;/code&gt;函数读取到header中的.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool ElfReader::ReadElfHeader() {
    ssize_t rc = TEMP_FAILURE_RETRY(read(fd_, &amp;amp;header_, sizeof(header_)));  // use read() function 直接将elfheader读取到header中
    ```//////////////////////////////
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;然后是&lt;code&gt;VerifyElfread&lt;/code&gt;()函数, 对Elfheader进行验证识别: 是否为32位，大小端，类型和版本.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;之后&lt;code&gt;ReadProgramHeader&lt;/code&gt;()函数(加载program header table从elf文件到一个只读的私有匿名的mmap-ed block中):&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool ElfReader::ReadProgramHeader() {
    phdr_num_ = header_.e_phnum;                                        
    //  将program header on内存中中单独映射一份, use于解析时临时use, on so装载到内存后, 便会释放这块内存, 转而使use装载后的so中的program header

    // Like the kernel, we only accept program header tables that
    // are smaller than 64KiB.
    if (phdr_num_ &amp;lt; 1 || phdr_num_ &amp;gt; 65536/sizeof(Elf32_Phdr)) {
        DL_ERR(&amp;quot;\&amp;quot;%s\&amp;quot; has invalid e_phnum: %d&amp;quot;, name_, phdr_num_);
        return false;
    }

    Elf32_Addr page_min = PAGE_START(header_.e_phoff);
    Elf32_Addr page_max = PAGE_END(header_.e_phoff + (phdr_num_ * sizeof(Elf32_Phdr)));
    Elf32_Addr page_offset = PAGE_OFFSET(header_.e_phoff);  

    phdr_size_ = page_max - page_min;

    void* mmap_result = mmap(NULL, phdr_size_, PROT_READ, MAP_PRIVATE, fd_, page_min);
        if (mmap_result == MAP_FAILED) {
        DL_ERR(&amp;quot;\&amp;quot;%s\&amp;quot; phdr mmap failed: %s&amp;quot;, name_, strerror(errno));
        return false;
    }

    phdr_mmap_ = mmap_result;
    phdr_table_ = reinterpret_cast&amp;lt;Elf32_Phdr*&amp;gt;(reinterpret_cast&amp;lt;char*&amp;gt;(mmap_result) + page_offset);
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ReverveAddressSpace&lt;/code&gt;()函数(准备虚拟内存足够的大来存放Program header中的&lt;code&gt;Load&lt;/code&gt;段(两个Load段～～) 通过&lt;code&gt;mmap with PROT_NONE&lt;/code&gt; 实现&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool ElfReader::ReserveAddressSpace() {
    Elf32_Addr min_vaddr;
    load_size_ = phdr_table_get_load_size(phdr_table_, phdr_num_, &amp;amp;min_vaddr);  // 获取so on 内存中需要的空间load_size
    if (load_size_ == 0) {
          DL_ERR(&amp;quot;\&amp;quot;%s\&amp;quot; has no loadable segments&amp;quot;, name_);
              return false;
    }

    uint8_t* addr = reinterpret_cast&amp;lt;uint8_t*&amp;gt;(min_vaddr);
    void* start = mmap(addr, load_size_, PROT_NONE, mmap_flags, -1, 0);         // use mmap匿名映射, 预留出相应的空间
    int mmap_flags = MAP_PRIVATE | MAP_ANONYMOUS;
    if (start == MAP_FAILED) {
        DL_ERR(&amp;quot;couldn&#39;t reserve %d bytes of address space for \&amp;quot;%s\&amp;quot;&amp;quot;, load_size_, name_);
        return false;
    }

    load_start_ = start;
    load_bias_ = reinterpret_cast&amp;lt;uint8_t*&amp;gt;(start) - addr;              // so可以指定加载的基址, 但是so指定的加载基址可能不是页对齐的, 这种情况
    return true;                                                            // 会导致实际映射地址和指定的加载地址有一个偏差, 这个偏差便是load_bias
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;LoadSegments&lt;/code&gt;()函数(在进程地址空间中加载所有可加载的段(假设你已经预留了空间为这个library)):&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool ElfReader::LoadSegments() {    
    for (size_t i = 0; i &amp;lt; phdr_num_; ++i) {
    const Elf32_Phdr* phdr = &amp;amp;phdr_table_[i];   // 遍历program header table

    if (phdr-&amp;gt;p_type != PT_LOAD) {          // 加载所有p_type == PT_LOAD的段
        continue;
    }

    ``` 之后就是一些设置段地址，段偏移, 之后mmap的一些操作

    return true;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FindPhdr&lt;/code&gt;()(返回program header table加载到内存中的地址, 因为之后还要执行.so的重定位).
现在回到我们&lt;code&gt;find_library_internal&lt;/code&gt;()这里，在执行完load_library()之后, 还有一个重要的函数为 &lt;code&gt;soinfo_link_image&lt;/code&gt;(soinfo* si):&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;这个函数会完成.so的动态链接，其中包含我们加载的.so库的重定位过程:
 1. 定位动态section,将动态section的虚拟地址和项数和读写权限存在dynamic, dynamic_count, dynamic_flags中.
    size_t dynamic_count;
    Elf32_Word dynamic_flags;
    phdr_table_get_dynamic_section(phdr, phnum, base, &amp;amp;si-&amp;gt;dynamic,     // 定位dynamic section
                                       &amp;amp;dynamic_count, &amp;amp;dynamic_flags);     // 

 2. 解析Dynamic section
 3. 调用find_library, 返回所有依赖的.so的soinfo指针并存放在数组中.
 4. 重定位(处理plt_rel(延迟绑定)和rel):
    可以看到, 处理两个重定位表的函数都是soinfo_relocate函数.
    if (si-&amp;gt;plt_rel != NULL) {
        DEBUG(&amp;quot;[ relocating %s plt ]&amp;quot;, si-&amp;gt;name );
        if (soinfo_relocate(si, si-&amp;gt;plt_rel, si-&amp;gt;plt_rel_count, needed)) {
            return false;
        }
    }
    if (si-&amp;gt;rel != NULL) {
        DEBUG(&amp;quot;[ relocating %s ]&amp;quot;, si-&amp;gt;name );
        if (soinfo_relocate(si, si-&amp;gt;rel, si-&amp;gt;rel_count, needed)) {       
            return false;
        }
    }       
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在分析soinfo_relocate函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;







&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>分析Android的JNI编程时所使用的一些函数功能</title>
      <link>https://l0phtg.github.io/post/%E5%88%86%E6%9E%90android%E7%9A%84jni%E7%BC%96%E7%A8%8B%E6%97%B6%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Thu, 16 Mar 2017 03:07:59 +0000</pubDate>
      
      <guid>https://l0phtg.github.io/post/%E5%88%86%E6%9E%90android%E7%9A%84jni%E7%BC%96%E7%A8%8B%E6%97%B6%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD/</guid>
      
        <description>&lt;p&gt;分析&lt;strong&gt;jni调用时&lt;/strong&gt;的一些函数及其函数功能.&lt;/p&gt;

&lt;p&gt;如 GetEnv &amp;hellip;&lt;/p&gt;

&lt;p&gt;本文已长草.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;基本类型&#34;&gt;基本类型&lt;/h2&gt;

&lt;p&gt;&lt;jni.h&gt;文件存放的位置在\Android\sdk\ndk-bundle\platforms\android-24\arch-arm\usr\include\jni.h&lt;/p&gt;

&lt;p&gt;现在来看一下jni.h头文件中内容:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    class _jobject {};                                      typedef _jobject*       jobject;
    class _jclass : public _jobject {};                     typedef _jclass*        jclass;         
    class _jstring : public _jobject {};                    typedef _jstring*       jstring;
    class _jarray : public _jobject {};                     typedef _jarray*        jarray;
    class _jobjectArray : public _jarray {};                typedef _jobjectArray*  jobjectArray;
    class _jbooleanArray : public _jarray {};               typedef _jbooleanArray* jbooleanArray;
    class _jbyteArray : public _jarray {};                  typedef _jbyteArray*    jbyteArray;
    class _jcharArray : public _jarray {};                  typedef _jcharArray*    jcharArray;
    class _jshortArray : public _jarray {};                 typedef _jshortArray*   jshortArray;
    class _jintArray : public _jarray {};                   typedef _jintArray*     jintArray;
    class _jlongArray : public _jarray {};                  typedef _jlongArray*    jlongArray;
    class _jfloatArray : public _jarray {};                 typedef _jfloatArray*   jfloatArray;
    class _jdoubleArray : public _jarray {};                typedef _jdoubleArray*  jdoubleArray;
    class _jthrowable : public _jobject {};                 typedef _jthrowable*    jthrowable;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从右边的typedef可以看出,每一个Jni中的cpp类型都有一个Java中的类型与之相对应.&lt;/p&gt;

&lt;p&gt;这里我们重点分析经常看到的_JNIEnv,_JavaVM,JNIEnv,JavaVM&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct _JNIEnv;
struct _JavaVM;
typedef const struct JNINativeInterface* C_JNIEnv;

#if defined(__cplusplus)
typedef _JNIEnv JNIEnv;
typedef _JavaVM JavaVM;
#else
typedef const struct JNINativeInterface* JNIEnv;
typedef const struct JNIInvokeInterface* JavaVM;
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JNINativeInterface为Native层的接口函数指针表, Jni中的本地函数通过这些接口来调用java层的函数.&lt;/p&gt;

&lt;p&gt;_JNIEnv是一个object, 包含一个指向JNINativeInterface的指针变量function和一些接口函数.&lt;/p&gt;

&lt;p&gt;JNIEnv在cpp中的定义为_JNIEnv, 在c中的定义为 struct JNINativeInterface*.&lt;/p&gt;

&lt;p&gt;JNIEnv: 每一个线程中都有一个属于自己线程的env, 且只在创建自己的线程内有效, 不能跨线程传递.&lt;/p&gt;

&lt;p&gt;下面分析JavaVM:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct _JavaVM {                                                               struct JNIInvokeInterface {                                                 
    const struct JNIInvokeInterface* functions;                                 void*       reserved0;
                                                                                void*       reserved1;
                                                                                void*       reserved2;
    #if defined(__cplusplus)                                                           
    jint DestroyJavaVM()                                                       
    { return functions-&amp;gt;DestroyJavaVM(this); }                                  jint        (*DestroyJavaVM)(JavaVM*);
    jint AttachCurrentThread(JNIEnv** p_env, void* thr_args)                    jint        (*AttachCurrentThread)(JavaVM*, JNIEnv**, void*);
    { return functions-&amp;gt;AttachCurrentThread(this, p_env, thr_args); }           jint        (*DetachCurrentThread)(JavaVM*);
    jint DetachCurrentThread()                                                  jint        (*GetEnv)(JavaVM*, void**, jint);
    { return functions-&amp;gt;DetachCurrentThread(this); }                            jint        (*AttachCurrentThreadAsDaemon)(JavaVM*, JNIEnv**, void*);
    jint GetEnv(void** env, jint version)                                      };
    { return functions-&amp;gt;GetEnv(this, env, version); }
    jint AttachCurrentThreadAsDaemon(JNIEnv** p_env, void* thr_args)
    { return functions-&amp;gt;AttachCurrentThreadAsDaemon(this, p_env, thr_args); }
    #endif /*__cplusplus*/
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaVM在cpp中定义为_JavaVM, 在c中定义为指向JNIInvokeInterface的指针.
JavaVM只有一个, 因为它是java虚拟机在Jni中的表示.&lt;/p&gt;

&lt;p&gt;在用ida加载.apk中.so文件时会发现识别出来的native函数是这样的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    int __fastcall Java_com_njctf_mobile_easycrack_MainActivity_parseText(int a1, int a2, int a3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java层的函数调用是这样的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public native String parseText(String arg1); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而这里的a1就是我们的env, a2就是jobject或者jclass, a3就是String arg1了.
我们在导入&lt;jni.h&gt;头文件和添加了Structures之后, 就可以对ida中的参数类型和参数名字进行修改了.&lt;/p&gt;

&lt;p&gt;修改之后的结果:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int __fastcall Java_com_njctf_mobile_easycrack_MainActivity_parseText(_JNIEnv *env, jobject *obj, jstring inputString);
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>第一篇博文-谈谈CVE-2014-7911</title>
      <link>https://l0phtg.github.io/post/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87-%E8%B0%88%E8%B0%88cve-2014-7911/</link>
      <pubDate>Wed, 01 Mar 2017 20:20:20 +0000</pubDate>
      
      <guid>https://l0phtg.github.io/post/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87-%E8%B0%88%E8%B0%88cve-2014-7911/</guid>
      
        <description>&lt;p&gt;分析一个反序列化漏洞, 以及漏洞的产生的利用过程.&lt;/p&gt;

&lt;p&gt;本文主要内容:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;漏洞成因&lt;/li&gt;
&lt;li&gt;漏洞利用的原理&lt;/li&gt;
&lt;li&gt;基础知识&lt;/li&gt;
&lt;li&gt;漏洞利用流程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;漏洞成因&#34;&gt;漏洞成因:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;`java.io.ObjectInputStream`类没有对接受的数据进行验证, 导致可以传入一个不可序列化的对象.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;利用的原理&#34;&gt;利用的原理:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;android.os.binderproxy对象时不可序列化的, 并且它涉及到一个native代码可以将mObject和mOrgue当作一个指针.
具体来说就是android.os.BinderProxy对象在gc时会调用一个native的`destory`()函数导致任意代码执行.
`native` 调用链`destroy()--&amp;gt; decStrong() --&amp;gt; refs-&amp;gt;mBase-&amp;gt;onLastStrongRef(id)`
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;基础知识&#34;&gt;基础知识&lt;/h2&gt;

&lt;h3 id=&#34;1-java反序列化分析&#34;&gt;1. Java反序列化分析&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;每个java object在序列化时都有一个序列号, 这是这种机制称为序列化的原因.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java.io.ObjectOutputStream可以对对象进行序列化, 它的writeObject()方法可以将序列化后写到一个目标输出流中.
java.io.ObjectInputStream可以对对象进行反序列化, 它的readObject()方法可以从目标输入流中读入序列化的对象并将其反序列化为原对象.
下面以实例来进行分析:
  我们这里定义了一个Employee类(内部有三个实例域和一个构造函数)(其他内部函数已经省略)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package hihihi;
import java.io.*;
import java.util.*;

public class Employee implements Serializable
{
    private String name;
    private double salary;
    private Date hireDay;

    public Employee(String n, double s, int year, int month, int day)
    {
        name = n;
        salary = s;
        GregorianCalendar calendar = new GregorianCalendar(year, month - 1, day);
        hireDay = calendar.getTime();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里是我们的测试程序,运行后会在该程序文件目录下产生一个TestEmployee.db的文件, 这个文件内部的数据即使我们序列化Employee类后产生的序列化数据:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import hihihi.*;
import java.io.*;
import java.util.Date;

public class Test {
    public static void main(String[] args) throws Exception {
        BinderProxy bT = new BinderProxy();
        Employee bE = new Employee(&amp;quot;hi&amp;quot;, 150, 2017, 3, 9);
        Date bD = new Date();
        // FileOutputStream fos= new FileOutputStream(&amp;quot;TestStream.db&amp;quot;);
        // ObjectOutputStream os = new ObjectOutputStream(fos); 
        // os.writeObject(bT);
        // os.close();

        FileOutputStream fosr = new FileOutputStream(&amp;quot;TestEmployee.db&amp;quot;);
        ObjectOutputStream osr = new ObjectOutputStream(fosr);
        osr.writeObject(bE);
        osr.close();    

        ObjectInputStream fisr = new ObjectInputStream(new FileInputStream(&amp;quot;TestEmployee.db&amp;quot;));
        Object newEmployee = fisr.readObject();
        fisr.close();
        System.out.println(newEmployee);    
        // FileOutputStream fosd = new FileOutputStream(&amp;quot;TestData.db&amp;quot;);
        // ObjectOutputStream osd = new ObjectOutputStream(fosd);
        // osd.writeObject(bD);
        // osd.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单说一下序列化后的数据:(参看&lt;code&gt;&amp;lt;&amp;lt;java核心技术(卷2)&amp;gt;&amp;gt;&lt;/code&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;每个文件的Magic Number 为:  &#39;AC ED&#39;
后面紧跟对象序列化的版本号: Ex: &#39;00 05&#39;
字符串对象被保存为: 74  2字节表示的字符串长度 字符
当存储一个对象时:   72  2字节的类名长度    类名   8字节长的指纹(serial ID)   1字节长的标志  2字节长的数据域描述符的数量 数据域描述符  结束标志78 超类类型(没有的话, 为70)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-java和android的gc机制&#34;&gt;2. Java和Android的GC机制&lt;/h3&gt;

&lt;p&gt;Java对象的生命周期和垃圾回收:(从网上摘录.侵删)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;创建对象的方式:

&lt;ul&gt;
&lt;li&gt;使用new语句创建对象;&lt;/li&gt;
&lt;li&gt;使用反射, 调用java.lang.Class或java.lang.reflect.Constructor的newInstance()实例方法;&lt;/li&gt;
&lt;li&gt;调用对象的clone()方法;&lt;/li&gt;
&lt;li&gt;使用反序列化手段, 调用java.io.ObjectInputStream对象的readObject()方法.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;垃圾回收:
对象的可触及性:

&lt;ul&gt;
&lt;li&gt;可触及状态: 当一个对象被创建后, 只要还有引用变量引用该对象, 那么它就始终处于可触及状态;&lt;/li&gt;
&lt;li&gt;可复活状态: 当程序不再有任何变量引用对象时, 它就进入可复活状态, 该状态的对象, 垃圾回收器会准备释放它的内存, 在释放前, 会调用它的finalize()方法, 这些finlize方法可能使对象重新转到可触及状态;&lt;/li&gt;
&lt;li&gt;不可触及状态: 当JVM执行完所有的可复活状态的finalize()方法之后, 假设这些方法都没有使对象转到可触及状态. 那么该对象就进入了不可触及状态. 只有对象处于不可触及状态时, 垃圾回收器才会真正回收它占用的内存.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;3-android的binder机制简介-网上有很多分析binder机制的文章-这里就直接给出一个简单的定义&#34;&gt;3. Android的Binder机制简介(网上有很多分析Binder机制的文章, 这里就直接给出一个简单的定义);&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;binder是Android提供的一种IPC通信机制，方便进程之间交换数据。binder的实现包括一个公共的顶层服务接口，同时实现了这个公共顶层接口的proxy代理端和service端。binder driver充当通信媒介。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-c-对象内存布局&#34;&gt;4. C++ 对象内存布局:&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;C++中, 对象的内存布局为先放父类, 然后放自己的成员, 如果有虚函数, 内存中会有一个放虚函数表的位置在最开始处.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-堆喷射&#34;&gt;5. 堆喷射:&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;原因(为什么要用到堆喷射技术): 控制的rip指针指向的地址是在一个范围内随机变化的, 而我们可以对rip指向的区域进行写操作.
方式: 通过构造特殊的内存布局, 使无论rip指向哪里, 它都会`最终`跳转到一个固定的地址处
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;6-rop&#34;&gt;6. ROP&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;在可以控制rip指针后, 我们可以在程序加载的.so中找到一些特定的gadget, 利用内存复写技术, 来控制最终执行system函数(也就是拿到了system权限)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;漏洞利用流程&#34;&gt;漏洞利用流程&lt;/h2&gt;

&lt;h3 id=&#34;1-触发gc机制&#34;&gt;1. 触发GC机制&lt;/h3&gt;

&lt;p&gt;BinderProxy的finalize方法调用了native的方法, 会将我们的mOruge处理为指针.&lt;/p&gt;

&lt;h3 id=&#34;2-分析native方法&#34;&gt;2. 分析native方法:&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;        ------------为了我们能够正确的控制指针指针我们期望的地址，而不会让system_server crash掉
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;destory在native层的调用逻辑:
    /Core/jni/android_util_Binder.cpp   static void android_os_BinderProxy_destroy(JNIEnv* env, jobject obj)
        -----&amp;gt; /libs/utils/RefBase.cpp    void RefBase::decStrong(const void* id) const
            -----&amp;gt; int32_t android_atomic_dec(volatile int32_t* addr)          /system/core/libcutils/atomic.c
            -----&amp;gt; /libs/utils/RefBase.cpp   void RefBase::onLastStrongRef(const void* /*id*/)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结合下面的代码分析:&lt;/p&gt;

&lt;p&gt;传入的object对象即是我们恶意构造的对象, 通过GetIntField()可以获得该对象中的实例域mObject和mOrgue&lt;/p&gt;

&lt;p&gt;注意到它将实例域赋值到drl后, 掉了drl-&amp;gt;decStrong() 函数&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;drl可控, 即传入的this可控, drl为指向DeathRecipientList的指针&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  在decStrong函数中
    * 首先 refs = mRefs,                        即让refs = *(mOruge + 4)
    * 调用refs-&amp;gt;removeStrongRef(id)             空实现
    * c = android_atomic_dec(&amp;amp;refs-&amp;gt;mStrong)    c = *(mOruge + 4) == 1
    * if (c == 1): then ....    BLX r2          r2 = * (*(*(*(mOrgue + 4) + 8)) + 12)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就完成了对rip的控制, 通过在system_server内存空间的dalvik-heap中进行堆喷射和合理的布置gadget, 就可以完成到system权限的提升.&lt;/p&gt;

&lt;p&gt;(具体代码可参照retme的&lt;a href=&#34;https://github.com/retme7/CVE-2014-7911_poc&#34;&gt;https://github.com/retme7/CVE-2014-7911_poc&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;DecStrong的汇编代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;PUSH            {R4-R6,LR}
MOV             R5, R0
LDR             R4, [R0,#4]             r4   = *(r0 + 4)
MOV             R6, R1
MOV             R0, R4
BLX             android_atomic_dec
CMP             R0, #1
BNE             loc_D184
LDR             R0, [R4,#8]             r0   = *(r4 + 8)
MOV             R1, R6
LDR             R3, [R0]                r3   = *(r0)
LDR             R2, [R3,#0xC]           r2   = *(r3 + 0xc)
BLX             R2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;native执行代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;static void android_os_BinderProxy_destroy(JNIEnv* env, jobject obj)
{
    IBinder* b = (IBinder*)
    env-&amp;gt;GetIntField(obj, gBinderProxyOffsets.mObject);
    DeathRecipientList* drl = (DeathRecipientList*)
    env-&amp;gt;GetIntField(obj, gBinderProxyOffsets.mOrgue);

    LOGDEATH(&amp;quot;Destroying BinderProxy %p: binder=%p drl=%p\n&amp;quot;, obj, b, drl);
    env-&amp;gt;SetIntField(obj, gBinderProxyOffsets.mObject, 0);
    env-&amp;gt;SetIntField(obj, gBinderProxyOffsets.mOrgue, 0);
    drl-&amp;gt;decStrong((void*)javaObjectForIBinder);
    b-&amp;gt;decStrong((void*)javaObjectForIBinder);

    IPCThreadState::self()-&amp;gt;flushCommands();
}

void RefBase::decStrong(const void* id) const
{
    weakref_impl* const refs = mRefs;
    refs-&amp;gt;removeStrongRef(id);
    const int32_t c = android_atomic_dec(&amp;amp;refs-&amp;gt;mStrong);
    ...
    if (c == 1) {
        refs-&amp;gt;mBase-&amp;gt;onLastStrongRef(id);
        if ((refs-&amp;gt;mFlags&amp;amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) {
            delete this;
        }
    }
    refs-&amp;gt;decWeak(id);
}

void RefBase::onLastWeakRef(const void* /*id*/)
{
}
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
  </channel>
</rss>