<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>L0phTg&#39;s Blog</title>
    <link>https://l0phtg.github.io/</link>
    <description>Recent content on L0phTg&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>l0phtg</copyright>
    <lastBuildDate>Mon, 20 Aug 2018 21:38:52 +0800</lastBuildDate>
    
        <atom:link href="https://l0phtg.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://l0phtg.github.io/about/</link>
      <pubDate>Mon, 20 Aug 2018 21:38:52 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/about/</guid>
      
        <description>&lt;p&gt;某邮电大学大四学生.&lt;/p&gt;

&lt;p&gt;like: c/c++, 操作系统, 编译原理.&lt;/p&gt;

&lt;p&gt;从事方向: 移动安全.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Kaleidoscope：Conclusion and Other Useful LLVM Tidbits</title>
      <link>https://l0phtg.github.io/post/llvm/kaleidoscopeconclusion-and-other-useful-llvm-tidbits/</link>
      <pubDate>Wed, 26 Jun 2019 16:04:38 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/llvm/kaleidoscopeconclusion-and-other-useful-llvm-tidbits/</guid>
      
        <description>&lt;p&gt;translate from: &lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl10.html&#34;&gt;http://llvm.org/docs/tutorial/LangImpl10.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文是LLVM教程（Kaleidoscope）的最后一章：介绍教程结论和一些有用的LLVM技巧。&lt;/p&gt;

&lt;p&gt;另：按照原本的计划，&amp;lt;&amp;lt;LLVM系列 * 上半年&amp;gt;&amp;gt;应该还有一篇Kaleidoscope教程的总结、和&amp;lt;&amp;lt;Pass基础知识介绍&amp;gt;&amp;gt;一篇文章，和三篇编写Pass的文章。但是预计近三个月刚入职，事情会比较多，所以这个系列文章的更新时间会推迟&amp;ndash;鸽（好饭不怕晚，哈哈哈&amp;mdash;自卖自夸）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Warnning&lt;/strong&gt;: 上午尽量少玩手机，伤眼。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;10-1-教程结论&#34;&gt;10.1 教程结论&lt;/h1&gt;

&lt;p&gt;欢迎来到“&lt;a href=&#34;http://llvm.org/docs/tutorial/index.html&#34;&gt;使用LLVM来实现一门语言&lt;/a&gt;”的最后一章。在本教程中，我们已经将我们的Kaleidoscope语言从一个无用的玩具改造成了一个有趣的玩具（虽然仍然可能是无用的，hhh）。&lt;/p&gt;

&lt;p&gt;我们现在回头看我们走了多远以及实现它的代码有多少，这件事是非常有趣的。我们构建了完整的词法分析器，抽象语法树，代码产生器，和一个交互式的运行终端（通过JIT实现），并且还可以在可执行文件中生成调试信息 &amp;mdash;- 对于小于1000行的代码。&lt;/p&gt;

&lt;p&gt;我们的语言支持很多有趣的特性：它支持用户自定义二元和一元运算符，它可以JIT执行，并且它还支持很多包含SSA结构的控制流。&lt;/p&gt;

&lt;p&gt;本教程的一部分想法是向你展示定义，构建和使用语言是多么容易和有趣。构建一个编译器不是一个可怕的或者神秘的过程！既然你已经看过了一些基础知识，我强烈建议你&lt;strong&gt;take the code and hack on it&lt;/strong&gt;. 例如，试图添加下面这些功能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;全局变量&lt;/strong&gt; - 虽然全局变量在现代软件工程中有一些问题，但是他们在组合像Kaleidscope编译器本身这样的小工具时很有用。幸运地是，我们当前的代码使得添加全局变量变得非常容易：只需要进行值检查，看看是否未解析的变量在全局变量符号表中。为了创建一个新的全局变量，创建LLVM &lt;code&gt;GlobalVariables&lt;/code&gt; 类的实例。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类型变量&lt;/strong&gt; - Kaleidoscope目前只支持浮点类型的变量。这使语言非常简单优雅，因为只支持一个类型意味着你从来不需要指定类型。不同的语言有不同的方式来处理有类型的变量。最简单的方式是要求用户在每一个变量定义时指定类型，并且在符号表中记录它的类型（和值放在一起）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数组，结构，向量，etc&lt;/strong&gt; - 一旦你添加了类型，你可以以各种有趣的方式来扩展类型系统。对于许多不同的应用来说，拥有简单的数组是非常有用的。添加它是一个对学习LLVM &lt;a href=&#34;http://llvm.org/docs/LangRef.html#getelementptr-instruction&#34;&gt;getelementptr&lt;/a&gt; 指令如何工作的一个练习：它是非常漂亮/非常规的。&lt;a href=&#34;http://llvm.org/docs/GetElementPtr.html&#34;&gt;http://llvm.org/docs/GetElementPtr.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;标准运行时&lt;/strong&gt; - 我们当前的语言允许用户来获取任意的外部函数，我们可以像使用“printd”和“putchard”一样来使用它。当你扩展语言来添加高级别的构造时，通常，如果将这些构造降低到语言提供的运行时，这些构造最有意义。例如，如果你在语言中添加哈希表，将例程添加到运行时将可能是有意义的，而不是一直将它们内联。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存管理&lt;/strong&gt; - 目前我们只能访问Kaleidoscope中的堆栈。能够通过调用标准库的 &lt;code&gt;malloc/free&lt;/code&gt; 接口或垃圾收集器来分配堆内存也是很有用的。如果你想使用垃圾收集，请注意LLVM完全支持&lt;a href=&#34;http://llvm.org/docs/GarbageCollection.html&#34;&gt;精确垃圾收集&lt;/a&gt;，包括移动对象并需要扫描/更新堆栈的算法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异常处理支持&lt;/strong&gt; - LLVM支持&lt;a href=&#34;http://llvm.org/docs/ExceptionHandling.html&#34;&gt;zero cost exceptions&lt;/a&gt;，它是与使用其他语言编译的代码相互交互。你可以通过隐式地使每个函数返回一个错误值并检查它来产生代码。你也能够使用 &lt;code&gt;setjmp/longjmp&lt;/code&gt;。当然有许多不同的方式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;面向对象，泛型，数据库访问，复数，几何编程&lt;/strong&gt;，&amp;hellip; - 真的，你可以添加到语言中的功能没有尽头。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;unusual domains&lt;/strong&gt; - 我们一直在讨论将LLVM应用到很多人都感兴趣的领域：对特定的语言构建一个编译器。然而，有许多其他的领域可以使用编译器技术，但是通常确不被考虑。例如，LLVM已经被用于实现OpenGL图形加速，将 c++ 代码翻译为 ActionScript，和许多其他可爱的和有趣的项目。或许你将会是第一个使用LLVM正则表达式解释器编译成本机代码JIT的程序员？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;玩得开心 - 试图使用LLVM做一些疯狂和不同寻常的事情。像其他人一样构建一门语言，没有什么比尝试一些有点疯狂的东西或看到它的结果更有趣。如果你遇到困难或者想要交流，可以给&lt;a href=&#34;http://lists.llvm.org/mailman/listinfo/llvm-dev&#34;&gt;llvm-dev mailing list&lt;/a&gt;发邮件：有很多人对语言感兴趣并且经常愿意提供帮助。&lt;/p&gt;

&lt;p&gt;在我们结束本教程之前，我想要谈谈生成LLVM IR的一些“技巧和窍门”。这些是一些可能不太明显的更微妙的事情，但对你利用LLVM的功能做事情非常有用。&lt;/p&gt;

&lt;h1 id=&#34;10-2-llvm-ir的属性&#34;&gt;10.2 LLVM IR的属性&lt;/h1&gt;

&lt;p&gt;我们很多关于LLVM IR中常见的问题 - 让我们现在就把它们弄清除，shall we?&lt;/p&gt;

&lt;h2 id=&#34;10-2-1-target-independence-目标独立性&#34;&gt;10.2.1 Target Independence/目标独立性&lt;/h2&gt;

&lt;p&gt;Kaleidoscope是“便捷式语言”的一个例子：所有被使用Kaleidoscope的程序都会以相同的方式运行在它运行的任何目标上。许多其他语言也有这个属性，E.g. lisp，java，haskell，javascript，python，etc（注意这些语言是可移植的，但他们的库不一定可移植）。&lt;/p&gt;

&lt;p&gt;LLVM的一个不错的方面是它通常能够&lt;strong&gt;保持IR的目标独立性&lt;/strong&gt;：你能够将LLVM IR用于Kaleidoscope编译的程序，并在LLVM支持的任何目标上运行它，甚至是生成 C 代码并且在LLVM本身不支持的目标上编译它。你可以简单地告诉Kaleidoscope编译器生成与目标无关的代码，因为它在生成代码时从不查询任何特定于目标的信息。&lt;/p&gt;

&lt;p&gt;LLVM提供了一个紧凑的、目标独立的代码表示，这让很多人兴奋不已。不幸地是，当这些人在询问有关语言可移植性的问题时，通常会考虑C语言或者C家族的语言。我说“不幸”，是因为几乎没有办法让C代码可移植，除了发送源代码(hhh，当然了，C源代码实际上也是不可移植的 - 例如将一个相当古老的32位应用移植到64位系统上？)&lt;/p&gt;

&lt;p&gt;C的问题（再次，完全普遍性）是它充满了目标特定的假设。作为一个简单的例子，预处理器在处理输入文本时，经常破坏性地从代码中移除目标独立性：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#ifdef __i386__
  int X = 1;
#else
  int X = 42;
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然可以为这样的问题设计越来越复杂的解决方案，但是它不能以一种比拷贝实际源代码更好的方式完全解决。&lt;/p&gt;

&lt;p&gt;也就是说，有一些C的子集是可移植的。如果你愿意将原始类型修复为固定的大小（例如 int = 32-bits，long = 64-bits），不要关心ABI与现有二进制文件的兼容性，并愿意放弃其他一些小功能，你可以拥有可移植的代码。这对于诸如内核语言之类的专用域是有意义的。&lt;/p&gt;

&lt;h2 id=&#34;10-2-2-安全保障&#34;&gt;10.2.2 安全保障&lt;/h2&gt;

&lt;p&gt;上面许多语言也是“安全”的语言：对于一个使用Java编译的程序来说，想要破坏其地址空间并且使进程崩溃是不可能的（假设JVM没有bugs）。安全性是一个有趣的属性，它需要结合语言设计，运行时支持，和操作系统支持。在LLVM中，实现一个安全的语言当然是可能的，但是LLVM IR本身并不能保证安全。LLVM IR允许不安全的指针类型转换，UAF bugs，缓冲区溢出，和大量其他的问题。安全性需要被作为LLVM的顶级层的一个实现，几个小组已经对这进行了调查。如果你想要了解更多的细节，可以在 &lt;a href=&#34;Http://lists.llvm.org/mailman/listinfo/llvm-dev&#34;&gt;llvm-dev 邮件列表&lt;/a&gt; 中询问。&lt;/p&gt;

&lt;h2 id=&#34;10-2-3-针对特定语言的优化&#34;&gt;10.2.3 针对特定语言的优化&lt;/h2&gt;

&lt;p&gt;导致很多人离开LLVM的很重要的事情是：它并没有解决我们的系统上相关的所有的问题。一个具体的示例就是人们认为LLVM无法执行特定的高级语言的优化：“LLVM失去了太多的信息”。以下是对此的一些观察：&lt;/p&gt;

&lt;p&gt;第一，LLVM的确会丢失信息。例如，截至到目前写这篇文章为止，在LLVM中无法区分SSA值是来自32位机器中的C&amp;rdquo;int&amp;rdquo;还是C&amp;rdquo;long&amp;rdquo;（调试信息除外）。两者都被编译为&amp;rdquo;i32&amp;rdquo;值，并且有关它的来源的信息已经丢失了。更普遍的问题是，LLVM类型系统使用“结构等价”而不是“名称等价”。令人惊讶的另一个地方是：如果你在高级语言中有两种类型，并且它们有相同的结构（例如：两个不同的结构体都只包含int域）：这些类型将编译为单个LLVM类型，并且无法分辨它的来源。&lt;/p&gt;

&lt;p&gt;第二，虽然LLVM确实丢失了信息，但LLVM并不是不变的：我们会用多种不同的方式继续增强和改进它。除了添加新特性外（LLVM不总是支持异常和调试信息），我们也可以扩展IR来捕获重要的信息和优化（例如，无论参数是符号扩展还是零扩展，关于指针别名的信息，等）。许多添加的功能都是用户驱动的：人们希望LLVM包含一些特定的功能，他们会一起添加并扩展它。&lt;/p&gt;

&lt;p&gt;第三，添加特定语言的优化是*可能*的，也是*容易*的，并且你有大量的选择如何做。一个简单的例子，添加特定语言的优化是很容易的，这些优化只是对特定编译的代码适用。针对C系语言，有一个优化pass，该pass对标准C库函数很了解。如果你在main()函数中调用&amp;rdquo;exit(0)&amp;ldquo;，它知道将其优化为&amp;rdquo;return 0&amp;rdquo;是安全的。因为C指定了exit(0)函数会做什么。&lt;/p&gt;

&lt;p&gt;除了简单的知识外，可以将各种特定其他语言的信息嵌入到LLVM IR中。如果你有一个特定的需要，但是遇到问题了，请将主题放在 llvm-dev 列表。最糟糕的情况下，你能总是将LLVM视为 &amp;ldquo;dumb code generator&amp;rdquo;，并且在你的前端的AST上实现针对特定高级语言的优化。&lt;/p&gt;

&lt;h1 id=&#34;10-3-技巧和窍门&#34;&gt;10.3 技巧和窍门&lt;/h1&gt;

&lt;p&gt;在使用LLVM之后，你可以了解到各种各样有用的提示和技巧，这些提示和技巧表面上并不明显。本节并不是让每个人重新发现它们，而是讨论其中的一些问题。&lt;/p&gt;

&lt;h2 id=&#34;10-3-1-实现轻便的-offsetof-sizeof&#34;&gt;10.3.1 实现轻便的 offsetof/sizeof&lt;/h2&gt;

&lt;p&gt;一个有趣的事情，如果你试图保持编译器生成“目标独立”的代码，那么有一件有趣的事情是，你经常需要知道某些LLVM类型的大小或LLVM结构中某些字段的偏移量。例如，你可能需要向一个函数传递一个类型的大小，来分配内存。&lt;/p&gt;

&lt;p&gt;不幸地是，这可能会因目标而异，例如：指针的宽度通常是特定于目标的。然而，有一个&lt;a href=&#34;http://nondot.org/sabre/LLVMNotes/SizeOf-OffsetOf-VariableSizedStructs.txt&#34;&gt;聪明的方法来使用getelementptr函数&lt;/a&gt;，这允许你以一种简单的方式来解决该问题。&lt;/p&gt;

&lt;h2 id=&#34;10-3-2-垃圾收集栈&#34;&gt;10.3.2 垃圾收集栈&lt;/h2&gt;

&lt;p&gt;有些语言希望明确管理其堆栈帧，经常使它们被垃圾收集或允许容易地实现闭包。与显示堆栈帧相比，通常有更好的方法来实现这些功能，&lt;a href=&#34;http://nondot.org/sabre/LLVMNotes/ExplicitlyManagedStackFrames.txt&#34;&gt;llvm支持它们&lt;/a&gt;，如果你想要的话。它需要你的前端将代码转换为对 &lt;a href=&#34;http://en.wikipedia.org/wiki/Continuation-passing_style&#34;&gt;Continuation Passing Style&lt;/a&gt;和(LLVM支持的)尾调用的使用。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Kaleidoscope：Adding Debug Information</title>
      <link>https://l0phtg.github.io/post/llvm/kaleidoscopeadding-debug-information/</link>
      <pubDate>Mon, 24 Jun 2019 19:56:26 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/llvm/kaleidoscopeadding-debug-information/</guid>
      
        <description>&lt;p&gt;translate from: &lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl09.html&#34;&gt;http://llvm.org/docs/tutorial/LangImpl09.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;唔，最后两个章节有点难产。&lt;/p&gt;

&lt;p&gt;本章主要介绍：为Kaleidoscope添加调试信息支持。
&lt;/p&gt;

&lt;h1 id=&#34;9-1-第九章介绍&#34;&gt;9.1 第九章介绍&lt;/h1&gt;

&lt;p&gt;欢迎来到“使用LLVM来实现一门语言”教程的第九章。在第一章到第八章的内容中，我们已经用函数和变量构建了一个不错的编程语言。&lt;strong&gt;但是如果在程序出现问题的情况下，会发生什么呢？我们该如何调试我们的程序呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;源码级的调试会使用格式化的数据，这些数据会帮助调试器将二进制的文件和机器的状态翻译回程序员编写的代码。在LLVM中，我们使用被叫做&lt;a href=&#34;http://dwarfstd.org/&#34;&gt;DWARF&lt;/a&gt;。DWARF是一种紧凑的编码，它可以表示出变量类型、源代码位置和变量的位置。&lt;/p&gt;

&lt;p&gt;本章的主要内容：为了获取到调试信息，并且将调试信息转换为DWARF格式，我们将看到各种各样你必须添加到编程语言中的内容。&lt;/p&gt;

&lt;p&gt;警告：因为现在我们无法通过JIT来对程序进行调试，所以我们需要将我们的程序编译为小的并且独立的程序。作为其中的一部分，我们将对语言的运行以及程序的编译方式做一些修改。这意味着我们将拥有一个用Kaleidoscope编写的简单程序而不是交互式的JIT程序。但是它有一个限制，即我们一次只有一个“顶级”命令来减少必要的改变次数。&lt;/p&gt;

&lt;p&gt;下面是我们将要编译的程序：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def fib(x)
  if x &amp;lt; 3 then
    1
  else
    fib(x-1)+fib(x-2);

fib(10)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;9-2-为什么这是个困难的问题&#34;&gt;9.2 为什么这是个困难的问题&lt;/h1&gt;

&lt;p&gt;生成调试信息是一个困难的问题，主要有几个不同的原因 &amp;mdash;- 这些原因大多数主要围绕优化代码。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一，编译器优化&lt;strong&gt;使想要保持源代码的位置不变更困难&lt;/strong&gt;。在LLVM IR中，我们记录每个IR指令的源代码位置。优化 passes 应该记录新创建指令的对应的源代码位置。但是针对合并的指令，我们只能记录一个源代码位置 &amp;mdash;- 当跳过优化程序时，这会引发一个程序跳转。&lt;/li&gt;
&lt;li&gt;第二，优化模块会使用很多种方式来移动变量（改变变量的位置），例如与其它变量共享内存。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了达到本教程的目的，我们会避免优化（下面我们会采用一些方式来避免优化）。&lt;/p&gt;

&lt;h1 id=&#34;9-3-提前编译模式&#34;&gt;9.3 提前编译模式&lt;/h1&gt;

&lt;p&gt;为了突出对源语言增加调试信息的各个方面，而不必担心JIT的复杂性，我们将对Kaleidoscope做一些改变来支持&lt;strong&gt;将前端产生的IR编译为一个简单的独立程序&lt;/strong&gt;，你可以执行、调试和查看结果。&lt;/p&gt;

&lt;p&gt;编译IR emitted by 前端 into 一个简单独立的程序that 你可以执行，调试 and see results。&lt;/p&gt;

&lt;p&gt;首先，我们将包含顶级语句的匿名函数作为我们的&amp;rdquo;main&amp;rdquo;函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;-    auto Proto = llvm::make_unique&amp;lt;PrototypeAST&amp;gt;(&amp;quot;&amp;quot;, std::vector&amp;lt;std::string&amp;gt;());
+    auto Proto = llvm::make_unique&amp;lt;PrototypeAST&amp;gt;(&amp;quot;main&amp;quot;, std::vector&amp;lt;std::string&amp;gt;());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只需要简单地改变它的名字就可以了。&lt;/p&gt;

&lt;p&gt;然后我们要删除所有的与命令行相关的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;@@ -1129,7 +1129,6 @@ static void HandleTopLevelExpression() {
 /// top ::= definition | external | expression | &#39;;&#39;
 static void MainLoop() {
   while (1) {
-    fprintf(stderr, &amp;quot;ready&amp;gt; &amp;quot;);
     switch (CurTok) {
     case tok_eof:
       return;
@@ -1184,7 +1183,6 @@ int main() {
   BinopPrecedence[&#39;*&#39;] = 40; // highest.

   // Prime the first token.
-  fprintf(stderr, &amp;quot;ready&amp;gt; &amp;quot;);
   getNextToken();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后我们将会&lt;strong&gt;禁用所有的优化passes和JIT&lt;/strong&gt;，以便在我们完成解析和生成代码之后唯一会发生的事情是LLVM IR将会转到标准错误：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;@@ -1108,17 +1108,8 @@ static void HandleExtern() {
 static void HandleTopLevelExpression() {
   // Evaluate a top-level expression into an anonymous function.
   if (auto FnAST = ParseTopLevelExpr()) {
-    if (auto *FnIR = FnAST-&amp;gt;codegen()) {
-      // We&#39;re just doing this to make sure it executes.
-      TheExecutionEngine-&amp;gt;finalizeObject();
-      // JIT the function, returning a function pointer.
-      void *FPtr = TheExecutionEngine-&amp;gt;getPointerToFunction(FnIR);
-
-      // Cast it to the right type (takes no arguments, returns a double) so we
-      // can call it as a native function.
-      double (*FP)() = (double (*)())(intptr_t)FPtr;
-      // Ignore the return value for this.
-      (void)FP;
+    if (!F-&amp;gt;codegen()) {
+      fprintf(stderr, &amp;quot;Error generating code for top level expr&amp;quot;);
     }
   } else {
     // Skip token for error recovery.
@@ -1439,11 +1459,11 @@ int main() {
   // target lays out data structures.
   TheModule-&amp;gt;setDataLayout(TheExecutionEngine-&amp;gt;getDataLayout());
   OurFPM.add(new DataLayoutPass());
+#if 0
   OurFPM.add(createBasicAliasAnalysisPass());
   // Promote allocas to registers.
   OurFPM.add(createPromoteMemoryToRegisterPass());
@@ -1218,7 +1210,7 @@ int main() {
   OurFPM.add(createGVNPass());
   // Simplify the control flow graph (deleting unreachable blocks, etc).
   OurFPM.add(createCFGSimplificationPass());
-
+  #endif
   OurFPM.doInitialization();

   // Set the global so the code gen can use this.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这相对较小的更改使我们能够通过此命令行将我们的Kaleidoscope语言编译为可执行程序：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Kaleidoscope-Ch9 &amp;lt; fib.ks | &amp;amp; clang -x ir -
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行这条命令，会在当前目录中生成a.out/ a.exe。&lt;/p&gt;

&lt;h1 id=&#34;9-4-编译单元&#34;&gt;9.4 编译单元&lt;/h1&gt;

&lt;p&gt;DWARF中一段代码的顶级容器是一个编译单元。它包含单个翻译单元的类型和函数数据（读取：源代码的一个文件）。所以我们需要做的第一件事是为fib.ks文件构造一个编译单元。&lt;/p&gt;

&lt;h1 id=&#34;9-5-dwarf-emission-setup&#34;&gt;9.5 DWARF Emission Setup&lt;/h1&gt;

&lt;p&gt;与&lt;code&gt;IRBuilder&lt;/code&gt;类似，我们有一个&lt;a href=&#34;http://llvm.org/doxygen/classllvm_1_1DIBuilder.html&#34;&gt;DIBuilder&lt;/a&gt;类，可以帮助构建LLVM IR文件调试所需的原始数据。&lt;code&gt;DIBuilder&lt;/code&gt;与&lt;code&gt;IRBuilder&lt;/code&gt;类似，只是名字更好听一点。要想使用&lt;code&gt;DIBuilder&lt;/code&gt;，需要你对DWARF有所了解，但是如果你仔细阅读有关&lt;a href=&#34;http://llvm.org/docs/SourceLevelDebugging.html&#34;&gt;元数据格式&lt;/a&gt;的文档，那么就对&lt;code&gt;DIBuilder&lt;/code&gt;会更加了解。我们将使用该类来构造所有的我们的IR级描述。它的构造需要一个模块，所以我们需要在构建模块后不久就构建它。我们会把它作为一个全局静态变量，这样会使它更容易使用。&lt;/p&gt;

&lt;p&gt;接下来，我们将创建一个小容器来缓存我们的一些经常使用的数据。第一个就是我们的编译单元，我也会为我们的类型编写一些代码，因为我们不必担心多个类型表达式（我们的类型只有double）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;static DIBuilder *DBuilder;

struct DebugInfo {
  DICompileUnit *TheCU;
  DIType *DblTy;

  DIType *getDoubleTy();
} KSDbgInfo;

DIType *DebugInfo::getDoubleTy() {
  if (DblTy)
    return DblTy;

  DblTy = DBuilder-&amp;gt;createBasicType(&amp;quot;double&amp;quot;, 64, dwarf::DW_ATE_float);
  return DblTy;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在我们构建模块时的&amp;rsquo;main&amp;rsquo;中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;DBuilder = new DIBuilder(*TheModule);

KSDbgInfo.TheCU = DBuilder-&amp;gt;createCompileUnit(
    dwarf::DW_LANG_C, DBuilder-&amp;gt;createFile(&amp;quot;fib.ks&amp;quot;, &amp;quot;.&amp;quot;),
    &amp;quot;Kaleidoscope Compiler&amp;quot;, 0, &amp;quot;&amp;quot;, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里有几点需要注意。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一，当我们为一种叫做Kaleidoscope的语言生成一个编译单元时，我们会用到C语言常量。这是因为调式器不一定理解它无法识别的语言的调用约定或默认ABI，并且我们在&lt;strong&gt;LLVM代码生成中遵循C ABI约定&lt;/strong&gt;，因此它是最准确的。这确保了我们可以实际&lt;strong&gt;调用来自调试器的函数&lt;/strong&gt;，并且让他们执行。&lt;/li&gt;
&lt;li&gt;第二，你将会在调用 &lt;code&gt;createCompileUnit&lt;/code&gt; 时看到 &amp;ldquo;fib.ks&amp;rdquo;。这是一个默认的硬编码值，因为我们使用shell重定向来将我们的源码放入Kaleidoscope编译器中。在前端中，你通常有一个输入文件名，并且它最终即会转到那里。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作为通过 &lt;em&gt;DIBuilder&lt;/em&gt; 生成调试信息的一部分，最后一件事情是我们需要&amp;rsquo;finalize&amp;rsquo;调试信息。原因是DIBuilder底层API的一部分，但请确保在main结束时执行此操作：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;DBuilder-&amp;gt;finalize();
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;9-6-函数&#34;&gt;9.6 函数&lt;/h1&gt;

&lt;p&gt;现在我们有了我们的编译单元和源码的位置，我们可以在调试信息中添加函数定义。所以在 &lt;code&gt;PrototypeAST::codegen()&lt;/code&gt;中，我们添加了几行代码来描述子程序的上下文，在该例子中上下文是&amp;rdquo;File&amp;rdquo;，以及函数本身的实际定义。&lt;/p&gt;

&lt;p&gt;所以上下文：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;DIFile *Unit = DBuilder-&amp;gt;createFile(KSDbgInfo.TheCU.getFilename(),
                                    KSDbgInfo.TheCU.getDirectory());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给我们一个 &lt;strong&gt;DIFile&lt;/strong&gt; 并且询问我们上面创建的编译单元，来获取我们当前所在的目录和文件名字。然后，现在，我们使用 0 的一些源位置（因为我们的AST当前没有源位置信息）并且构造我们的函数定义：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;DIScope *FContext = Unit;
unsigned LineNo = 0;
unsigned ScopeLine = 0;
DISubprogram *SP = DBuilder-&amp;gt;createFunction(
    FContext, P.getName(), StringRef(), Unit, LineNo,
    CreateFunctionType(TheFunction-&amp;gt;arg_size(), Unit),
    false /* internal linkage */, true /* definition */, ScopeLine,
    DINode::FlagPrototyped, false);
TheFunction-&amp;gt;setSubprogram(SP);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们现在有了一个 &lt;code&gt;DISubprogram&lt;/code&gt;，它包含了对该函数的所有元数据的引用。&lt;/p&gt;

&lt;h1 id=&#34;9-7-源代码位置&#34;&gt;9.7 源代码位置&lt;/h1&gt;

&lt;p&gt;对于调试信息来说，最重要的事情是&lt;strong&gt;准确的源代码位置&lt;/strong&gt; &amp;ndash; 这样就可以将源代码映射回来。我们现在有一个问题就是&lt;strong&gt;Kaleidoscope 在词法分析器和解析器中没有记录任何源代码位置信息&lt;/strong&gt;，所以我们需要添加它：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct SourceLocation {
  int Line;
  int Col;
};
static SourceLocation CurLoc;
static SourceLocation LexLoc = {1, 0};

static int advance() {
  int LastChar = getchar();

  if (LastChar == &#39;\n&#39; || LastChar == &#39;\r&#39;) {
    LexLoc.Line++;
    LexLoc.Col = 0;
  } else
    LexLoc.Col++;
  return LastChar;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这组代码中，我们添加了一些关于&lt;strong&gt;如何跟踪“源文件”的行和列&lt;/strong&gt;的功能。因为我们词法分析其会记录每个token，所以我们设置我们目前的“词汇定位”设置为token开头的行和列。我们通过使用新的advance() 重载所有之前对 &lt;em&gt;getchar()&lt;/em&gt; 的调用来跟踪信息，然后我们将所有AST类添加到源位置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class ExprAST {
  SourceLocation Loc;

  public:
    ExprAST(SourceLocation Loc = CurLoc) : Loc(Loc) {}
    virtual ~ExprAST() {}
    virtual Value* codegen() = 0;
    int getLine() const { return Loc.Line; }
    int getCol() const { return Loc.Col; }
    virtual raw_ostream &amp;amp;dump(raw_ostream &amp;amp;out, int ind) {
      return out &amp;lt;&amp;lt; &#39;:&#39; &amp;lt;&amp;lt; getLine() &amp;lt;&amp;lt; &#39;:&#39; &amp;lt;&amp;lt; getCol() &amp;lt;&amp;lt; &#39;\n&#39;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们创建一个新的表达式时，我们会传递下去：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;LHS = llvm::make_unique&amp;lt;BinaryExprAST&amp;gt;(BinLoc, BinOp, std::move(LHS),
                                       std::move(RHS));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为我们的每个表达式和变量提供了位置信息。&lt;/p&gt;

&lt;p&gt;无论什么时候我们到了一个新的位置时，为了确保每条指令都获得合适的定位信息，我们必须要告诉 *Builder*。这时我们会使用一个小的辅助函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void DebugInfo::emitLocation(ExprAST *AST) {
  DIScope *Scope;
  if (LexicalBlocks.empty())
    Scope = TheCU;
  else
    Scope = LexicalBlocks.back();
  Builder.SetCurrentDebugLocation(
      DebugLoc::get(AST-&amp;gt;getLine(), AST-&amp;gt;getCol(), Scope));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这既会告诉主要的&lt;code&gt;IRBuilder&lt;/code&gt;我们现在在哪，也会告诉它我们当前的作用域范围。作用域范围可以是编译单元级别的，也可以是最近的封闭词汇块，如当前函数。为了表示这个，我们会创建一个栈来记录范围：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::vector&amp;lt;DIScope *&amp;gt; LexicalBlocks;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们开始为每个函数生成代码时，将范围（函数）推送到堆栈的顶部：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;KSDbgInfo.LexicalBlocks.push_back(SP);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时，我们还要在函数代码产生的末尾弹出作用域：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Pop off the lexical block for the function since we added it
// unconditionally.
KSDbgInfo.LexicalBlocks.pop_back();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，我们会确保每次我们开始为新的AST对象产生代码时emit位置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;KSDbgInfo.emitLocation(this);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;9-8-变量&#34;&gt;9.8 变量&lt;/h1&gt;

&lt;p&gt;现在我们有了函数，我们需要能够打印作用域中的变量。让我们设置我们的函数参数，这样我们就可以获得不错的 &lt;code&gt;backtraces&lt;/code&gt;（回溯） 并且看看我们的函数是如何被调用的。这并不需要写很多代码，我们通常当我们在 &lt;code&gt;FunctionAST::codegen&lt;/code&gt; 创建参数allocas时处理它。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Record the function arguments in the NamedValues map.
NamedValues.clear();
unsigned ArgIdx = 0;
for (auto &amp;amp;Arg : TheFunction-&amp;gt;args()) {
  // Create an alloca for this variable.
  AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName());

  // Create a debug descriptor for the variable.
  DILocalVariable *D = DBuilder-&amp;gt;createParameterVariable(
      SP, Arg.getName(), ++ArgIdx, Unit, LineNo, KSDbgInfo.getDoubleTy(),
      true);

  DBuilder-&amp;gt;insertDeclare(Alloca, D, DBuilder-&amp;gt;createExpression(),
                          DebugLoc::get(LineNo, 0, SP),
                          Builder.GetInsertBlock());

  // Store the initial value into the alloca.
  Builder.CreateStore(&amp;amp;Arg, Alloca);

  // Add arguments to variable symbol table.
  NamedValues[Arg.getName()] = Alloca;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里我们首先会创建变量，给它作用域范围（SP)，名称，源位置，类型，因为它是一个参数，还需要有参数索引。下一步，我们创建一个 &lt;code&gt;lvm.dbg.declare&lt;/code&gt; 调用来指示在 IR 级别我们在 alloca 中有一个变量（并且它给出了变量的起始位置），并在申明上为该范围的开头设置了一个源位置。&lt;/p&gt;

&lt;p&gt;此刻需要注意的一件有趣的事情是，各种调试器会根据过去为它们生成代码和调试信息进行假设。在这个例子中，我们需要做一些hack来避免产生为函数prologue产生行信息，以便于当设置断点时，调试器知道跳过这些指令。所以我们在 &lt;code&gt;FunctionAST::CodeGen&lt;/code&gt; 添加一些更多的行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Unset the location for the prologue emission (leading instructions with no
// location in a function are considered part of the prologue and the debugger
// will run past them when breaking on a function)
KSDbgInfo.emitLocation(nullptr);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们实际开始为函数体生成代码时emit一个新的位置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;KSDbgInfo.emitLocation(Body.get());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了这个，我们有足够的调试信息来设置函数中的断点，打印参数变量，并且调用函数。只需要几行简单的代码就行了！&lt;/p&gt;

&lt;h1 id=&#34;9-9-全部代码&#34;&gt;9.9 全部代码&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Compile
$clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native` -O3 -o toy
# Run
$./toy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl09.html#full-code-listing&#34;&gt;http://llvm.org/docs/tutorial/LangImpl09.html#full-code-listing&lt;/a&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Kaleidoscope：Compile to Object Code</title>
      <link>https://l0phtg.github.io/post/llvm/kaleidoscopecompile-to-object-code/</link>
      <pubDate>Sun, 16 Jun 2019 18:42:08 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/llvm/kaleidoscopecompile-to-object-code/</guid>
      
        <description>&lt;p&gt;translate from:&lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl08.html&#34;&gt;http://llvm.org/docs/tutorial/LangImpl08.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本章为“LLVM Tutorial”的第八章：将代码编译为目标对象文件。&lt;/p&gt;

&lt;p&gt;本章内容比较简单。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;8-1-第八章介绍&#34;&gt;8.1 第八章介绍&lt;/h1&gt;

&lt;p&gt;欢迎来到&lt;strong&gt;“通过LLVM实现一个语言”&lt;/strong&gt;教程的第八章。本章描述了&lt;strong&gt;如何将我们Kaleidoscope程序编译为目标文件&lt;/strong&gt;。&lt;/p&gt;

&lt;h1 id=&#34;8-2-选择一个目标&#34;&gt;8.2 选择一个目标&lt;/h1&gt;

&lt;p&gt;LLVM本身支持交叉编译。你可以将项目编译为适用于你当前机器的架构（或者其它架构）的程序，都是很容易完成的。在本教程中，我们将会编译程序为当前机器的架构。&lt;/p&gt;

&lt;p&gt;为了指定我们要编译目标的架构，我们使用一个名为“target triple”的字符串。它的形式为 &amp;lt;arch&amp;gt;&amp;lt;sub&amp;gt;-&amp;lt;vendor&amp;gt;-&amp;lt;sys&amp;gt;-&amp;lt;abi&amp;gt; (阅读&lt;a href=&#34;http://clang.llvm.org/docs/CrossCompilation.html#target-triple&#34;&gt;交叉编译文档&lt;/a&gt;)。&lt;/p&gt;

&lt;p&gt;举个例子，我们可以通过运行下面这条命令看到当前平台架构：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ clang --version | grep Target
Target: x86_64-unknown-linux-gnu
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为你的架构和操作系统可能和我的不一样，所以在你的机器上运行该命令可能显示出不同的结果。&lt;/p&gt;

&lt;p&gt;幸运地是，我们不需要硬编码一个target triple（目标三元组）来表示当前机器。LLVM提供一个函数：&lt;em&gt;sys::getDefaultTargetTriple&lt;/em&gt; ，调用该函数可以得到当前机器的target triple。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto TargetTriple = sys::getDefaultTargetTriple();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;LLVM不要求我们链接所有目标平台。例如，如果我们只是使用JIT，我们就不需要汇编代码生成。同样地，如果我们仅针对某些体系结构，我们可以只链接这些体系结构。&lt;/p&gt;

&lt;p&gt;例如，为了生成目标对象代码，我们将初始化所有的目标：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;InitializeAllTargetInfos();
InitializeAllTargets();
InitializeAllTargetMCs();
InitializeAllAsmParsers();
InitializeAllAsmPrinters();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们现在能够使用我们target triple来获得目标平台的Target：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;std::string Error;
auto Target = TargetRegistry::lookupTarget(TargetTriple, Error);

// Print an error and exit if we couldn&#39;t find the requested target.
// This generally occurs if we&#39;ve forgotten to initialise the
// TargetRegistry or we have a bogus target triple.
if (!Target) {
  errs() &amp;lt;&amp;lt; Error;
  return 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;8-3-目标机器&#34;&gt;8.3 目标机器&lt;/h1&gt;

&lt;p&gt;我们还需要一个&lt;em&gt;TargetMachine&lt;/em&gt;. 此类提供了我们当前机器的完整机器描述。如果我们想要指定一个特定的特性（例如SSE）或指定的CPU（例如intel的Sandylake），我们现在就可以开始了。&lt;/p&gt;

&lt;p&gt;我们可以通过llc，来获得LLVM包含的特性和CPU。例如，我们指定目标架构为x86:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ llvm-as &amp;lt; /dev/null | llc -march=x86 -mattr=help
Available CPUs for this target:

  amdfam10      - Select the amdfam10 processor.
  athlon        - Select the athlon processor.
  athlon-4      - Select the athlon-4 processor.
  ...

Available features for this target:

  16bit-mode            - 16-bit mode (i8086).
  32bit-mode            - 32-bit mode (80386).
  3dnow                 - Enable 3DNow! instructions.
  3dnowa                - Enable 3DNow! Athlon instructions.
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于我们的示例，我们将使用没有任何额外特性、选项或者重定位模型的通用CPU。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto CPU = &amp;quot;generic&amp;quot;;
auto Features = &amp;quot;&amp;quot;;

TargetOptions opt;
auto RM = Optional&amp;lt;Reloc::Model&amp;gt;();
auto TargetMachine = Target-&amp;gt;createTargetMachine(TargetTriple, CPU, Features, opt, RM);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;8-4-配置模块&#34;&gt;8.4 配置模块&lt;/h1&gt;

&lt;p&gt;我们现在开始准备配置我们的模块，以指定*Target*和*data layout*数据布局。严格来说，这不是必要的，但是&lt;a href=&#34;http://llvm.org/docs/Frontend/PerformanceTips.html&#34;&gt;前端性能指南&lt;/a&gt;推荐我们这样做。在知道了*Target*目标和*data layout*数据布局后，会很大程度上帮助我们提高优化能力。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;TheModule-&amp;gt;setDataLayout(TargetMachine-&amp;gt;createDataLayout());
TheModule-&amp;gt;setTargetTriple(TargetTriple);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;8-5-emit-object-code&#34;&gt;8.5 Emit Object Code&lt;/h1&gt;

&lt;p&gt;我们现在准备生成obj代码！ 让我们定义生成的文件位置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto Filename = &amp;quot;output.o&amp;quot;;
std::error_code EC;
raw_fd_ostream dest(Filename, EC, sys::fs::F_None);

if (EC) {
  errs() &amp;lt;&amp;lt; &amp;quot;Could not open file: &amp;quot; &amp;lt;&amp;lt; EC.message();
  return 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，我们定义了一个pass来生成obf代码。然后我们运行该pass:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;legacy::PassManager pass;
auto FileType = TargetMachine::CGFT_ObjectFile;

if (TargetMachine-&amp;gt;addPassesToEmitFile(pass, dest, nullptr, FileType)) {
  errs() &amp;lt;&amp;lt; &amp;quot;TargetMachine can&#39;t emit a file of this type&amp;quot;;
  return 1;
}

pass.run(*TheModule);
dest.flush();
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;8-6-将它们放在一起&#34;&gt;8.6 将它们放在一起&lt;/h1&gt;

&lt;p&gt;我们做的工作成功了吗？让我们测试一下！我们需要编译我们的代码，但是注意&lt;code&gt;llvm-config&lt;/code&gt;指定的参数与前面的章节是不同的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ clang++ -g -O3 toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs all` -o toy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;让我们运行它，并定义一个计算平均值的函数。当你输入完成的时候，按 Ctrl-D。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./toy
ready&amp;gt; def average(x y) (x + y) * 0.5;
^D
Wrote output.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们生成了一个目标文件！为了测试它是否是生成正确，让我们编写一个简单的程序并且将它与我们的输出相链接。这里是源代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

extern &amp;quot;C&amp;quot; {
    double average(double, double);
}

int main() {
    std::cout &amp;lt;&amp;lt; &amp;quot;average of 3.0 and 4.0: &amp;quot; &amp;lt;&amp;lt; average(3.0, 4.0) &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们将我们的程序链接为output.o并且检查结果是否符合我们的预期：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ clang++ main.cpp output.o -o main
$ ./main
average of 3.0 and 4.0: 3.5
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;full-code-listing&#34;&gt;Full Code Listing&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl08.html#full-code-listing&#34;&gt;http://llvm.org/docs/tutorial/LangImpl08.html#full-code-listing&lt;/a&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Kaleidoscope：Extending the Language：Mutable Variables</title>
      <link>https://l0phtg.github.io/post/llvm/kaleidoscopeextending-the-languagemutable-variables/</link>
      <pubDate>Wed, 12 Jun 2019 19:43:42 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/llvm/kaleidoscopeextending-the-languagemutable-variables/</guid>
      
        <description>&lt;p&gt;translate from: &lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl07.html&#34;&gt;http://llvm.org/docs/tutorial/LangImpl07.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本章为“LLVM tutorial”的第七章：为Kaleidoscope添加对&lt;strong&gt;改变变量&lt;/strong&gt;功能的支持。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;改变已经存在的变量：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;函数参数。&lt;/li&gt;
&lt;li&gt;迭代变量。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在Codegen层面，为了改变这些变量，我们会为通过调用Alloca指令为每个变量在栈上创建空间，之后想要改变该变量的值可以通过Store指令来实现对变量值的改变，使用Load指令读取Alloca内存中的值（同时，我们还要修改NamedValues映射）。&lt;/p&gt;

&lt;p&gt;具体到Kaleidoscope语法层面，我们通过&amp;rsquo;=&amp;lsquo;运算符达到对已经定义变量的改变。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;新定义一个变量：&lt;/p&gt;

&lt;p&gt;通过关键字var/in实现。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#39;mermaid&#39;&gt;
graph TB
    subgraph 添加 var/in 以支持用户自定义变量
        subgraph 1.添加词法分析支持
            extendParser[&#34;扩展词法分析器&#34;]
        end
        subgraph 2.构建varExprAST
            buildAST[&#34;定义varExprAST节点&#34;] --&gt; parseAST[&#34;实现ParserVarExpr达到对var/in表达式的解析&#34;]
        end
        subgraph 3.添加Codegen支持
            varExprCodegen[&#34;实现varExprAST的Codegen&#34;]
        end
        extendParser --&gt; buildAST
        parseAST --&gt; varExprCodegen
    end
    subgraph 添加 赋值运算符 以支持改变已有变量
        subgraph 1.根据已有变量创建Alloca指令
            createAlloca[&#34;为现有的变量创建Alloca指令&#34;] --&gt; StoreInitialValue[&#34;Alloca内存中存入初始值&#34;]
            StoreInitialValue --&gt; updateSymbolTable[&#34;更新NamedValues符号表&#34;]
        end
        subgraph 2.利用Alloca实现变量引用
            variableCodegen[&#34;更改VariableExprAST实现变量引用&#34;]
        end
        subgraph 3.添加mem2reg Pass
            addMem2regPass[&#34;添加mem2reg Pass支持&#34;]
        end
        subgraph 3.定义赋值运算符实现变量修改
            serPrecedence[添加赋值运算符并设置运算符优先级] --&gt; binaryCodegen[&#34;为赋值运算符实现Codegen&#34;]
        end
        updateSymbolTable --&gt; variableCodegen
        variableCodegen --&gt; addMem2regPass
        addMem2regPass --&gt; serPrecedence
    end
    
    style buildAST fill:#f9f
    style parseAST fill:#f9f
    style variableCodegen fill:#f9f
    style serPrecedence fill:#f9f
    style binaryCodegen fill:#f9f
    
    style varExprCodegen fill:#ccff66
    style addMem2regPass fill:#ccff66
&lt;/div&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;chapter-7-introduction&#34;&gt;Chapter 7 Introduction&lt;/h1&gt;

&lt;p&gt;欢迎来到“使用LLVM来实现一门语言”的第七章。在第一章到第六章，我们已经构建了一个简单但是功能强大的编程语言。在我们的学习过程中，我们学习了一些&lt;strong&gt;词法解析技巧&lt;/strong&gt;，&lt;strong&gt;如何构建和表示AST&lt;/strong&gt;，&lt;strong&gt;如何生成 LLVM IR&lt;/strong&gt;，以及&lt;strong&gt;如何优化结果代码&lt;/strong&gt;以及 &lt;strong&gt;使用JIT来编译它&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;虽然 Kaleidoscope 作为一种功能性语言是非常有趣的，但同时对于它来说产生LLVM IR的实现是很简单的。特别地，函数式语言使得&lt;strong&gt;直接以 SSA 形式构建 LLVM IR 变得非常容易&lt;/strong&gt;。由于 LLVM 要求输入代码是 SSA 形式的（这是非常好的性质），但是对于新手来说不明白&lt;strong&gt;如何使用可变变量为命令式语言产生代码&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;本章的内容: 你不必为前端构建 SSA形式，LLVM为此提供了高度优化且经过良好测试的支持，尽管它的工作方式对某些人来说有点意外。&lt;/p&gt;

&lt;h1 id=&#34;7-2-为什么这是一个困难的问题&#34;&gt;7.2 为什么这是一个困难的问题？&lt;/h1&gt;

&lt;p&gt;为了理解为什么可变变量会&lt;strong&gt;导致SSA构造的复杂性&lt;/strong&gt;*，考虑下面这个极其简单的 c 代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int G, H;
int test(_Bool Condition) {
  int X;
  if (Condition)
    X = G;
  else
    X = H;
  return X;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个例子中，我们有变量 &amp;ldquo;X&amp;rdquo;，&lt;strong&gt;它的值依赖于程序运行时执行的路径&lt;/strong&gt;。因为返回指令之前有两个可能的值，所以一个 PHI 节点会被插入以用来合并这两个值。它生成的LLVM IR看起来像下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-llvm&#34;&gt;@G = weak global i32 0   ; type of @G is i32*
@H = weak global i32 0   ; type of @H is i32*

define i32 @test(i1 %Condition) {
entry:
  br i1 %Condition, label %cond_true, label %cond_false

cond_true:
  %X.0 = load i32* @G
  br label %cond_next

cond_false:
  %X.1 = load i32* @H
  br label %cond_next

cond_next:
  %X.2 = phi i32 [ %X.1, %cond_false ], [ %X.0, %cond_true ]
  ret i32 %X.2
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在此例中，来自 G 和 H 全局变量的加载在 LLVM IR 中是显式的，并且他们位于 if 语句的 then/else 分支（ cond_true/cond_false）。为了合并传入的值，在 cond_next 块中根据控制流来自何处来选择要使用的正确值：如果控制流来自 cond_false 块，X.2 将会得到 X.1 的值。可选地，如果控制流来自 cond_true，它得到 X.0 的值。本章的目的不是解释 SSA 形式的细节。为了了解更多有关SSA的信息，请阅读 &lt;a href=&#34;http://en.wikipedia.org/wiki/Static_single_assignment_form&#34;&gt;many online references&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;本篇文章的问题是“当降低可变变量的赋值时，谁会放置phi节点?”. 这里的问题是 LLVM 要求它的 IR 一定是 SSA 形式：它没有“非SSA”模式。然而，SSA构造需要 非平凡（non-trivial） 算法和数据结构，所以对于每一个前端来说必须重写这段逻辑，它是不方便并且也是浪费的。&lt;/p&gt;

&lt;h1 id=&#34;7-3-llvm中的内存&#34;&gt;7.3 LLVM中的内存&lt;/h1&gt;

&lt;p&gt;这里的“技巧”是：LLVM要求所有的寄存器值都是SSA形式，它不要求（或者允许）内存对象是 SSA 形式。在上面的例子中，注意到 G 和 H 的负载是对 G 和 H 的直接访问：他们不会重命名或者更改版本。这与其他一些会尝试改变内存对象的版本的编译器系统不同。在 LLVM 中，它不会将内存的数据流分析编码到 LLVM IR 中，而是通过&lt;a href=&#34;http://llvm.org/docs/WritingAnLLVMPass.html&#34;&gt;分析passes&lt;/a&gt;来处理（按需计算）。&lt;/p&gt;

&lt;p&gt;考虑到这一点，高级一些的思路是我们为函数中的每个可变对象创建一个栈变量。为了利用这个技巧，我们需要讨论 LLVM 如何表示栈变量。&lt;/p&gt;

&lt;p&gt;在LLVM中，&lt;strong&gt;所有内存访问都是显式地通过使用加载/存储指令来完成的&lt;/strong&gt;，并且它被精心设计过使它不需要“地址”运算符。注意&lt;strong&gt;@G/@H全局变量的类型实际上是 &amp;ldquo;i32&amp;rdquo;&lt;/strong&gt;，即使该变量被定义为“i32”。这意味着@G在全局数据区域中为一个i32定义了空间，但是它的名字实际上指向该空间的地址。栈变量工作方式相同，除了不是使用全局变量定义声明，应该使用&lt;a href=&#34;http://llvm.org/docs/LangRef.html#alloca-instruction&#34;&gt;LLVM alloca&lt;/a&gt;指令申明它们：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-llvm&#34;&gt;define i32 @example() {
entry:
  %X = alloca i32           ; type of %X is i32*.
  ...
  %tmp = load i32* %X       ; load the stack value %X from the stack.
  %tmp2 = add i32 %tmp, 1   ; increment it
  store i32 %tmp2, i32* %X  ; store it back
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此代码展示了&lt;strong&gt;如何在LLVM IR中申明和操作堆栈变量&lt;/strong&gt;。使用alloca指令分配的堆栈内存是完全通用的：你可以将堆栈槽的地址传给函数，你可以将其存储在其它变量中，等等。在我们上面的例子中，我们可以&lt;strong&gt;使用alloca技术重写&lt;/strong&gt;来避免使用PHI节点：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-llvm&#34;&gt;@G = weak global i32 0   ; type of @G is i32*
@H = weak global i32 0   ; type of @H is i32*

define i32 @test(i1 %Condition) {
entry:
  %X = alloca i32           ; type of %X is i32*.
  br i1 %Condition, label %cond_true, label %cond_false

cond_true:
  %X.0 = load i32* @G
  store i32 %X.0, i32* %X   ; Update X
  br label %cond_next

cond_false:
  %X.1 = load i32* @H
  store i32 %X.1, i32* %X   ; Update X
  br label %cond_next

cond_next:
  %X.2 = load i32* %X       ; Read X
  ret i32 %X.2
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过这种方式，我们发现了一种&lt;strong&gt;不需要创建PHI节点就能处理任意可变变量的方法&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;每一个可变变量都成为栈分配；&lt;/li&gt;
&lt;li&gt;每次读取变量变成了栈中加载；&lt;/li&gt;
&lt;li&gt;变量的每次更新变成了向栈中存储；&lt;/li&gt;
&lt;li&gt;获取变量的地址只是直接使用栈地址；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;虽然这个解决方案解决了我们目前的问题，但是它引入了另一个问题：我们现在显然已经为非常简单和常见的操作引入了大量的栈流量，&lt;strong&gt;这是一个主要的性能的问题&lt;/strong&gt;。对我们来说是幸运地是，&lt;strong&gt;LLVM优化器有一个名为“mem2reg”的高度优化的pass来处理这种情况&lt;/strong&gt;，将分配提升到 SSA 寄存器中，并根据需要插入PHI节点。例如，如果你通过该pass运行此例，你将获得：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-llvm&#34;&gt;$ llvm-as &amp;lt; example.ll | opt -mem2reg | llvm-dis
@G = weak global i32 0
@H = weak global i32 0

define i32 @test(i1 %Condition) {
entry:
  br i1 %Condition, label %cond_true, label %cond_false

cond_true:
  %X.0 = load i32* @G
  br label %cond_next

cond_false:
  %X.1 = load i32* @H
  br label %cond_next

cond_next:
  %X.01 = phi i32 [ %X.1, %cond_false ], [ %X.0, %cond_true ]
  ret i32 %X.01
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mem2reg pass&lt;strong&gt;实现了用于构造SSA形式的标准“iterated dominance frontier”算法&lt;/strong&gt;，并且具有很多非常常见的优化。mem2reg 优化 pass 是处理可变变量的实现方案，我们强烈推荐你依赖它。注意：&lt;strong&gt;mem2reg只对特定情况下的变量可以起作用&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;mem2reg 是 alloca 驱动的：它寻找allocas，如果它可以处理他们，它会促进他们。它不适用于全局变量或者堆分配变量。&lt;/li&gt;
&lt;li&gt;mem2reg 只在函数的&lt;strong&gt;entry block查找alloca指令&lt;/strong&gt;。在entry block中保证alloca&lt;strong&gt;只执行一次&lt;/strong&gt;（这会使分析更简单）。&lt;/li&gt;
&lt;li&gt;mem2reg 只能优化&lt;strong&gt;使用直接加载和存储的allocas&lt;/strong&gt;。如果栈变量的地址被传递给一个函数，或者涉及任何有趣的指针算法，则不会优化alloca。&lt;/li&gt;
&lt;li&gt;mem2reg只对第一类值的allocas起作用（such as 指针、标量和向量），并且仅在分配的数组大小是1时有效（或者在.ll文件中缺失才有效）。mem2reg无法将结构体或者数组转换为寄存器。注意：“sroa” pass 是一个更加强大的pass，它在许多情况下可以转换结构体，“联合”，和数组为寄存器。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所有这些性质属性对于命令式语言都是很适合的，我们将在下面用Kaleidoscope进行说明。你可能会问的最后一个问题是：&lt;strong&gt;我应该为我的前端使用mem2reg吗&lt;/strong&gt;? &lt;strong&gt;如果我直接使用SSA构建，避免使用mem2reg会不会更好&lt;/strong&gt;？简而言之，我们强烈建议你使用此技术来构建SSA形式，除非有非常好的理由不这样做。&lt;/p&gt;

&lt;p&gt;使用mem2reg的优点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;经验证且经过充分的测试：clang对于本地可变变量会使用mem2reg。你可以确保快速找到错误并尽早修复。&lt;/li&gt;
&lt;li&gt;速度极快：mem2reg 有许多特殊的情况，可以使它在常见情况下快速完成。例如，它对于只被用于单个基本块的变量（这些变量只有一个赋值的地方）有一个快速的路径，它会避免插入不需要的phi节点，等等。&lt;/li&gt;
&lt;li&gt;需要调试信息生成：在LLVM中&lt;a href=&#34;http://llvm.org/docs/SourceLevelDebugging.html&#34;&gt;调试信息&lt;/a&gt;依赖于公开变量的地址，以便可以将调试信息附加到它上面。这种技术与这种调试信息风格非常吻合。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果不出意外，这样会使你的前端更容易上手和运行，并且实现起来非常简单。现在让我们开始为Kaleidoscope添加可变变量扩展吧！&lt;/p&gt;

&lt;h1 id=&#34;7-4-kaleidoscope中可变变量&#34;&gt;7.4 Kaleidoscope中可变变量&lt;/h1&gt;

&lt;p&gt;现在我们知道了我们想要解决的问题，让我们看看在Kaleidoscope它是如何实现的。我们将会添加两个特性：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用‘=’运算符来改变变量的能力。&lt;/li&gt;
&lt;li&gt;定义新变量的能力。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;到目前为止，我们的变量包含&lt;strong&gt;传入的参数&lt;/strong&gt;和&lt;strong&gt;归纳的变量（迭代变量）&lt;/strong&gt;和&lt;strong&gt;重新定义的那些变量&lt;/strong&gt;:). 此外，无论你是否改变变量，拥有定义新变量的能力都是有用的。这是一个很不错的例子，展示了我们如何使用它们：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Define &#39;:&#39; for sequencing: as a low-precedence operator that ignores operands
# and just returns the RHS.
def binary : 1 (x y) y;

# Recursive fib, we could do this before.
def fib(x)
  if (x &amp;lt; 3) then
    1
  else
    fib(x-1)+fib(x-2);

# Iterative fib.
def fibi(x)
  var a = 1, b = 1, c in
  (for i = 3, i &amp;lt; x in
     c = a + b :
     a = b :
     b = c) :
  b;

# Call it.
fibi(10);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了改变变量，我们必须使用“alloca技巧”来实现。一旦我们实现了该功能，我们之后将会添加一个新的运算符，然后扩展Kaleidoscope来支持新的变量定义。&lt;/p&gt;

&lt;h1 id=&#34;7-5-改变现有的变量&#34;&gt;7.5 改变现有的变量&lt;/h1&gt;

&lt;p&gt;代码生成时，Kaleidoscope中的符号表通过&amp;rdquo;NamedValues&amp;rdquo;映射来管理。这个映射目前跟踪了LLVM的“Value”，它包含给定变量的数值。为了支持变量的改变，我们需要稍微改变一下代码，&lt;strong&gt;使 &lt;em&gt;NamedValues&lt;/em&gt; 保存有问题变量的内存位置&lt;/strong&gt;。注意：这种改变是一种重构：它改变了代码的结构，但是没有（本身）改变编译器的行为。所有这些改变都只在Kaleidoscope代码产生器进行。&lt;/p&gt;

&lt;p&gt;在Kaleidoscope的发展过程中，它目前只支持两种类型的变量：函数的传入参数和&amp;rsquo;for&amp;rsquo;循环的归纳（迭代）变量。为了保持一致性，除了其他用户定义的变量外，我们还允许对这些变量进行改变。这意味着这些都需要内存位置。&lt;/p&gt;

&lt;p&gt;为了开始我们的Kaleidoscope的转换，我们将改变NamedValues映射，使其映射到AllocaInst*而不是Value *。一旦我们这样做了， C++编译器将告诉我们代码中哪些部分需要更新。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;static std::map&amp;lt;std::string, AllocaInst*&amp;gt; NamedValues;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此外，因为我们需要创建这些allocas，我们将使用一个辅助函数来确保在函数的入口块创建allocas：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// CreateEntryBlockAlloca - Create an alloca instruction in the entry block of
/// the function.  This is used for mutable variables etc.
static AllocaInst *CreateEntryBlockAlloca(Function *TheFunction,
                                          const std::string &amp;amp;VarName) {
  IRBuilder&amp;lt;&amp;gt; TmpB(&amp;amp;TheFunction-&amp;gt;getEntryBlock(),
                 TheFunction-&amp;gt;getEntryBlock().begin());
  return TmpB.CreateAlloca(Type::getDoubleTy(TheContext), 0,
                           VarName.c_str());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个看起来很有趣的代码创建了一个指向入口块的第一条指令的IRBuilder对象(.begin())。它然后根据给定名称创建了一个alloca并返回它。因为在Kaleidoscope中所有的值都是doubles，因此不必传入要使用的类型。&lt;/p&gt;

&lt;p&gt;有了辅助函数之后，我们想要做的第一个功能改变属于&lt;strong&gt;变量引用&lt;/strong&gt;。在我们新的方案中，变量存在于栈中，所以生成一个对代码的引用实际上需要从栈上产生一个加载指令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Value *VariableExprAST::codegen() {
  // Look this variable up in the function.
  // 读取 Value
  Value *V = NamedValues[Name];
  if (!V)
    return LogErrorV(&amp;quot;Unknown variable name&amp;quot;);

  // Load the value.
  // 加载value
  return Builder.CreateLoad(V, Name.c_str());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正如你看到的，这非常简单。现在我们需要更新定义变量的内容来设置alloca。我们将从 ForExprAST::codegen()开始:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Function *TheFunction = Builder.GetInsertBlock()-&amp;gt;getParent();

// Create an alloca for the variable in the entry block.
// 在entry block中为变量创建Alloca指令
AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);

// Emit the start code first, without &#39;variable&#39; in scope.
Value *StartVal = Start-&amp;gt;codegen();
if (!StartVal)
  return nullptr;

// Store the value into the alloca.
// 将值存入Alloca中
Builder.CreateStore(StartVal, Alloca);
...

// Compute the end condition.
Value *EndCond = End-&amp;gt;codegen();
if (!EndCond)
  return nullptr;

// Reload, increment, and restore the alloca.  This handles the case where
// the body of the loop mutates the variable.
Value *CurVar = Builder.CreateLoad(Alloca);
Value *NextVar = Builder.CreateFAdd(CurVar, StepVal, &amp;quot;nextvar&amp;quot;);
Builder.CreateStore(NextVar, Alloca);
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此代码实际上与我们之前的代码大致相同。最大的区别是我们不再需要构建一个PHI节点，并且我们使用 load/store 来根据需要获取变量。&lt;/p&gt;

&lt;p&gt;为了支持可变参数变量，我们还需要为它们进行分配空间。代码实现也非常简单：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Function *FunctionAST::codegen() {
  ...
  Builder.SetInsertPoint(BB);

  // Record the function arguments in the NamedValues map.
  NamedValues.clear();
  for (auto &amp;amp;Arg : TheFunction-&amp;gt;args()) {
    // Create an alloca for this variable.
    // 为每个变量创建Alloca
    AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName());

    // Store the initial value into the alloca.
    // 将初始值存入Alloca中
    Builder.CreateStore(&amp;amp;Arg, Alloca);

    // Add arguments to variable symbol table.
    更新NamedValues符号表
    NamedValues[Arg.getName()] = Alloca;
  }

  if (Value *RetVal = Body-&amp;gt;codegen()) {
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于每个参数，我们都会创建一个alloca指令，将函数的参数（即初始值）存储到alloca分配的空间中，并将alloca注册为参数的内存位置。在为函数设置了入口基本块之后，Function::codegen()立即被调用。&lt;/p&gt;

&lt;p&gt;最后剩下的部分是添加mem2reg pass，这可以使我们生成的代码进行再一次的优化：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Promote allocas to registers.
TheFPM-&amp;gt;add(createPromoteMemoryToRegisterPass());
// Do simple &amp;quot;peephole&amp;quot; optimizations and bit-twiddling optzns.
TheFPM-&amp;gt;add(createInstructionCombiningPass());
// Reassociate expressions.
TheFPM-&amp;gt;add(createReassociatePass());
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有趣的是看看mem2reg优化运行之前和之后的代码是什么样的。例如，这是我们的递归fib函数的优化前/优化后代码。在优化之前：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-llvm&#34;&gt;define double @fib(double %x) {
entry:
  %x1 = alloca double
  store double %x, double* %x1
  %x2 = load double, double* %x1
  %cmptmp = fcmp ult double %x2, 3.000000e+00
  %booltmp = uitofp i1 %cmptmp to double
  %ifcond = fcmp one double %booltmp, 0.000000e+00
  br i1 %ifcond, label %then, label %else

then:       ; preds = %entry
  br label %ifcont

else:       ; preds = %entry
  %x3 = load double, double* %x1
  %subtmp = fsub double %x3, 1.000000e+00
  %calltmp = call double @fib(double %subtmp)
  %x4 = load double, double* %x1
  %subtmp5 = fsub double %x4, 2.000000e+00
  %calltmp6 = call double @fib(double %subtmp5)
  %addtmp = fadd double %calltmp, %calltmp6
  br label %ifcont

ifcont:     ; preds = %else, %then
  %iftmp = phi double [ 1.000000e+00, %then ], [ %addtmp, %else ]
  ret double %iftmp
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里只有一个变量（x，传入的参数）但是你仍然可以看到我们正在使用的极其简单的代码生成策略。在入口基本块，一个alloca被创建，并且初始值被存储到其中。每个对变量的引用都会从栈中重新加载。注意：我们不会修改 if/then/else 表达式，因为它只插入PHI节点。虽然我们可以为它创建一个alloca，但实际上为它创建一个PHI节点是更容易的，所以我们仍然使用PHI指令。&lt;/p&gt;

&lt;p&gt;下面是mem2reg pass运行之后的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-llvm&#34;&gt;define double @fib(double %x) {
entry:
  %cmptmp = fcmp ult double %x, 3.000000e+00
  %booltmp = uitofp i1 %cmptmp to double
  %ifcond = fcmp one double %booltmp, 0.000000e+00
  br i1 %ifcond, label %then, label %else

then:
  br label %ifcont

else:
  %subtmp = fsub double %x, 1.000000e+00
  %calltmp = call double @fib(double %subtmp)
  %subtmp5 = fsub double %x, 2.000000e+00
  %calltmp6 = call double @fib(double %subtmp5)
  %addtmp = fadd double %calltmp, %calltmp6
  br label %ifcont

ifcont:     ; preds = %else, %then
  %iftmp = phi double [ 1.000000e+00, %then ], [ %addtmp, %else ]
  ret double %iftmp
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是mem2reg的一个简单案例，因为没有对变量进行重新定义。&lt;/p&gt;

&lt;p&gt;在剩余的优化运行之后，我们得到：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-llvm&#34;&gt;define double @fib(double %x) {
entry:
  %cmptmp = fcmp ult double %x, 3.000000e+00
  %booltmp = uitofp i1 %cmptmp to double
  %ifcond = fcmp ueq double %booltmp, 0.000000e+00
  br i1 %ifcond, label %else, label %ifcont

else:
  %subtmp = fsub double %x, 1.000000e+00
  %calltmp = call double @fib(double %subtmp)
  %subtmp5 = fsub double %x, 2.000000e+00
  %calltmp6 = call double @fib(double %subtmp5)
  %addtmp = fadd double %calltmp, %calltmp6
  ret double %addtmp

ifcont:
  ret double 1.000000e+00
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里，我们看到simplifycfg pass决定将返回指令克隆到‘else’块的末尾。这允许它消除一些分支和PHI节点。&lt;/p&gt;

&lt;p&gt;现在所有的符号表引用都更新为使用栈变量，之后我们将添加赋值运算符。&lt;/p&gt;

&lt;h1 id=&#34;7-6-创建赋值运算符&#34;&gt;7.6 创建赋值运算符&lt;/h1&gt;

&lt;p&gt;使用我们目前的框架，添加新的赋值运算符是非常简单的。我们将会和解析其他二元操作符一样解析它，但是我们是在内部处理它（而不是允许用户定义它）。第一步是设置优先级：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int main() {
  // Install standard binary operators.
  // 1 is lowest precedence.
  BinopPrecedence[&#39;=&#39;] = 2;
  BinopPrecedence[&#39;&amp;lt;&#39;] = 10;
  BinopPrecedence[&#39;+&#39;] = 20;
  BinopPrecedence[&#39;-&#39;] = 20;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在负责所有解析和AST生成的解析器知道了二元运算符的优先级。我们只需要为赋值运算符实现codegen。这看起来像：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Value *BinaryExprAST::codegen() {
  // Special case &#39;=&#39; because we don&#39;t want to emit the LHS as an expression.
  if (Op == &#39;=&#39;) {
    // Assignment requires the LHS to be an identifier.
    VariableExprAST *LHSE = dynamic_cast&amp;lt;VariableExprAST*&amp;gt;(LHS.get());
    if (!LHSE)
      return LogErrorV(&amp;quot;destination of &#39;=&#39; must be a variable&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;与其他二元运算符不同，我们的赋值运算符不遵循“emit LHS，emit RHS，do computation”模型。因此，在其他二元运算符被处理之前，它会被当作一个特殊的例子来处理。另一个奇怪的事情是它需要&lt;strong&gt;将LHS作为变量&lt;/strong&gt;。“(x + 1) = expr”无效，只允许“x = expr”之类的二元表达式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt; // Codegen the RHS.
  Value *Val = RHS-&amp;gt;codegen();
  if (!Val)
    return nullptr;

  // Look up the name.
  Value *Variable = NamedValues[LHSE-&amp;gt;getName()];
  if (!Variable)
    return LogErrorV(&amp;quot;Unknown variable name&amp;quot;);

  Builder.CreateStore(Val, Variable);
  return Val;
}
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一旦我们得到了变量，codegen的赋值就是很简单直接的：我们emit赋值的RHS，创建一个store，并且返回计算值。返回值允许链式赋值，就像“X = (Y = Z)”。&lt;/p&gt;

&lt;p&gt;现在我们有了一个赋值运算符，我们可以改变循环变量和参数。例如，我们现在可以运行下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Function to print a double.
extern printd(x);

# Define &#39;:&#39; for sequencing: as a low-precedence operator that ignores operands
# and just returns the RHS.
def binary : 1 (x y) y;

def test(x)
  printd(x) :
  x = 4 :
  printd(x);

test(123);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行时，该代码先打印“123”，然后打印“4”，表明了我们实际上确实改变了该值。不错，我们现在正式实现了我们的目标：在一般情况下，要实现该目标需要SSA构建。然而，为了真正有用，我们希望能够定义我们自己的本地变量，让我们接下来添加它。&lt;/p&gt;

&lt;h1 id=&#34;7-7-用户定义变量&#34;&gt;7.7 用户定义变量&lt;/h1&gt;

&lt;p&gt;添加 var/in 就像我们对Kaleidoscope进行的任何其他扩展一样：我们扩展词法分析器，解析器和AST以及代码生成器。添加新的&amp;rsquo;var/in&amp;rsquo;结构的第一步是&lt;strong&gt;扩展词法分析器&lt;/strong&gt;。和以前一样，这非常简单，代码就像下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;enum Token {
  ...
  // var definition
  tok_var = -13
...
}
...
static int gettok() {
...
    if (IdentifierStr == &amp;quot;in&amp;quot;)
      return tok_in;
    if (IdentifierStr == &amp;quot;binary&amp;quot;)
      return tok_binary;
    if (IdentifierStr == &amp;quot;unary&amp;quot;)
      return tok_unary;
    if (IdentifierStr == &amp;quot;var&amp;quot;)
      return tok_var;
    return tok_identifier;
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下一步是&lt;strong&gt;定义我们将要构造的AST节点&lt;/strong&gt;。对于 var/in 来说，它看起来就像下面这样:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// VarExprAST - Expression class for var/in
class VarExprAST : public ExprAST {
  std::vector&amp;lt;std::pair&amp;lt;std::string, std::unique_ptr&amp;lt;ExprAST&amp;gt;&amp;gt;&amp;gt; VarNames;
  std::unique_ptr&amp;lt;ExprAST&amp;gt; Body;

public:
  VarExprAST(std::vector&amp;lt;std::pair&amp;lt;std::string, std::unique_ptr&amp;lt;ExprAST&amp;gt;&amp;gt;&amp;gt; VarNames,
             std::unique_ptr&amp;lt;ExprAST&amp;gt; Body)
    : VarNames(std::move(VarNames)), Body(std::move(Body)) {}

  Value *codegen() override;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;var/in允许一次定义名称列表，每个名称可以选择是否拥有初始值。因此，我们在VarNames向量中获取此信息。另外，var/in有body，它被允许访问var/in定义的变量。&lt;/p&gt;

&lt;p&gt;有了这个，我们可以定义解析器片段。我们要做的第一件事是将其添加为主要表达式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// primary
///   ::= identifierexpr
///   ::= numberexpr
///   ::= parenexpr
///   ::= ifexpr
///   ::= forexpr
///   ::= varexpr
static std::unique_ptr&amp;lt;ExprAST&amp;gt; ParsePrimary() {
  switch (CurTok) {
  default:
    return LogError(&amp;quot;unknown token when expecting an expression&amp;quot;);
  case tok_identifier:
    return ParseIdentifierExpr();
  case tok_number:
    return ParseNumberExpr();
  case &#39;(&#39;:
    return ParseParenExpr();
  case tok_if:
    return ParseIfExpr();
  case tok_for:
    return ParseForExpr();
  case tok_var:	// 此处添加了一个case
    return ParseVarExpr();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们定义 &lt;em&gt;ParseVarExpr&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// varexpr ::= &#39;var&#39; identifier (&#39;=&#39; expression)?
//                    (&#39;,&#39; identifier (&#39;=&#39; expression)?)* &#39;in&#39; expression
static std::unique_ptr&amp;lt;ExprAST&amp;gt; ParseVarExpr() {
  getNextToken();  // eat the var.

  std::vector&amp;lt;std::pair&amp;lt;std::string, std::unique_ptr&amp;lt;ExprAST&amp;gt;&amp;gt;&amp;gt; VarNames;

  // At least one variable name is required.
  // 至少有一个变量名字
  if (CurTok != tok_identifier)
    return LogError(&amp;quot;expected identifier after var&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此代码的第一部分将&lt;strong&gt;标识符/表达式列表&lt;/strong&gt;解析为&lt;strong&gt;本地VarNames向量&lt;/strong&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;while (1) {
  std::string Name = IdentifierStr;
  getNextToken();  // eat identifier.

  // Read the optional initializer.
  std::unique_ptr&amp;lt;ExprAST&amp;gt; Init;
  if (CurTok == &#39;=&#39;) {
    getNextToken(); // eat the &#39;=&#39;.

    Init = ParseExpression();
    if (!Init) return nullptr;
  }

  VarNames.push_back(std::make_pair(Name, std::move(Init)));

  // End of var list, exit loop.
  if (CurTok != &#39;,&#39;) break;
  getNextToken(); // eat the &#39;,&#39;.

  if (CurTok != tok_identifier)
    return LogError(&amp;quot;expected identifier list after var&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一旦解析完成了所有变量，我们就会解析body并创建AST节点：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;  // At this point, we have to have &#39;in&#39;.
  // 我们有了 in 表达式
  if (CurTok != tok_in)
    return LogError(&amp;quot;expected &#39;in&#39; keyword after &#39;var&#39;&amp;quot;);
  getNextToken();  // eat &#39;in&#39;.

  auto Body = ParseExpression();
  if (!Body)
    return nullptr;

  return llvm::make_unique&amp;lt;VarExprAST&amp;gt;(std::move(VarNames),
                                       std::move(Body));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们可以解析并且表示代码，我们需要支持emmision of LLVM IR for it.我们可以这样开始：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Value *VarExprAST::codegen() {
  std::vector&amp;lt;AllocaInst *&amp;gt; OldBindings;

  Function *TheFunction = Builder.GetInsertBlock()-&amp;gt;getParent();

  // Register all variables and emit their initializer.
  // 注册所有的变量并且emit他们的初始化器
  for (unsigned i = 0, e = VarNames.size(); i != e; ++i) {
    const std::string &amp;amp;VarName = VarNames[i].first;
    ExprAST *Init = VarNames[i].second.get();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它会遍历所有变量，一次记录一个变量。对于我们放入符号表的每个变量，我们保存了OldBindings中记录的以前的值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;  // Emit the initializer before adding the variable to scope, this prevents
  // the initializer from referencing the variable itself, and permits stuff
  // like this:
  //  var a = 1 in
  //    var a = a in ...   # refers to outer &#39;a&#39;.
  Value *InitVal;
  if (Init) {
    InitVal = Init-&amp;gt;codegen();
    if (!InitVal)
      return nullptr;
  } else { // If not specified, use 0.0.
    InitVal = ConstantFP::get(TheContext, APFloat(0.0));
  }

  AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);
  Builder.CreateStore(InitVal, Alloca);

  // Remember the old variable binding so that we can restore the binding when
  // we unrecurse.
  OldBindings.push_back(NamedValues[VarName]);

  // Remember this binding.
  NamedValues[VarName] = Alloca;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码中包含很多注释。基本思路是我们emit初始化器，创建alloca，然后更新符号表来指向它。一旦所有的变量都存放在了符号表中，我们就会计算var/in表达式的body：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Codegen the body, now that all vars are in scope.
// 对 body 进行 Codegen，现在所有的变量都在作用域中。
Value *BodyVal = Body-&amp;gt;codegen();
if (!BodyVal)
  return nullptr;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，在返回之前，我们恢复以前的变量绑定：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;  // Pop all our variables from scope.
  for (unsigned i = 0, e = VarNames.size(); i != e; ++i)
    NamedValues[VarNames[i].first] = OldBindings[i];

  // Return the body computation.
  return BodyVal;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终结果是我们获得了确定定义域内的变量定义，并且我们甚至允许改变他们。&lt;/p&gt;

&lt;p&gt;现在我们完成了我们想要做的。我们的迭代fit示例可以成功编译并运行得很好。mem2reg pass将我们所有的栈变量优化到了SSA寄存器中，在需要的地方插入PHI节点，并且我们的前端实现仍然是很简单的：在任何地方都没有“iterated dominance frontier”计算。&lt;/p&gt;

&lt;h1 id=&#34;7-8-全部代码&#34;&gt;7.8 全部代码&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl07.html#id1&#34;&gt;http://llvm.org/docs/tutorial/LangImpl07.html#id1&lt;/a&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Kaleidoscope：Extending the Language：User Defined Operators</title>
      <link>https://l0phtg.github.io/post/llvm/kaleidoscopeextending-the-languageuser-defined-operators/</link>
      <pubDate>Tue, 11 Jun 2019 21:53:54 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/llvm/kaleidoscopeextending-the-languageuser-defined-operators/</guid>
      
        <description>&lt;p&gt;translate from: &lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl06.html&#34;&gt;http://llvm.org/docs/tutorial/LangImpl06.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;发一篇干货，接着之前的LLVM tutorial教程的翻译，本次翻译的为第六章。&lt;/p&gt;

&lt;p&gt;扩展我们的Kaleidoscope语言，以支持用户定义操作符（一元操作符和二元操作符）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;为了实现用户自定义运算符，我们采用了&lt;strong&gt;扩展函数申明和扩展函数定义&lt;/strong&gt;的实现方式。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为了实现对用户自定义运算符的表达式支持：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;针对用户自定义的二元运算符。因为我们之前已经支持了部分二元运算符（如+、- 等），所以我们只需要扩展BinaryExprAST来支持用户自定义的二元运算符即可；&lt;/li&gt;
&lt;li&gt;针对用户自定义的一元运算符。我们需要定义UnaryExprAST抽象语法树，并实现Codegen支持，且添加到解析表达式的逻辑中。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;mermaid&#34;&gt;
graph TB

    subgraph 二元运算符
        binaryParser[1. 添加词法分析支持] 
        subgraph 2. 实现用户自定义二元运算符函数
        funcProtoExtend[扩展函数申明AST] --&gt; funcProtoParser[扩展ParsePrototype函数]
        end 
        binaryParser --&gt; funcProtoExtend
        funcProtoParser --&gt; binaryCodegen[3. 在BinaryExprAST的Codegen中支持自定义的二元运算符]
    end

    subgraph 一元运算符
        unaryParser[&#34;1. 添加词法分析支持&#34;] 
        subgraph 2. 实现用户自定义的一元运算符函数
            unaryFuncProtoExtend[扩展函数申明AST] --&gt; unaryFuncProtoParser[扩展ParsePrototype函数]
        end
        unaryParser --&gt; unaryFuncProtoExtend
        subgraph 3. 实现一元运算符表达式的解析 
            createUnaryAST[创建UnaryExprAST节点] --&gt; parseUnary[添加解析一元运算符表达式的函数]
            parseUnary --&gt; parsePrimary[在ParsePrimay中添加调用ParseUnary的逻辑]
        end
        unaryFuncProtoParser --&gt; createUnaryAST
    end

    style funcProtoExtend fill:#f9f
    style funcProtoParser fill:#f9f
    style unaryFuncProtoExtend fill:#f9f
    style unaryFuncProtoParser fill:#f9f
    
    style binaryCodegen fill:#ccff66
    style createUnaryAST fill:#ccff66
    style parseUnary fill:#ccff66
    style parsePrimary fill:#ccff66

&lt;/div&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;6-1-第六章介绍&#34;&gt;6.1 第六章介绍&lt;/h1&gt;

&lt;p&gt;欢迎来到第六章。在我们的教程中，我们现在拥有一个功能完备的语言，它非常简单，但也非常有用。然而，它仍然存在一个大问题。我们的语言没有很多有用的运算符（例如除法，逻辑否定，甚至除了小于以外的任何比较运算符）。&lt;/p&gt;

&lt;p&gt;本章对简单而漂亮的Kaleidoscope语言添加用户定义的运算符，但是我们会稍微偏离主题。这种偏题会导致我们的语言变得有些丑陋，但是会让我们的语言很强大。创建自己语言的好处是：你可以决定什么是好的或者坏的。在本教程中，我们假设可以使用它作为一种展示一些有趣的解析技术的方式。&lt;/p&gt;

&lt;p&gt;在本教程的最后，我们将会运行一个Kaleidoscope 应用 that &lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl06.html#kicking-the-tires&#34;&gt;renders the Mandelbrot set&lt;/a&gt;（渲染Mandelbrot集合）。我们将会通过Kaleidoscope来构建该例子，并且来展示Kaleidoscope的特性，&lt;/p&gt;

&lt;h1 id=&#34;6-2-用户定义运算符-思路&#34;&gt;6.2 用户定义运算符： 思路&lt;/h1&gt;

&lt;p&gt;我们将会添加“&lt;strong&gt;运算符重载&lt;/strong&gt;”功能到Kaleidoscope语言中，它的设计将比C++中的设计更加通用。在C++中，你只能重新定义已经存在的运算符：你不能人工改变语法，并引入新的运算符，改变优先级等。在本章，我们将在Kaleidoscope语言中添加此功能，这可以用户就可以使用更多自定义的运算符。&lt;/p&gt;

&lt;p&gt;我们现在介绍用于定义运算符的目的是&lt;strong&gt;展示使用手写解析器的强大功能和灵活性&lt;/strong&gt;。到目前为止，我们实现的解析器在大部分对于表达式的语法和操作符优先级解析中都使用到了递归下降。可以阅读&lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl02.html&#34;&gt;第二章&lt;/a&gt;了解更多相关的内容。通过使用运算符优先级解析，允许程序员在语法中引入新的运算符是相当容易的：程序在JIT运行时，语法是动态可扩展的。&lt;/p&gt;

&lt;p&gt;我们将会添加两个功能：可以编程的一元运算符(unary operators)（现在，Kaleidoscope还没有一元运算符）以及二元运算符(binary operators)。&lt;/p&gt;

&lt;p&gt;一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Logical unary not.
def unary!(v)
  if v then
    0
  else
    1;

# Define &amp;gt; with the same precedence as &amp;lt;.
def binary&amp;gt; 10 (LHS RHS)
  RHS &amp;lt; LHS;

# Binary &amp;quot;logical or&amp;quot;, (note that it does not &amp;quot;short circuit&amp;quot;)
def binary| 5 (LHS RHS)
  if LHS then
    1
  else if RHS then
    1
  else
    0;

# Define = with slightly lower precedence than relationals.
def binary= 9 (LHS RHS)
  !(LHS &amp;lt; RHS | LHS &amp;gt; RHS);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;许多语言都希望能够&lt;strong&gt;使用该语言本身来实现其标准库&lt;/strong&gt;。在Kaleidoscope中，我们可以在库中实现该语言的重要部分！&lt;/p&gt;

&lt;p&gt;我们将这些功能的实现分解为两个部分：实现对&lt;strong&gt;用户定义的二元运算符的支持&lt;/strong&gt;和&lt;strong&gt;添加一元运算符&lt;/strong&gt;。&lt;/p&gt;

&lt;h1 id=&#34;6-3-用户定义的二元运算符&#34;&gt;6.3 用户定义的二元运算符&lt;/h1&gt;

&lt;p&gt;使用我们目前的框架来添加对用户定义的二元运算符的支持非常简单。我们将首先添加对一元/二元关键字：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;enum Token {
  ...
  // operators
  tok_binary = -11,
  tok_unary = -12
};
...
static int gettok() {
...
    if (IdentifierStr == &amp;quot;for&amp;quot;)
      return tok_for;
    if (IdentifierStr == &amp;quot;in&amp;quot;)
      return tok_in;
    if (IdentifierStr == &amp;quot;binary&amp;quot;)
      return tok_binary;
    if (IdentifierStr == &amp;quot;unary&amp;quot;)
      return tok_unary;
    return tok_identifier;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这只是添加了对一元和二元关键字的&lt;strong&gt;词法支持&lt;/strong&gt;。当前的AST的优点是：我们通过使用该二元运算符操作码的ASCI码来表示具有范型的二元运算符。对于我们扩展的操作符来说，我们将使用相同的表示，所以我们不需要任何新的AST或者解析器支持。&lt;/p&gt;

&lt;p&gt;在另一方面，我们必须保证在函数定义时，可以正确解析和表示这些新的运算符的定义，例如&amp;rdquo;def binary | 5&amp;rdquo;。到目前为止，我们的语法中，&lt;strong&gt;函数定义时的名字被解析作为申明&lt;/strong&gt;，并且会进入到&lt;strong&gt;PrototypeAST&lt;/strong&gt; AST 节点。为了将我们新定义的运算符表示为申明，我们必须扩展&lt;strong&gt;Prototype&lt;/strong&gt; AST 节点：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// PrototypeAST - This class represents the &amp;quot;prototype&amp;quot; for a function,
/// which captures its argument names as well as if it is an operator.
class PrototypeAST {
  std::string Name;
  std::vector&amp;lt;std::string&amp;gt; Args;
  bool IsOperator;      // 是否是运算符
  unsigned Precedence;  // Precedence if a binary op. 运算符优先级

public:
  PrototypeAST(const std::string &amp;amp;name, std::vector&amp;lt;std::string&amp;gt; Args,
               bool IsOperator = false, unsigned Prec = 0)
  : Name(name), Args(std::move(Args)), IsOperator(IsOperator),
    Precedence(Prec) {}

  Function *codegen();
  const std::string &amp;amp;getName() const { return Name; }

  bool isUnaryOp() const { return IsOperator &amp;amp;&amp;amp; Args.size() == 1; }
  bool isBinaryOp() const { return IsOperator &amp;amp;&amp;amp; Args.size() == 2; }

  char getOperatorName() const {
    assert(isUnaryOp() || isBinaryOp());
    return Name[Name.size() - 1];
  }

  unsigned getBinaryPrecedence() const { return Precedence; }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基本上，除了要知道一个申明的名字之外，我们现在还要跟踪&lt;strong&gt;它是否为一个运算符&lt;/strong&gt;，并且如果它是的话，&lt;strong&gt;运算符的优先级别是什么&lt;/strong&gt;。优先级仅仅被用于二元运算符（正如你将在下面看到的，它对一元运算符不适用）。现在我们有了一种方法来表示对用户定义运算符的声明，我们现在来解析它：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// prototype
///   ::= id &#39;(&#39; id* &#39;)&#39;
///   ::= binary LETTER number? (id, id)
static std::unique_ptr&amp;lt;PrototypeAST&amp;gt; ParsePrototype() {
  std::string FnName;

  unsigned Kind = 0;  // 0 = identifier, 1 = unary, 2 = binary.
  unsigned BinaryPrecedence = 30;

  switch (CurTok) {
  default:
    return LogErrorP(&amp;quot;Expected function name in prototype&amp;quot;);
  case tok_identifier:
    FnName = IdentifierStr;
    Kind = 0;
    getNextToken();
    break;
  case tok_binary:
    getNextToken();
    if (!isascii(CurTok))
      return LogErrorP(&amp;quot;Expected binary operator&amp;quot;);
    FnName = &amp;quot;binary&amp;quot;;			// 为二元运算符设置FnName = &amp;quot;binary&amp;quot;+CurTok
    FnName += (char)CurTok;
    Kind = 2;
    getNextToken();

    // Read the precedence if present.
    if (CurTok == tok_number) {
      if (NumVal &amp;lt; 1 || NumVal &amp;gt; 100)
        return LogErrorP(&amp;quot;Invalid precedence: must be 1..100&amp;quot;);
      BinaryPrecedence = (unsigned)NumVal;
      getNextToken();
    }
    break;
  }

  if (CurTok != &#39;(&#39;)
    return LogErrorP(&amp;quot;Expected &#39;(&#39; in prototype&amp;quot;);

  std::vector&amp;lt;std::string&amp;gt; ArgNames;
  while (getNextToken() == tok_identifier)
    ArgNames.push_back(IdentifierStr);
  if (CurTok != &#39;)&#39;)
    return LogErrorP(&amp;quot;Expected &#39;)&#39; in prototype&amp;quot;);

  // success.
  getNextToken();  // eat &#39;)&#39;.

  // Verify right number of names for operator.
  if (Kind &amp;amp;&amp;amp; ArgNames.size() != Kind)
    return LogErrorP(&amp;quot;Invalid number of operands for operator&amp;quot;);

  return llvm::make_unique&amp;lt;PrototypeAST&amp;gt;(FnName, std::move(ArgNames), Kind != 0,
                                         BinaryPrecedence);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码都非常简单，我们之前已经看到了很多类似的代码。关于上面的代码一个有趣的部分是为二元运算符设计FnName的那几行。这位新定义的“@”运算符构建了像“binary@”这样的名称。它利用了LLVM符号表中的符号表可以被允许包含任何字符的事实，甚至可以包括嵌入的nul字符。&lt;/p&gt;

&lt;p&gt;下一个有趣的事情是为这些二元运算符&lt;strong&gt;添加Codegen支持&lt;/strong&gt;（产生LLVM IR的代码）。通过使用我们目前的代码框架，在已经有了二元操作符节点后，实现Codegen只需要简单添加一个case。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Value *BinaryExprAST::codegen() {
  Value *L = LHS-&amp;gt;codegen();
  Value *R = RHS-&amp;gt;codegen();
  if (!L || !R)
    return nullptr;

  switch (Op) {
  case &#39;+&#39;:
    return Builder.CreateFAdd(L, R, &amp;quot;addtmp&amp;quot;);
  case &#39;-&#39;:
    return Builder.CreateFSub(L, R, &amp;quot;subtmp&amp;quot;);
  case &#39;*&#39;:
    return Builder.CreateFMul(L, R, &amp;quot;multmp&amp;quot;);
  case &#39;&amp;lt;&#39;:
    L = Builder.CreateFCmpULT(L, R, &amp;quot;cmptmp&amp;quot;);
    // Convert bool 0/1 to double 0.0 or 1.0
    return Builder.CreateUIToFP(L, Type::getDoubleTy(TheContext),
                                &amp;quot;booltmp&amp;quot;);
  default:
    break;
  }

  // If it wasn&#39;t a builtin binary operator, it must be a user defined one. Emit
  // a call to it.
  // 如果它不是一个内建的二元操作符，它一定是用户定义的二元操作符。Emit a call to it.
  Function *F = getFunction(std::string(&amp;quot;binary&amp;quot;) + Op);
  assert(F &amp;amp;&amp;amp; &amp;quot;binary operator not found!&amp;quot;);

  Value *Ops[2] = { L, R };
  return Builder.CreateCall(F, Ops, &amp;quot;binop&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正如上面看到的，添加的代码实际上非常简单。它只是&lt;strong&gt;在符号表中查找合适的运算符并且生成对它的函数调用&lt;/strong&gt;。由于用户定义的运算符只是被作为普通函数构建（因为“申明”就是有正确名称的函数）。&lt;/p&gt;

&lt;p&gt;我们最好还需要添加的一段代码，是&lt;strong&gt;一段顶级膜法&lt;/strong&gt;（hhhh）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Function *FunctionAST::codegen() {
  // Transfer ownership of the prototype to the FunctionProtos map, but keep a
  // reference to it for use below.
  // 将申明的所有权转移到了FunctionProtos映射中，但是会保留一个引用以便于之后调用。
  auto &amp;amp;P = *Proto;
  FunctionProtos[Proto-&amp;gt;getName()] = std::move(Proto);
  Function *TheFunction = getFunction(P.getName());
  if (!TheFunction)
    return nullptr;

  // If this is an operator, install it.、
  // 如果当前正在解析的函数是一个运算符函数，install it.
  if (P.isBinaryOp())
    BinopPrecedence[P.getOperatorName()] = P.getBinaryPrecedence(); // 赋予它优先级

  // Create a new basic block to start insertion into.
  BasicBlock *BB = BasicBlock::Create(TheContext, &amp;quot;entry&amp;quot;, TheFunction);
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基本上，在一个函数codegen之前，如果它是一个用户定义的运算符，我们会在优先级表中注册它。这会允许我们使用已经有的二元运算符解析逻辑来处理它。由于我们正在研究一个完全通用的运算符优先级解析器，所以我们需要做的就是“扩展语法”。&lt;/p&gt;

&lt;p&gt;现在我们有了有用的用户定义的二元运算符。我们在之前的框架上添加了一些逻辑来支持这个功能。&lt;/p&gt;

&lt;p&gt;添加一元运算符是更具有挑战性的，因为我们还没有任何框架 &amp;ndash; let&amp;rsquo;s see what it takes.&lt;/p&gt;

&lt;h1 id=&#34;6-4-用户定义的一元运算符&#34;&gt;6.4 用户定义的一元运算符&lt;/h1&gt;

&lt;p&gt;由于目前我们的Kaleidoscope语言中还不支持一元运算符，所以为了支持该功能，我们必须要从头开始做。在之前的介绍中，我们已经在词法分析器中为一元运算符添加了&amp;rdquo;unary&amp;rdquo;关键字支持。除此之外，我们还需要&lt;strong&gt;创建AST节点&lt;/strong&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// UnaryExprAST - Expression class for a unary operator.
class UnaryExprAST : public ExprAST {
  char Opcode;
  std::unique_ptr&amp;lt;ExprAST&amp;gt; Operand;

public:
  UnaryExprAST(char Opcode, std::unique_ptr&amp;lt;ExprAST&amp;gt; Operand)
    : Opcode(Opcode), Operand(std::move(Operand)) {}

  Value *codegen() override;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到现在为止，AST节点的意义是非常简单明了的。除了一元运算符只有一个子节点之外（二元运算符有两个子节点），它与二元运算符的AST节点基本相同。有了AST节点之后，我们需要&lt;strong&gt;添加解析逻辑&lt;/strong&gt;。解析一元运算符实现起来是非常简单的：&lt;strong&gt;我们将添加一个新的函数来支持该功能&lt;/strong&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// unary
///   ::= primary
///   ::= &#39;!&#39; unary
static std::unique_ptr&amp;lt;ExprAST&amp;gt; ParseUnary() {
  // If the current token is not an operator, it must be a primary expr.
  // 如果当前处理的token不是运算符，那它就一定是一个主表达式。
  if (!isascii(CurTok) || CurTok == &#39;(&#39; || CurTok == &#39;,&#39;)
    return ParsePrimary();

  // If this is a unary operator, read it.
  // 如果它是一个一元运算符，read it。
  int Opc = CurTok;
  getNextToken();
  if (auto Operand = ParseUnary())
    return llvm::make_unique&amp;lt;UnaryExprAST&amp;gt;(Opc, std::move(Operand));
  return nullptr;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里我们添加的语法是非常简单的。当解析主运算符时，如果我们看到了一个一元运算符，我们将会将运算符作为前缀使用，并且将剩余的部分解析为另一个一元运算符。这允许我们处理多个一元运算符（例如“!!x”）。请注意，一元运算符不能像二元运算符那样具有模糊的解析，所以不需要优先级信息。&lt;/p&gt;

&lt;p&gt;这个函数的问题是：我们需要在某个地方调用&lt;strong&gt;ParseUnary&lt;/strong&gt;。为了做这个，我们改变以前的 &lt;strong&gt;ParsePrimay&lt;/strong&gt; 调用者来调用 &lt;strong&gt;ParseUnary&lt;/strong&gt; ：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// binoprhs
///   ::= (&#39;+&#39; unary)*
static std::unique_ptr&amp;lt;ExprAST&amp;gt; ParseBinOpRHS(int ExprPrec,
                                              std::unique_ptr&amp;lt;ExprAST&amp;gt; LHS) {
  ...
    // Parse the unary expression after the binary operator.
    // 在解析二元操作符后解析一元表达式
    auto RHS = ParseUnary();
    if (!RHS)
      return nullptr;
  ...
}
/// expression
///   ::= unary binoprhs
///
static std::unique_ptr&amp;lt;ExprAST&amp;gt; ParseExpression() {
  auto LHS = ParseUnary();
  if (!LHS)
    return nullptr;

  return ParseBinOpRHS(0, std::move(LHS));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了这两个改变之后，我们现在能够解析一元运算符并为他们构建AST。下一步，我们需要为申明添加解析器支持，来解析一元运算符的申明。我们对上面的二元运算符代码进行扩展：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// prototype
///   ::= id &#39;(&#39; id* &#39;)&#39;
///   ::= binary LETTER number? (id, id)
///   ::= unary LETTER (id)
static std::unique_ptr&amp;lt;PrototypeAST&amp;gt; ParsePrototype() {
  std::string FnName;

  unsigned Kind = 0;  // 0 = identifier, 1 = unary, 2 = binary.
  unsigned BinaryPrecedence = 30;

  switch (CurTok) {
  default:
    return LogErrorP(&amp;quot;Expected function name in prototype&amp;quot;);
  case tok_identifier:
    FnName = IdentifierStr;
    Kind = 0;
    getNextToken();
    break;
  case tok_unary:
    getNextToken();
    if (!isascii(CurTok))
      return LogErrorP(&amp;quot;Expected unary operator&amp;quot;);
    FnName = &amp;quot;unary&amp;quot;;
    FnName += (char)CurTok;
    Kind = 1;
    getNextToken();
    break;
  case tok_binary:
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和二元运算符一样，我们将一元运算符命名为包含operator+字符的名称。这有助于我们进行代码产生。Speaking of，我们需要添加的最后一部分是&lt;strong&gt;对一元运算符添加codegen支持&lt;/strong&gt;。它像下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Value *UnaryExprAST::codegen() {
  Value *OperandV = Operand-&amp;gt;codegen();
  if (!OperandV)
    return nullptr;

  Function *F = getFunction(std::string(&amp;quot;unary&amp;quot;) + Opcode);
  if (!F)
    return LogErrorV(&amp;quot;Unknown unary operator&amp;quot;);

  return Builder.CreateCall(F, OperandV, &amp;quot;unop&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此代码与二进制运算符的代码类似，但是更简单。它更简单，主要是因为它不需要处理任何预定义的运算符。&lt;/p&gt;

&lt;h1 id=&#34;6-5-kicking-the-tires&#34;&gt;6.5 Kicking the Tires&lt;/h1&gt;

&lt;p&gt;听起来是难以置信的，但是在有了最后几章中介绍的简单的扩展之后，Kaleidoscope就会成长为一个真正的语言。之后，我们可以使用Kaleidoscope做大量有趣的事情，包括I/O，数学，和一堆其它的东西。例如，我们现在可以添加一个排序运算符（printd 被定义为打印出指定的值和换行符）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ready&amp;gt; extern printd(x);
Read extern:
declare double @printd(double)

ready&amp;gt; def binary : 1 (x y) 0;  # Low-precedence operator that ignores operands.
...
ready&amp;gt; printd(123) : printd(456) : printd(789);
123.000000
456.000000
789.000000
Evaluated to 0.000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以定义一堆其它的“primitive”的操作，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Logical unary not.
# 逻辑 not
def unary!(v)
  if v then
    0
  else
    1;

# Unary negate.
# 一元运算符 负
def unary-(v)
  0-v;

# Define &amp;gt; with the same precedence as &amp;lt;.
# 定义 &amp;gt; 与 &amp;lt; 的优先级相同
def binary&amp;gt; 10 (LHS RHS)
  RHS &amp;lt; LHS;

# Binary logical or, which does not short circuit.
# 逻辑或
def binary| 5 (LHS RHS)
  if LHS then
    1
  else if RHS then
    1
  else
    0;

# Binary logical and, which does not short circuit.
# 逻辑 and
def binary&amp;amp; 6 (LHS RHS)
  if !LHS then
    0
  else
    !!RHS;

# Define = with slightly lower precedence than relationals.
# = 
def binary = 9 (LHS RHS)
  !(LHS &amp;lt; RHS | LHS &amp;gt; RHS);

# Define &#39;:&#39; for sequencing: as a low-precedence operator that ignores operands
# and just returns the RHS.
def binary : 1 (x y) y;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了之前的 if/then/else 支持，我们也可以为 I/O 定义一些有趣的函数。例如，下面打印出一个字符，其密度反映了传入的值： 值越低，字符越密集。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ready&amp;gt; extern putchard(char);
...
ready&amp;gt; def printdensity(d)
  if d &amp;gt; 8 then
    putchard(32)  # &#39; &#39;
  else if d &amp;gt; 4 then
    putchard(46)  # &#39;.&#39;
  else if d &amp;gt; 2 then
    putchard(43)  # &#39;+&#39;
  else
    putchard(42); # &#39;*&#39;
...
ready&amp;gt; printdensity(1): printdensity(2): printdensity(3):
       printdensity(4): printdensity(5): printdensity(9):
       putchard(10);
**++.
Evaluated to 0.000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基于这些简单的操作，我们可以开始定义一些有趣的东西。例如，这儿有一个函数，它确定复平面中某个函数发散所需的迭代次数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Determine whether the specific location diverges. 决定具体位置是否发散.
# Solve for z = z^2 + c in the complex plane. 求解复平面中的 z = z^2 + c.
def mandelconverger(real imag iters creal cimag)
  if iters &amp;gt; 255 | (real*real + imag*imag &amp;gt; 4) then
    iters
  else
    mandelconverger(real*real - imag*imag + creal,
                    2*real*imag + cimag,
                    iters+1, creal, cimag);

# Return the number of iterations required for the iteration to escape
# 返回iteration to escape所需的迭代次数.
def mandelconverge(real imag)
  mandelconverger(real, imag, 0, real, imag);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个“z = z2 + c”函数是一个漂亮的小生物(hhh)，是计算 &lt;a href=&#34;http://en.wikipedia.org/wiki/Mandelbrot_set&#34;&gt;Mandelbrot 集合&lt;/a&gt;的基础。我们的 mandelconverge 函数返回复杂轨道逃逸所需的迭代次数，饱和度是255。这本身不是一个有用的函数，但是如果你在二维平面上绘制它的值，你能够看到 Mandelbrot set。由于我们仅限于使用 putchard，我们的图形输出是有限的，但是我们可以使用上面的密度绘图仪将一些东西结合在一起。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Compute and plot the mandelbrot set with the specified 2 dimensional range
# info.
def mandelhelp(xmin xmax xstep   ymin ymax ystep)
  for y = ymin, y &amp;lt; ymax, ystep in (
    (for x = xmin, x &amp;lt; xmax, xstep in
       printdensity(mandelconverge(x,y)))
    : putchard(10)
  )

# mandel - This is a convenient helper function for plotting the mandelbrot set
# from the specified position with the specified Magnification.
def mandel(realstart imagstart realmag imagmag)
  mandelhelp(realstart, realstart+realmag*78, realmag,
             imagstart, imagstart+imagmag*40, imagmag);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了这个，我们可以尝试绘制出mandelbrot集合！ Lets try it out:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ready&amp;gt; mandel(-2.3, -1.3, 0.05, 0.07);
*******************************+++++++++++*************************************
*************************+++++++++++++++++++++++*******************************
**********************+++++++++++++++++++++++++++++****************************
*******************+++++++++++++++++++++.. ...++++++++*************************
*****************++++++++++++++++++++++.... ...+++++++++***********************
***************+++++++++++++++++++++++.....   ...+++++++++*********************
**************+++++++++++++++++++++++....     ....+++++++++********************
*************++++++++++++++++++++++......      .....++++++++*******************
************+++++++++++++++++++++.......       .......+++++++******************
***********+++++++++++++++++++....                ... .+++++++*****************
**********+++++++++++++++++.......                     .+++++++****************
*********++++++++++++++...........                    ...+++++++***************
********++++++++++++............                      ...++++++++**************
********++++++++++... ..........                        .++++++++**************
*******+++++++++.....                                   .+++++++++*************
*******++++++++......                                  ..+++++++++*************
*******++++++.......                                   ..+++++++++*************
*******+++++......                                     ..+++++++++*************
*******.... ....                                      ...+++++++++*************
*******.... .                                         ...+++++++++*************
*******+++++......                                    ...+++++++++*************
*******++++++.......                                   ..+++++++++*************
*******++++++++......                                   .+++++++++*************
*******+++++++++.....                                  ..+++++++++*************
********++++++++++... ..........                        .++++++++**************
********++++++++++++............                      ...++++++++**************
*********++++++++++++++..........                     ...+++++++***************
**********++++++++++++++++........                     .+++++++****************
**********++++++++++++++++++++....                ... ..+++++++****************
***********++++++++++++++++++++++.......       .......++++++++*****************
************+++++++++++++++++++++++......      ......++++++++******************
**************+++++++++++++++++++++++....      ....++++++++********************
***************+++++++++++++++++++++++.....   ...+++++++++*********************
*****************++++++++++++++++++++++....  ...++++++++***********************
*******************+++++++++++++++++++++......++++++++*************************
*********************++++++++++++++++++++++.++++++++***************************
*************************+++++++++++++++++++++++*******************************
******************************+++++++++++++************************************
*******************************************************************************
*******************************************************************************
*******************************************************************************
Evaluated to 0.000000
ready&amp;gt; mandel(-2, -1, 0.02, 0.04);
**************************+++++++++++++++++++++++++++++++++++++++++++++++++++++
***********************++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*********************+++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
*******************+++++++++++++++++++++++++++++++++++++++++++++++++++++++++...
*****************+++++++++++++++++++++++++++++++++++++++++++++++++++++++++.....
***************++++++++++++++++++++++++++++++++++++++++++++++++++++++++........
**************++++++++++++++++++++++++++++++++++++++++++++++++++++++...........
************+++++++++++++++++++++++++++++++++++++++++++++++++++++..............
***********++++++++++++++++++++++++++++++++++++++++++++++++++........        .
**********++++++++++++++++++++++++++++++++++++++++++++++.............
********+++++++++++++++++++++++++++++++++++++++++++..................
*******+++++++++++++++++++++++++++++++++++++++.......................
******+++++++++++++++++++++++++++++++++++...........................
*****++++++++++++++++++++++++++++++++............................
*****++++++++++++++++++++++++++++...............................
****++++++++++++++++++++++++++......   .........................
***++++++++++++++++++++++++.........     ......    ...........
***++++++++++++++++++++++............
**+++++++++++++++++++++..............
**+++++++++++++++++++................
*++++++++++++++++++.................
*++++++++++++++++............ ...
*++++++++++++++..............
*+++....++++................
*..........  ...........
*
*..........  ...........
*+++....++++................
*++++++++++++++..............
*++++++++++++++++............ ...
*++++++++++++++++++.................
**+++++++++++++++++++................
**+++++++++++++++++++++..............
***++++++++++++++++++++++............
***++++++++++++++++++++++++.........     ......    ...........
****++++++++++++++++++++++++++......   .........................
*****++++++++++++++++++++++++++++...............................
*****++++++++++++++++++++++++++++++++............................
******+++++++++++++++++++++++++++++++++++...........................
*******+++++++++++++++++++++++++++++++++++++++.......................
********+++++++++++++++++++++++++++++++++++++++++++..................
Evaluated to 0.000000
ready&amp;gt; mandel(-0.9, -1.4, 0.02, 0.03);
*******************************************************************************
*******************************************************************************
*******************************************************************************
**********+++++++++++++++++++++************************************************
*+++++++++++++++++++++++++++++++++++++++***************************************
+++++++++++++++++++++++++++++++++++++++++++++**********************************
++++++++++++++++++++++++++++++++++++++++++++++++++*****************************
++++++++++++++++++++++++++++++++++++++++++++++++++++++*************************
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++**********************
+++++++++++++++++++++++++++++++++.........++++++++++++++++++*******************
+++++++++++++++++++++++++++++++....   ......+++++++++++++++++++****************
+++++++++++++++++++++++++++++.......  ........+++++++++++++++++++**************
++++++++++++++++++++++++++++........   ........++++++++++++++++++++************
+++++++++++++++++++++++++++.........     ..  ...+++++++++++++++++++++**********
++++++++++++++++++++++++++...........        ....++++++++++++++++++++++********
++++++++++++++++++++++++.............       .......++++++++++++++++++++++******
+++++++++++++++++++++++.............        ........+++++++++++++++++++++++****
++++++++++++++++++++++...........           ..........++++++++++++++++++++++***
++++++++++++++++++++...........                .........++++++++++++++++++++++*
++++++++++++++++++............                  ...........++++++++++++++++++++
++++++++++++++++...............                 .............++++++++++++++++++
++++++++++++++.................                 ...............++++++++++++++++
++++++++++++..................                  .................++++++++++++++
+++++++++..................                      .................+++++++++++++
++++++........        .                               .........  ..++++++++++++
++............                                         ......    ....++++++++++
..............                                                    ...++++++++++
..............                                                    ....+++++++++
..............                                                    .....++++++++
.............                                                    ......++++++++
...........                                                     .......++++++++
.........                                                       ........+++++++
.........                                                       ........+++++++
.........                                                           ....+++++++
........                                                             ...+++++++
.......                                                              ...+++++++
                                                                    ....+++++++
                                                                   .....+++++++
                                                                    ....+++++++
                                                                    ....+++++++
                                                                    ....+++++++
Evaluated to 0.000000
ready&amp;gt; ^D

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在此刻，你可能开始意识到 Kaleidoscope 是一个真实的并且强大的语言。It may not be self-similar：），但是它可以被用来绘制那些东西！&lt;/p&gt;

&lt;p&gt;我们现在总结本章。我们已经成功的扩展了我们的语言，在库中增加了扩展语言的能力，并且我们已经展示了如何在Kaleidoscope中构建一个简单有趣的应用。在此刻，Kaleidoscope 可以构建各种功能性的应用并且能够调用具有副作用的函数，但是它实际上无法定义并改变变量。&lt;/p&gt;

&lt;p&gt;引人注目的是，&lt;strong&gt;可变变量&lt;/strong&gt;在许多语言中是一个重要的特性，在你的前端中没有SSA构造语法时，想要实现对可变变量的支持是不容易的。在下一章节，我们将会描述如何在你的前端，在不构建SSA的情况下添加&lt;strong&gt;对可变变量的支持&lt;/strong&gt;。&lt;/p&gt;

&lt;h1 id=&#34;6-6-full-code-listing&#34;&gt;6.6 Full Code Listing&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl06.html#full-code-listing&#34;&gt;http://llvm.org/docs/tutorial/LangImpl06.html#full-code-listing&lt;/a&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>信号与系统-学习笔记</title>
      <link>https://l0phtg.github.io/post/class/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 11 Jun 2019 16:32:00 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/class/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      
        <description>&lt;p&gt;昨天刚回家，停更了两天，今天继续更博客。&lt;strong&gt;先简单水一篇&amp;lt;&amp;lt;信号与系统&amp;gt;&amp;gt;的学习记录&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&amp;lt;&amp;lt;信号与系统&amp;gt;&amp;gt;是我大学期间唯一一门挂了三年的课程，所以我对它的印象不可谓不深刻。&lt;/p&gt;

&lt;p&gt;为了过补考，在上个寒假时又重新学了一遍课程，并做了很多笔记，&lt;strong&gt;本文发一下我当前的笔记目录，并附上笔记pdf的github地址&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;笔记地址: &lt;a href=&#34;https://github.com/L0phTg/ClassNote&#34;&gt;https://github.com/L0phTg/ClassNote&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本文不断更新中&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;目录&#34;&gt;目录&lt;/h1&gt;

&lt;p&gt;信号与系统    3&lt;/p&gt;

&lt;p&gt;第一章、连续信号分析   4&lt;/p&gt;

&lt;p&gt;1.1、冲激函数     5&lt;/p&gt;

&lt;p&gt;1.1.1、正交函数   5&lt;/p&gt;

&lt;p&gt;1.1.2、冲激信号的定义    6&lt;/p&gt;

&lt;p&gt;1.1.3、冲激函数的性质    8&lt;/p&gt;

&lt;p&gt;1.2 系统  11&lt;/p&gt;

&lt;p&gt;1.2.1、系统的定义  11&lt;/p&gt;

&lt;p&gt;1.2.2、系统的分类  11&lt;/p&gt;

&lt;p&gt;1.2.3、系统的表示  12&lt;/p&gt;

&lt;p&gt;1.2.4、系统的性质  14&lt;/p&gt;

&lt;p&gt;1.3、连续信号的表示&lt;/p&gt;

&lt;p&gt;1.3.2、信号的能量量和功率&lt;/p&gt;

&lt;p&gt;1.4、连续信号的卷积 18&lt;/p&gt;

&lt;p&gt;1.4.1、连续信号卷积的定义  18&lt;/p&gt;

&lt;p&gt;1.4.2、连续信号卷积的性质  19&lt;/p&gt;

&lt;p&gt;1.5、连续信号在系统中的响应 23&lt;/p&gt;

&lt;p&gt;1.5.1、冲激响应和阶跃响应  23&lt;/p&gt;

&lt;p&gt;1.5.2、自自由响应和强迫响应     24&lt;/p&gt;

&lt;p&gt;1.5.3、全响应    24&lt;/p&gt;

&lt;p&gt;1.6、连续信号的频域分析    25&lt;/p&gt;

&lt;p&gt;1.6.1、傅立立叶级数的导出  25&lt;/p&gt;

&lt;p&gt;1.6.2、傅立立叶分析的导出  29&lt;/p&gt;

&lt;p&gt;1.6.3、傅立立叶变换定义   30&lt;/p&gt;

&lt;p&gt;1.6.4、常⻅见信号的傅立立叶变换   33&lt;/p&gt;

&lt;p&gt;1.6.5、周期信号的傅立立叶变换    39&lt;/p&gt;

&lt;p&gt;1.6.6、傅立立叶变换的性质  40&lt;/p&gt;

&lt;p&gt;1.6.7、信号的取样  47&lt;/p&gt;

&lt;p&gt;1.6.8、对连续信号进行行行频域分析&lt;/p&gt;

&lt;p&gt;1.7、连续信号的复频域分析  52&lt;/p&gt;

&lt;p&gt;1.7.1、拉普拉斯变换     52&lt;/p&gt;

&lt;p&gt;1.7.2、单边拉普拉斯变换   55&lt;/p&gt;

&lt;p&gt;1.7.3、常⻅见信号的单边拉式变换   56&lt;/p&gt;

&lt;p&gt;1.7.4、拉普拉斯变换性质   59&lt;/p&gt;

&lt;p&gt;第二章、离散信号分析   65&lt;/p&gt;

&lt;p&gt;2.1 单位序列列和单位阶跃响应     66&lt;/p&gt;

&lt;p&gt;2.2 离散信号的卷积  67&lt;/p&gt;

&lt;p&gt;2.2.1 卷积和    67&lt;/p&gt;

&lt;p&gt;2.2.2 卷积和的性质     68&lt;/p&gt;

&lt;p&gt;2.3 序列列的傅立立叶分析&lt;/p&gt;

&lt;p&gt;2.3.1 周期序列列的离散傅立立叶级数(DFS)    69&lt;/p&gt;

&lt;p&gt;2.3.2 非非周期序列列的离散时间傅立立叶变换(DTFT)   71&lt;/p&gt;

&lt;p&gt;2.4 离散傅立立叶变换及其性质    73&lt;/p&gt;

&lt;p&gt;2.4.1 离散傅立立叶变换 (DFT) 处理理有限⻓长序列列  73&lt;/p&gt;

&lt;p&gt;2.4.2 离散傅立立叶变换的性质    74&lt;/p&gt;

&lt;p&gt;2.5 Z 变换&lt;/p&gt;

&lt;p&gt;2.5.1 Z 变换的产生生   80&lt;/p&gt;

&lt;p&gt;2.5.2 Z 变换的定义    83&lt;/p&gt;

&lt;p&gt;2.5.3 收敛域    84&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>C&#43;&#43;：设计一个抽象数据类型</title>
      <link>https://l0phtg.github.io/post/c&#43;&#43;/c&#43;&#43;%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sat, 08 Jun 2019 22:22:06 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/c&#43;&#43;/c&#43;&#43;%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      
        <description>&lt;p&gt;初次接触c++是在15年，还蛮早的，但之后的学习中由于使用c++的地方比较少，所以没怎么使用c++开发过项目。然而随着最近学习Art和LLVM的时候，用到了很多c++知识，逐渐发现了自己基础知识的薄弱。遂决定写一个c++系列的语法和编程入门总结。（主要参考 c++ primer 和 effective c++, effective系列没有涉及细节，详细内容可以看书来获得）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本文不断更新中。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;设计class犹如设计type。&lt;em&gt;&amp;mdash;- effective c++ 19&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;定义&#34;&gt;定义&lt;/h1&gt;

&lt;h2 id=&#34;struct&#34;&gt;struct&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct Screen{
    
    
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;class&#34;&gt;class&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Screen{
    
    
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;struct和class的区别&#34;&gt;struct和class的区别&lt;/h2&gt;

&lt;p&gt;struct: 第一个访问控制说明符之前的成员全部是public的。&lt;/p&gt;

&lt;p&gt;class: 第一个访问控制说明符之前的成员全部是private的。&lt;/p&gt;

&lt;h1 id=&#34;组成&#34;&gt;组成&lt;/h1&gt;

&lt;p&gt;当定义一个类时，如果自己没有申明拷贝构造函数，拷贝赋值运算符和析构函数，编译器会为我们默认生成。如果没有构造函数，编译器也会为我们合成默认构造函数。&amp;mdash;- &lt;em&gt;effective c++ 05&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;我们可以通过=default来表明根据编译器默认合成。&lt;/p&gt;

&lt;p&gt;同样地，如果不使用编译器自动生成的拷贝构造函数和拷贝赋值运算符，应该明确拒绝。 &amp;mdash;- &lt;em&gt;effective c++ 06&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;我们可以通过在函数第一次声明时添加=delete来阻止编译器合成拷贝构造函数和拷贝赋值运算符。&lt;/p&gt;

&lt;h2 id=&#34;类型成员&#34;&gt;类型成员&lt;/h2&gt;

&lt;p&gt;我们可以定义一个类型成员，有两种方式来定义：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;typedef;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;   class Screen {
   public:
   	typedef std::string::size_type pos;
   private:
   	pos cursor = 0;
   	pos height = 0, width = 0;
   };
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;using;类型别名&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;   class Screen {
   public:
   	using pos = std::string::size_type;
   }; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: &lt;strong&gt;类型成员定义在类开始的地方，因为之后的成员函数或成员变量会使用到&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&#34;数据成员&#34;&gt;数据成员&lt;/h2&gt;

&lt;p&gt;成员变量应该被声明是private的。&lt;em&gt;&amp;mdash;- effective c++ 22&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;可变变量-mutable&#34;&gt;可变变量（mutable)&lt;/h3&gt;

&lt;p&gt;如果我们希望修改类的某个类型成员，即使在const成员函数内。可以通过在变量的申明中加入 &lt;strong&gt;mutable&lt;/strong&gt; 关键字。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一个可变数据成员永远不会是const的，即使它是const对象的成员&lt;/strong&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Screen {
public:
    void some_member() const;
private:
	mutable size_t access_str;
};

void  Screen::some_member() const 
{
	++access_ctr;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;静态变量-static&#34;&gt;静态变量（static）&lt;/h3&gt;

&lt;p&gt;我们可以在成员的申明之前添加关键字“static”使得其与类关联在一起。&lt;/p&gt;

&lt;p&gt;类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。&lt;/p&gt;

&lt;h2 id=&#34;构造函数和析构函数&#34;&gt;构造函数和析构函数&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;构造函数定义&lt;/strong&gt;：类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做&lt;strong&gt;构造函数&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;构造函数的组成&lt;/strong&gt;：没有返回值、构造函数名字与类名相同、包含参数列表和函数体。（多个构造函数的参数数量或参数类型上必须有所区别）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一些限制&lt;/strong&gt;：构造函数不能被申明为const的。（因为常量属性是在对象初始化之后才有的）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;析构函数定义&lt;/strong&gt;：析构函数执行与构造函数相反的操作：构造函数初始化对象的非static数据成员，还可能做一些其他操作；析构函数释放对象的资源，并销毁对象的非static数据成员。&lt;/p&gt;

&lt;p&gt;注意：由于析构函数不能接受参数，因此它不能被重载。对于一个给定类，只会有一个析构函数。&lt;/p&gt;

&lt;p&gt;隐式销毁一个内置指针类型的成员不会delete它所指向的对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;什么时候执行析构函数&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;变量在离开其作用域时被销毁。&lt;/li&gt;
&lt;li&gt;当一个对象被销毁时，其成员被销毁。&lt;/li&gt;
&lt;li&gt;容器（无论是标准库容器还是数组）被销毁时，其元素被销毁。&lt;/li&gt;
&lt;li&gt;对于动态分配的对象，当对指向它的指针应用delete运算符被销毁时。&lt;/li&gt;
&lt;li&gt;对于临时对象，当创建它的完整表达式结束时被销毁。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意：绝对不要再构造和析构过程中调用virtual函数。&lt;em&gt;&amp;mdash;- effective c++ 09&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;构造函数分类&#34;&gt;构造函数分类&lt;/h3&gt;

&lt;h4 id=&#34;默认构造函数&#34;&gt;默认构造函数&lt;/h4&gt;

&lt;p&gt;在用户&lt;strong&gt;未定义任何构造函数&lt;/strong&gt;时，编译器会&lt;strong&gt;合成&lt;/strong&gt;默认构造函数。&lt;/p&gt;

&lt;p&gt;当然也可以明确申明使用编译器合成的默认构造函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Sales_data() = default;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们不使用默认构造函数的话，要明确指定删除：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Sales_data() = delete;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果类包含有内置类型或者复合类型的成员，则只有当这些成员全部都被赋予了类内初始值时，这个类才适合于使用合成的默认构造函数。&lt;/p&gt;

&lt;h4 id=&#34;拷贝构造函数&#34;&gt;拷贝构造函数&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：如果一个构造函数的第一个参数是自身类型的引用，且任何额外参数都有默认值，则此构造函数是&lt;strong&gt;拷贝构造函数&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个，与合成默认构造函数不同，&lt;strong&gt;即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数&lt;/strong&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Sales_data(const Sales_data&amp;amp;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;发生的时机&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将一个对象作为实参传递给一个非引用类型的形参；&lt;/li&gt;
&lt;li&gt;从一个返回类型为非引用类型的函数返回一个对象；&lt;/li&gt;
&lt;li&gt;用花括号列表初始化一个数组中的元素或一个聚合类中的成员；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;拷贝语义&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;类的行为像一个值；（如标准库容器和string类的行为）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;即它应该有自己的状态。当我们拷贝一个像值的对象时，副本和原对象是完全独立的。改变副本不会对原对象有任何影响，反之亦然。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;类的行为像一个指针；（如shared_ptr类提供类似指针的行为）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;行为像指针的类则共享状态。当我们拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;类的行为既不像值也不像指针；（如 IO 类型 和 unique_ptr 不允许拷贝和赋值。）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;实现&lt;/strong&gt;: 如果我们要实现自己的拷贝构造函数，注意要拷贝它的每一个成员。（如果我们添加了类成员，相应地，我们也要改变拷贝构造函数）。&lt;em&gt;&amp;mdash;- effective c++ 12&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实现派生类的拷贝构造函数&lt;/strong&gt;: 我们不仅要赋值派生类的成员，还要复制基类的成员（可以通过调用基类的拷贝构造函数来完成）。&amp;mdash;- effective c++ 12&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;PriorityCustomer::PriorityCustomer(const PriorityCustomer&amp;amp; rhs)
	: Customer(rhs), 				// 调用基类的拷贝构造函数
	  priority(rhs.priority)
{
	LogCall(&amp;quot;PriorityCustomer copy constructor&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;移动构造函数&#34;&gt;移动构造函数&lt;/h4&gt;

&lt;p&gt;在某些情况下，对象拷贝后就立即被销毁了。这这些情况下，移动而非拷贝对象会大幅度提升性能。&lt;/p&gt;

&lt;p&gt;为了让我们的类型支持移动操作，需要为其定义移动构造函数和移动赋值运算符。这两个成员类似对应的拷贝操作，但它们从给定对象“窃取”资源而不是拷贝资源。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;移动构造函数&lt;/strong&gt;： 第一个参数是该类类型的一个右值引用。任何额外的参数都必须有默认实参。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：移动构造函数必须确保移后源对象处于这样一个状态&amp;mdash;-销毁它是无害的。特别是，一旦资源完成移动，源对象必须不再指向被移动的资源&amp;mdash;-这些资源的所有权已经归属新创建的对象。&lt;/p&gt;

&lt;p&gt;移动构造函数不应该抛出异常，且不分配任何新内存。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;StrVec::StrVec(StrVec &amp;amp;&amp;amp;s) noexcept
	: elements(s.elements), first_free(s.first_free), cap(s.cap)
{
	s.elements = s.first_free = s.cap = nullptr;        
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;委托构造函数&#34;&gt;委托构造函数&lt;/h4&gt;

&lt;p&gt;很好理解，就是一个委托构造函数使用&lt;strong&gt;它所属类的其他构造函数&lt;/strong&gt;执行它自己的初始化过程。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Sales_data {
public:
	Sales_data(std::string s, unsigned cnt, double price) :
			bookNo(s), units_sold(cnt), revenue(cnt*price) {}
	Sales_data() : Sales_data(&amp;quot;&amp;quot;, 0, 0) {}
private:
	...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;构造函数组成&#34;&gt;构造函数组成&lt;/h3&gt;

&lt;h4 id=&#34;explicit属性&#34;&gt;explicit属性&lt;/h4&gt;

&lt;p&gt;在要求隐式转换的程序上下文中，我们可以通过将构造函数申明为 &lt;strong&gt;explict&lt;/strong&gt; 加以阻止。&lt;/p&gt;

&lt;p&gt;explicit构造函数只能用于直接初始化。&lt;/p&gt;

&lt;h4 id=&#34;构造函数初始值列表&#34;&gt;构造函数初始值列表&lt;/h4&gt;

&lt;p&gt;就对象的数据成员而言，初始化和赋值也有类似的区别。如果没有在构造函数的初始值列表中显式地初始化成员，则该成员将在构造函数体之前执行默认初始化。&lt;/p&gt;

&lt;p&gt;如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值。&lt;/p&gt;

&lt;p&gt;最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且如果可能的话，尽量避免使用某些成员初始化其他成员。&lt;/p&gt;

&lt;h3 id=&#34;虚析构函数&#34;&gt;虚析构函数&lt;/h3&gt;

&lt;p&gt;析构函数添加了virtual属性。所有的基类的析构函数都应该为虚析构函数。&amp;mdash;- &lt;em&gt;effective c++ 07&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;析构函数决定不应该吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下他们（不传播）或结束程序。&lt;em&gt;&amp;mdash;- effective c++ 08&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;成员函数&#34;&gt;成员函数&lt;/h2&gt;

&lt;p&gt;公有的成员函数即是&lt;strong&gt;接口&lt;/strong&gt;。好的接口设计应该很容易被正确使用，不容易被误用。&lt;em&gt;&amp;mdash;- effective c++ 18&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;宁可拿 non-member non-friend 函数替换 member 函数，这样做可以增加封装性、包裹弹性（packaging flexibility）和机能扩充性。&lt;em&gt;&amp;mdash;- effective c++ 23&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;virtual属性&#34;&gt;virtual属性&lt;/h3&gt;

&lt;p&gt;一个某个函数被声明为virtual属性，那么在所有派生类中它都是虚函数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;: 实现c++中的多态性，提高代码复用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;多态&lt;/strong&gt;: 即多种形式。我们把具有继承关系的多个类型称为多态类型，因为我们能使用这些类型的“多种形式”而无须在意它们的差异。&lt;strong&gt;引用或指针的静态类型与动态类型不同这一事实正是C++语言支持多态性的根本所在&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;虚函数调用和非虚函数调用的区别&lt;/strong&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对&lt;strong&gt;非虚函数&lt;/strong&gt;的调用在编译时进行绑定。类似的，通过&lt;strong&gt;对象&lt;/strong&gt;进行的函数（虚函数或非虚函数）调用也在编译时绑定。（对象的类型是确定不变的，我们无论如何都不可能令对象的动态类型与静态类型不一致）&lt;/li&gt;
&lt;li&gt;当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;inline属性&#34;&gt;inline属性&lt;/h3&gt;

&lt;p&gt;声明inline函数的两种方式：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;函数的返回类型前面添加关键字&lt;strong&gt;inline&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;类内定义的函数默认都是&lt;strong&gt;inline&lt;/strong&gt;函数；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意：内联说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。&lt;/p&gt;

&lt;h3 id=&#34;static成员函数&#34;&gt;static成员函数&lt;/h3&gt;

&lt;p&gt;与静态数据成员类似，静态成员函数也不与任何对象绑定在一起，它们&lt;strong&gt;不包含 this 指针&lt;/strong&gt;，作为结果，静态成员函数不能申明为const的，而且我们也不能在static函数中使用this指针。&lt;/p&gt;

&lt;h3 id=&#34;const成员函数&#34;&gt;const成员函数&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;形式&lt;/strong&gt;：在成员函数的参数列表后紧跟const关键字。这里，const的作用是修改隐式this指针的类型。&lt;/p&gt;

&lt;p&gt;默认情况下，this的类型是指向类类型非常量版本的常量指针。&lt;/p&gt;

&lt;p&gt;一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用。&lt;/p&gt;

&lt;h3 id=&#34;组成-1&#34;&gt;组成&lt;/h3&gt;

&lt;p&gt;返回类型、函数名称、参数、函数体。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;返回类型的设计&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;必须返回对象时，别妄想返回其reference。&lt;em&gt;&amp;mdash;- effective c++ 21&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;避免返回handles指向对象内部成分。&lt;em&gt;&amp;mdash;- effective c++ 28&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;参数的设计&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;​   1. 默认情况下 c++ 以 by value 方式传递对象至函数。尽量以 pass-by-reference-to-const 替换 pass-by-value。前者通常比较高效，并可避免切割问题。（当然，以上规则不适用于内置类型，以及STL的迭代器和函数对象。对它们而言，pass-by-value往往比较适当）&lt;em&gt;&amp;mdash;- effective c++ 20&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;若所有的参数都需要类型转换，请为此采用 non-member 函数。&lt;em&gt;&amp;mdash;- effective c++ 24&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;函数体的设计&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;只要定义了一个变量而其类型带有一个构造函数或析构函数，那么当程序的控制流到达这个变量定义式时，你便得承受构造成本；当这个变量离开其作用域时，你便得承受析构成本。所以，&lt;strong&gt;尽可能延后变量定义式的出现时间&lt;/strong&gt;。&lt;em&gt;&amp;mdash;- effective c++ 26&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;尽量少做转型动作。&lt;em&gt;&amp;mdash;- effective c++ 27&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;友元&#34;&gt;友元&lt;/h2&gt;

&lt;p&gt;类可以允许其它类访问它的&lt;strong&gt;非公有成员&lt;/strong&gt;，方法是令其它类或函数称为它的友元。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Sales_data {
friend: Sales_data add(const Sales_data&amp;amp;, const Sales_data&amp;amp;);
public:
	...
private:
	...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：友元的声明仅仅指定了访问的权限，函数的声明需要在类外声明。&lt;/p&gt;

&lt;p&gt;如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;extern std::ostream&amp;amp; storeOn(std::ostream &amp;amp;, Screen &amp;amp;);
extern BitMap&amp;amp; storeOn(BitMap &amp;amp;, Screen &amp;amp;);
class Screen {
	friend std::ostream&amp;amp; storeOn(std::ostream &amp;amp;, Screen &amp;amp;);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;声明位置&lt;/strong&gt;：一般来说，最好在类的最开始处集中声明友元。&lt;/p&gt;

&lt;h2 id=&#34;运算符&#34;&gt;运算符&lt;/h2&gt;

&lt;h3 id=&#34;拷贝赋值运算符&#34;&gt;拷贝赋值运算符&lt;/h3&gt;

&lt;p&gt;如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个 &lt;strong&gt;合成拷贝赋值运算符&lt;/strong&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Sales_data&amp;amp;
Sales_data::operator=(const Sales_data &amp;amp;rhs)
{
...
    return *this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一定要返回reference to *this。并且要正确处理自赋值。&lt;em&gt;&amp;mdash;- effective c++ 10 11&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;移动赋值运算符&#34;&gt;移动赋值运算符&lt;/h3&gt;

&lt;p&gt;移动赋值运算符执行与析构函数和移动构造函数相同的工作。另外，移动赋值运算符必须正确处理自赋值：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;StrVec &amp;amp;StrVec::operator=(StrVec &amp;amp;&amp;amp;rhs) noexcept
{
	if (this != rhs)
    {
    	free(); 		// 释放已有元素   
        elements = rhs.elements;
        first_free = rhs.first_free;
        cap = rhs.cap;
        rhs.elements = rhs.first_free = rhs.cap = nullptr;
    }
    return *this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一定要返回reference to *this。并且要正确处理自赋值。&lt;em&gt;&amp;mdash;- effective c++ 10 11&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;函数调用运算符&#34;&gt;函数调用运算符&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;：如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象。（因为这样的类同时也能存储状态，所以与普通函数相比它们更加灵活）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct absInt {
	int operator()(int val) const {
		return val &amp;lt; 0? -val : val;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。&lt;/p&gt;

&lt;h2 id=&#34;this-指针&#34;&gt;this 指针&lt;/h2&gt;

&lt;p&gt;this总是指向该类实例化出来的对象。另外，this还是一个&lt;strong&gt;常量指针&lt;/strong&gt;，我们&lt;strong&gt;不允许改变this中保存的地址&lt;/strong&gt;。（Type*const this;）&lt;/p&gt;

&lt;p&gt;this作为非静态成员函数的隐式参数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;total.isbn(); 
== 
Sales_data::isbn(&amp;amp;total);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;作用域&#34;&gt;作用域&lt;/h2&gt;

&lt;h1 id=&#34;类的层次结构&#34;&gt;类的层次结构&lt;/h1&gt;

&lt;p&gt;基类和派生类。&lt;/p&gt;

&lt;h1 id=&#34;类的性质&#34;&gt;类的性质&lt;/h1&gt;

&lt;h2 id=&#34;访问控制属性-封装性&#34;&gt;访问控制属性（封装性）&lt;/h2&gt;

&lt;h2 id=&#34;继承属性&#34;&gt;继承属性&lt;/h2&gt;

&lt;h3 id=&#34;基类和派生类&#34;&gt;基类和派生类&lt;/h3&gt;

&lt;p&gt;通过&lt;strong&gt;继承&lt;/strong&gt;（inheritance)联系在一起的类构成一种层次关系。通常在层次关系的根部有一个&lt;strong&gt;基类&lt;/strong&gt;（base class），其他类则直接或间接地从基类继承而来，这些继承得到的类称为&lt;strong&gt;派生类&lt;/strong&gt;（derived class）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;动态绑定&lt;/strong&gt;: 在 C++ 语言中，当我们使用&lt;strong&gt;基类的引用（或指针）调用一个虚函数&lt;/strong&gt;时将发生动态绑定。&lt;/p&gt;

&lt;h4 id=&#34;基类&#34;&gt;基类&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;虚函数&lt;/strong&gt;: 所有的子类要覆盖的函数（子类有特定行为）都申明为virtual函数。&amp;mdash;- &lt;em&gt;effective c++&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;基类通常都应该定义一个&lt;strong&gt;虚析构函数&lt;/strong&gt;，即使该函数不执行任何实际操作也是如此。&lt;/p&gt;

&lt;h4 id=&#34;派生类&#34;&gt;派生类&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：派生类必须通过使用&lt;strong&gt;派生类列表&lt;/strong&gt;明确指出它是从哪个（或哪些）基类继承而来的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;派生类列表的形式&lt;/strong&gt;: 首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种&lt;strong&gt;访问说明符&lt;/strong&gt;中的一个：public、protected和private。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;派生类中的虚函数&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;派生类可以在它覆盖的函数前使用virtual关键字。也可以在形参列表后面添加override关键字来表明覆盖了基类的虚函数。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;派生类对象及派生类向基类的类型转换&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一个派生类对象包含多个组成部分：一个含有派生类自己定义的（非静态）成员的子对象，以及一个与该派生类继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;派生类到基类的类型转换&lt;/strong&gt;: 因为在派生类对象中含有与基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分上。&lt;/p&gt;

&lt;h3 id=&#34;单继承&#34;&gt;单继承&lt;/h3&gt;

&lt;h4 id=&#34;公有继承-is-a关系&#34;&gt;公有继承（is-a关系）&lt;/h4&gt;

&lt;p&gt;public inheritance意味着 is-a 的关系。&lt;/p&gt;

&lt;p&gt;即：如果class D(&amp;ldquo;Derived&amp;rdquo;) 以 public形式继承 class B(&amp;ldquo;Base&amp;rdquo;)，便意味着每一个类型为D的对象同时也是一个类型为B的对象。使用于 base classes 身上的每一件事一定也适用于derived classes身上，因为每一个derived class对象也都是一个base class对象。&lt;em&gt;&amp;mdash;- effective c++ 32&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;继承时，应该避免遮掩继承而来的名称，在public继承下从来没有人希望如此。&lt;em&gt;&amp;mdash;- effective c++ 33&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;关于接口和实现的继承详解：&lt;em&gt;&amp;mdash;- effective c++ 34&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;pure virtual函数只具体指定接口继承。&lt;/li&gt;
&lt;li&gt;impure virtual函数具体指定接口继承及其默认实现继承。&lt;/li&gt;
&lt;li&gt;no virtual函数具体指定接口继承以及强制性实现继承。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;绝不重新定义继承而来的默认参数值。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因为虚函数动态绑定，而默认参数值是静态绑定的。 &lt;em&gt;&amp;mdash;- effective c++ 37&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;私有继承&#34;&gt;私有继承&lt;/h4&gt;

&lt;h3 id=&#34;多重继承&#34;&gt;多重继承&lt;/h3&gt;

&lt;h2 id=&#34;多态属性&#34;&gt;多态属性&lt;/h2&gt;

&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;</description>
      
    </item>
    
    <item>
      <title>习字：入门</title>
      <link>https://l0phtg.github.io/post/handwriting/%E4%B9%A0%E5%AD%97%E5%85%A5%E9%97%A8/</link>
      <pubDate>Fri, 07 Jun 2019 18:39:03 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/handwriting/%E4%B9%A0%E5%AD%97%E5%85%A5%E9%97%A8/</guid>
      
        <description>&lt;p&gt;&lt;strong&gt;本篇是水文!!!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从小我爸就一直说我字写得不好，就这么说了二十多年，现在依然写的一般。不过经过断断续续的练字，也有了一丁点的进步。最近学校的事基本忙完了，准备每天抽出一些时间来继续练字。&lt;/p&gt;

&lt;p&gt;今天看了几节田舍之老师在&lt;strong&gt;网易云课堂&lt;/strong&gt;的&amp;lt;&amp;lt;硬笔书法系列&amp;gt;&amp;gt;教程，发现了自己练字期间一直存在的问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从单字来说，有些写的比较杂乱无序。这个问题在单个字时不容易暴露出来，但是从全文来看，就会很明显发现不整齐。&lt;/li&gt;
&lt;li&gt;我硬笔字写的速度一直很慢，原因是过度注重“&lt;strong&gt;提按顿挫&lt;/strong&gt;”。&lt;strong&gt;提按顿挫&lt;/strong&gt;在写毛笔时比较容易实现，因为笔头是软的，但是写硬笔字时，虽然这样写出来比较好看，但日常应用中写起来速度很慢，没有实用性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;插一句，近两个月积攒了十几篇文章。今天起，定期更新。&lt;/strong&gt;
&lt;/p&gt;

&lt;h1 id=&#34;握笔姿势&#34;&gt;握笔姿势&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;笔杆靠在食指指根上。目的是因为我们书写的动作是要靠食指来完成的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/docs-pic/handwriting/posture.jpg&#34; alt=&#34;posture&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;两个支点。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/docs-pic/handwriting/pivotPoint.jpg&#34; alt=&#34;pivotPoint&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;横与竖&#34;&gt;横与竖&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;横摆手。&lt;/li&gt;
&lt;li&gt;竖点头。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;单字与篇章&#34;&gt;单字与篇章&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;每个字上下要齐，全部字都在一个圆内；（字写的一般，理解就行）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/docs-pic/handwriting/upDown.jpg&#34; alt=&#34;upDown&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;开合。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/docs-pic/handwriting/openMerge.jpg&#34; alt=&#34;open&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;每个字都应该横平竖直，不能杂乱无序。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;单字与日常应用&#34;&gt;单字与日常应用&lt;/h1&gt;

&lt;p&gt;硬笔注重实用性，不要过度关注&lt;strong&gt;提按顿挫&lt;/strong&gt;。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Kaleidoscope: 前五章总结</title>
      <link>https://l0phtg.github.io/post/llvm/kaleidoscope-%E5%89%8D%E4%BA%94%E7%AB%A0%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 15 Apr 2019 17:58:13 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/llvm/kaleidoscope-%E5%89%8D%E4%BA%94%E7%AB%A0%E6%80%BB%E7%BB%93/</guid>
      
        <description>&lt;p&gt;对前五章做了一个总结, 侧重Codegen部分.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;kaleidoscope支持的语法&#34;&gt;Kaleidoscope支持的语法&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;表达式运算&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;4+5;
5-1;
5*10;
10/5;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;函数定义&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;def bar(a) foo(a, 4.0) + bar(31337);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;函数调用&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;cos(1.234);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;if/then/else&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;extern foo();
extern bar();
def baz(x) if x then foo() else bar();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;for&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;extern putchard(char);
def printstar(n)
  for i = 1, i &amp;lt; n, 1.0 in
    putchard(42);  # ascii 42 = &#39;*&#39;

# print 100 &#39;*&#39; characters
printstar(100);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;词法分析&#34;&gt;词法分析&lt;/h1&gt;

&lt;p&gt;词法分析很简单. 我这里简单画了下处理的流程图.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/docs-pic/llvm/Lexer And Parser.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;具体的分析请看: &lt;a href=&#34;https://l0phtg.github.io/post/kaleidoscope-tutorial-introduction-and-lexer/&#34;&gt;Lexer and Parse&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;抽象语法树&#34;&gt;抽象语法树&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/docs-pic/llvm/AST.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;生成抽象语法树-ast&#34;&gt;生成抽象语法树(AST)&lt;/h1&gt;

&lt;p&gt;这块比较简单. 简单介绍下:&lt;/p&gt;

&lt;h2 id=&#34;expr的-ast-生成&#34;&gt;Expr的(AST)生成&lt;/h2&gt;

&lt;p&gt;我们对所有的表达式进行集中处理.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// expression
///   ::= primary binoprhs
///
static std::unique_ptr&amp;lt;ExprAST&amp;gt; ParseExpression() {
  auto LHS = ParsePrimary();
  if (!LHS)
    return nullptr;

  return ParseBinOpRHS(0, std::move(LHS));
}

static std::unique_ptr&amp;lt;ExprAST&amp;gt; ParsePrimary() {
  switch (CurTok) {
  default:
    return LogError(&amp;quot;unknown token when expecting an expression&amp;quot;);
  case tok_identifier:
    return ParseIdentifierExpr();
  case tok_number:
    return ParseNumberExpr();
  case &#39;(&#39;:
    return ParseParenExpr();
  case tok_if:
    return ParseIfExpr();
  case tok_for:
    return ParseForExpr();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ParseIdentifierExpr&lt;/code&gt;,&lt;code&gt;ParseNumberExpr&lt;/code&gt;和&lt;code&gt;ParseParenExpr&lt;/code&gt;的实现请参考: &lt;a href=&#34;https://l0phtg.github.io/post/llvm/kaleidoscope-implementing-a-parser-and-ast/&#34;&gt; Implementing a Parser and AST&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ParseIfExpr&lt;/code&gt;和&lt;code&gt;ParseForExpr&lt;/code&gt;的实现请参考: &lt;a href=&#34;https://l0phtg.github.io/post/llvm/kaleidoscope-extending-the-language-control-flow/&#34;&gt;Extending the Language Control Flow&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;函数定义和申明的ast生成&#34;&gt;函数定义和申明的AST生成&lt;/h2&gt;

&lt;p&gt;请参考:&lt;a href=&#34;https://l0phtg.github.io/post/llvm/kaleidoscope-implementing-a-parser-and-ast/&#34;&gt; Implementing a Parser and AST&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;codegen-产生llvm-ir&#34;&gt;Codegen(产生LLVM IR)&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/docs-pic/llvm/Codegen.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;四个基本表达式的codegen&#34;&gt;四个基本表达式的codegen&lt;/h2&gt;

&lt;p&gt;请参考: &lt;a href=&#34;https://l0phtg.github.io/post/llvm/kaleidoscope-code-generation-to-llvm-ir/&#34;&gt;code generation to llvm ir&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;if-then-else&#34;&gt;if/then/else&lt;/h2&gt;

&lt;h3 id=&#34;kaleidoscpe-if-then-else&#34;&gt;Kaleidoscpe: if/then/else&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;extern foo();
extern bar();
def baz(x) if x then foo() else bar();  // 如果 x != 0, then foo, else bar;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;未经优化的llvm-ir&#34;&gt;未经优化的LLVM IR&lt;/h3&gt;

&lt;p&gt;根据我们上面编写的Kaleidoscope的代码, 可以生成下面的LLVM IR.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;declare double @foo()

declare double @bar()

define double @baz(double %x) {
entry:
  %ifcond = fcmp one double %x, 0.000000e+00
  br i1 %ifcond, label %then, label %else

then:       ; preds = %entry
  %calltmp = call double @foo()
  br label %ifcont

else:       ; preds = %entry
  %calltmp1 = call double @bar()
  br label %ifcont

ifcont:     ; preds = %else, %then
  %iftmp = phi double [ %calltmp, %then ], [ %calltmp1, %else ] ; 返回值
  ret double %iftmp
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;ir解析&#34;&gt;IR解析&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;IR指令&lt;/th&gt;
&lt;th&gt;例子&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$\bold{fcmp}$&lt;/td&gt;
&lt;td&gt;$\color{red}{fcmp}$ $one$ $double$ ${x}$,   $0.0e+00$&lt;/td&gt;
&lt;td&gt;比较指令, 相等则返回 0, 不相等返回 1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{call}$&lt;/td&gt;
&lt;td&gt;$\color{red}{call}$    $double$ $@ foo()$&lt;/td&gt;
&lt;td&gt;调用函数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{br}$&lt;/td&gt;
&lt;td&gt;$\color{red}{br}$       ${label }$  ${\%ifcont}$&lt;/td&gt;
&lt;td&gt;直接跳转&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{br}$&lt;/td&gt;
&lt;td&gt;$\color{red}{br}$       $i1$  $\%ifcond$,  $label$  $\%then$,   $label$   $\%else$&lt;/td&gt;
&lt;td&gt;条件跳转&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{phi}$&lt;/td&gt;
&lt;td&gt;$\color{red}{phi}$     ${double [\% calltmp, \%then] }$, ${[\%calltmp1, \%else]}$&lt;/td&gt;
&lt;td&gt;调用${phi}$ 函数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{ret}$&lt;/td&gt;
&lt;td&gt;$\color{red}{ret}$     $double$ $\% 0$&lt;/td&gt;
&lt;td&gt;函数返回&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Label&lt;/th&gt;
&lt;th&gt;means&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$\bold{entry}$&lt;/td&gt;
&lt;td&gt;函数入口&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{then}$&lt;/td&gt;
&lt;td&gt;条件分支then&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{else}$&lt;/td&gt;
&lt;td&gt;条件分支else&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{ifcont}$&lt;/td&gt;
&lt;td&gt;结束条件分支&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;if-then-else-s-cfg&#34;&gt;if/then/else&amp;rsquo;s CFG&lt;/h3&gt;

&lt;p&gt;使用&lt;code&gt;opt -analyze -view-cfg if.bc&lt;/code&gt;生成的CFG.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/docs-pic/llvm/if.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;if-then-else-s-dominator-判断哪里需要插入phi函数&#34;&gt;if/then/else&amp;rsquo;s dominator (判断哪里需要插入phi函数)&lt;/h4&gt;

&lt;p&gt;这里只是对插入$\phi$函数时机的一个分析. (不想了解的壳跳过).&lt;/p&gt;

&lt;p&gt;根据我前面翻译的文章: &lt;a href=&#34;https://l0phtg.github.io/post/dominatorgraph-theory/&#34;&gt;Dominator&lt;/a&gt;来分析我们&lt;code&gt;if/then/else&lt;/code&gt;的控制流.&lt;/p&gt;

&lt;p&gt;我们将:  &lt;code&gt;entry&lt;/code&gt; 视为节点 $\bold{1}$。    &lt;code&gt;then&lt;/code&gt;视为节点 $\bold{2}$。&lt;/p&gt;

&lt;p&gt;​         &lt;code&gt;else&lt;/code&gt; 视为节点 $\bold{3}$。      &lt;code&gt;ifcont&lt;/code&gt;视为节点 $\bold{4}$。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;$\bold{1}$&lt;/th&gt;
&lt;th&gt;$\color{black}{dom}$&lt;/th&gt;
&lt;th&gt;$\color{Gray}{1}$&lt;/th&gt;
&lt;th&gt;$\color{Red}{2}$&lt;/th&gt;
&lt;th&gt;$\color{Red}{3}$&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$\bold{2}$&lt;/td&gt;
&lt;td&gt;$\color{black}{dom}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$\color{Gray}{2}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{3}$&lt;/td&gt;
&lt;td&gt;$\color{black}{dom}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$\color{Gray}{3}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{4}$&lt;/td&gt;
&lt;td&gt;$\color{black}{dom}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$\color{Gray}{4}$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;节点&lt;/th&gt;
&lt;th&gt;支配分析&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$\bold{1}$&lt;/td&gt;
&lt;td&gt;支配: 1, 2, 3, 4.    严格支配: 2, 3, 4.     直接支配: 2, 3.    支配边界: set().&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{2}$&lt;/td&gt;
&lt;td&gt;支配: 2.                 严格支配: 无.           直接支配: 无.       支配边界: set(4).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{3}$&lt;/td&gt;
&lt;td&gt;支配: 3.                 严格支配: 无.           直接支配: 无.       支配边界: set(4).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{4}$&lt;/td&gt;
&lt;td&gt;支配: 4.                 严格支配: 无.           直接支配: 无.       支配边界: set().&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;根据&lt;a href=&#34;https://l0phtg.github.io/post/llvm/static-single-assignment/&#34;&gt;SSA&lt;/a&gt;理论, 我们可以在 $\bold{4}$ 节点处插入 $\bold{\phi}$ 函数.&lt;/p&gt;

&lt;h3 id=&#34;builder创建ir指令&#34;&gt;Builder创建IR指令&lt;/h3&gt;

&lt;p&gt;用Builder来产生每条指令的IR.&lt;/p&gt;

&lt;p&gt;下面是一些&lt;code&gt;if/then/else&lt;/code&gt;会涉及到的&lt;code&gt;Builder创建指令的操作&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&#34;创建cmp指令&#34;&gt;创建cmp指令&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;CondV = Builder.CreateFCmpONE(
      CondV, ConstantFP::get(TheContext, APFloat(0.0)), &amp;quot;ifcond&amp;quot;);

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;创建条件br指令&#34;&gt;创建条件br指令&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Builder.CreateCondBr(CondV, ThenBB, ElseBB);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;创建直接br指令&#34;&gt;创建直接br指令&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Builder.CreateBr(MergeBB);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;创建phi指令&#34;&gt;创建phi指令&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;  PHINode *PN =
    Builder.CreatePHI(Type::getDoubleTy(TheContext), 2, &amp;quot;iftmp&amp;quot;);

  PN-&amp;gt;addIncoming(ThenV, ThenBB);
  PN-&amp;gt;addIncoming(ElseV, ElseBB);
  return PN;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;创建block&#34;&gt;创建Block&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;构造block时直接在&amp;rdquo;TheFunction&amp;rdquo;后面添加该block.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;BasicBlock *ThenBB =
    BasicBlock::Create(TheContext, &amp;quot;then&amp;quot;, TheFunction);
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;单纯创建Block, 当未添加到函数中.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;   BasicBlock *ElseBB = BasicBlock::Create(TheContext, &amp;quot;else&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;irbuilder中插入block&#34;&gt;IRBuilder中插入Block&lt;/h4&gt;

&lt;p&gt;控制流的独特性之处在于,  它有自己的内部的作用域(block). 所以我们在编写codegen代码时, 会调用内部block的codegen. 而不会直接去处理它.(内部block的codegen是它自己处理的, 不归我们的 ifExpr.Codegen管)&lt;/p&gt;

&lt;p&gt;所以我们会这样做:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Builder.SetInsertPoint(ThenBB);          // 将builder此时的插入点设置为ThenBB.
Value *ThenV = Then-&amp;gt;codegen();          // 调用 then block的codegen
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;将未添加的block添加到函数中&#34;&gt;将未添加的Block添加到函数中&lt;/h4&gt;

&lt;p&gt;在&amp;rdquo;TheFunction&amp;rdquo;后面添加&amp;rdquo;merge block&amp;rdquo;, 因为在我们创建时, 只是单纯的创建的block, 还未添加到函数中.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;  TheFunction-&amp;gt;getBasicBlockList().push_back(MergeBB); // TheFunction中添加Block
  Builder.SetInsertPoint(MergeBB); // IRBuilder中插入BB
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;builder流程图&#34;&gt;Builder流程图&lt;/h3&gt;

&lt;p&gt;生成if/then/else 的IR可以分为四个部分生成:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;cond

&lt;ol&gt;
&lt;li&gt;创建cmp IR. 目的是根据条件判断返回bool值.&lt;/li&gt;
&lt;li&gt;创建&lt;strong&gt;条件&lt;/strong&gt;跳转IR. 目的是根据返回的bool值做分支跳转.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;then

&lt;ol&gt;
&lt;li&gt;then.codegen(). 目的是进行then block的codegen.&lt;/li&gt;
&lt;li&gt;创建&lt;strong&gt;直接&lt;/strong&gt;跳转IR.目的是跳转到ifcond处.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;else

&lt;ol&gt;
&lt;li&gt;else.codegen(). 目的是进行else block的codegen.&lt;/li&gt;
&lt;li&gt;创建&lt;strong&gt;直接跳转&lt;/strong&gt;IR,目的是跳转到ifcond处.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;ifcond(分支合并后):

&lt;ol&gt;
&lt;li&gt;创建phi函数调用IR. 目的是判断我们是从哪个分支跳转来的.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;, 这里不会涉及&lt;code&gt;ret&lt;/code&gt;指令的&lt;strong&gt;codegen&lt;/strong&gt; ,我们在&lt;code&gt;ifExprAST&lt;/code&gt;中最后做的仅仅是将$\bold{\phi}$函数的返回值返回.  &lt;code&gt;ret&lt;/code&gt;指令的&lt;strong&gt;codegen&lt;/strong&gt;应该在&lt;code&gt;函数&lt;/code&gt;的&lt;strong&gt;codegen&lt;/strong&gt;时做.&lt;/p&gt;

&lt;p&gt;(在上文例子中, &lt;code&gt;ret&lt;/code&gt;指令的&lt;strong&gt;codegen&lt;/strong&gt; 是&lt;strong&gt;baz&lt;/strong&gt;函数生成的)&lt;/p&gt;

&lt;div class=&#34;mermaid&#34;&gt;
graph TD
    Start(&#34;If Codegen&#34;)
    builderCreateCmp[&#34;Builder.CreateCmpOne&#34;]
    builderCreateCond[&#34;Builder.CreateCondBr&#34;]
    Start --&gt; builderCreateCmp
    builderCreateCmp --&gt; builderCreateCond
    
    subgraph Then
        builderSetInsertThenBB[&#34;Builder.SetInsertPoint(ThenBB);&#34;]
        ThenCodegen[&#34;Then-&gt;codegen();&#34;]
        builderCreateBr1[&#34;Builder.CreateBr&#34;]
        builderSetInsertThenBB --&gt; ThenCodegen
        ThenCodegen --&gt; builderCreateBr1
    end
    
    builderCreateCond --&gt; builderSetInsertThenBB
    
    subgraph Else
        builderSetInsertElseBB[&#34;Builder.SetInsertPoint(ElseBB);&#34;]
        ElseCodegen[&#34;Else-&gt;codegen();&#34;]
        builderCreateBr2[&#34;Builder.CreateBr&#34;]
        builderSetInsertElseBB --&gt; ElseCodegen
        ElseCodegen --&gt; builderCreateBr2
    end
    
    builderCreateBr1 --&gt; builderSetInsertElseBB
    
    subgraph Merge
        builderSetInsertIfcontBB[&#34;Builder.SetInsertPoint(MergeBB);&#34;]
        builderCreatePHI[&#34;Builder.CreatePHI&#34;]
        builderSetInsertIfcontBB --&gt; builderCreatePHI
    end
    
    builderCreateBr2 --&gt; builderSetInsertIfcontBB
    
    builderCreatePHI --&gt; End(&#34;End Codegen&#34;)
    
    style builderSetInsertThenBB fill:#ffcc66
    style builderSetInsertElseBB fill:#ffcc66
    style builderSetInsertIfcontBB fill:#ffcc66
    
    style ThenCodegen fill:#ff66cc
    style ElseCodegen fill:#ff66cc
    
    style Start fill:#ff9966
    style End fill:#ff9966
&lt;/div&gt;

&lt;h2 id=&#34;loop&#34;&gt;Loop&lt;/h2&gt;

&lt;h3 id=&#34;kaleidoscope-for&#34;&gt;Kaleidoscope: for&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;extern putchard(char);
def printstar(n)
  for i = 1, i &amp;lt; n, 1.0 in
    putchard(42);  # ascii 42 = &#39;*&#39;

# print 100 &#39;*&#39; characters
printstar(100);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;未经优化的llvm-ir-1&#34;&gt;未经优化的LLVM IR&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;declare double @putchard(double)

define double @printstar(double %n) {
entry:
  ; initial value = 1.0 (inlined into phi)
  br label %loop

loop:       ; preds = %loop, %entry
  %i = phi double [ 1.000000e+00, %entry ], [ %nextvar, %loop ]
  ; body
  %calltmp = call double @putchard(double 4.200000e+01)
  ; increment
  %nextvar = fadd double %i, 1.000000e+00

  ; termination test
  %cmptmp = fcmp ult double %i, %n
  %booltmp = uitofp i1 %cmptmp to double
  %loopcond = fcmp one double %booltmp, 0.000000e+00
  br i1 %loopcond, label %loop, label %afterloop

afterloop:      ; preds = %loop
  ; loop always returns 0.0
  ret double 0.000000e+00
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有三个&lt;code&gt;Label&lt;/code&gt;, 意味者三个&lt;code&gt;BasicBlock&lt;/code&gt;: &lt;strong&gt;entry&lt;/strong&gt;,  &lt;strong&gt;loop&lt;/strong&gt;,  &lt;strong&gt;afterloop&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;有四个主要的&lt;code&gt;Expression&lt;/code&gt;: &lt;strong&gt;Start&lt;/strong&gt;, &lt;strong&gt;Cond&lt;/strong&gt;, &lt;strong&gt;Body&lt;/strong&gt;, &lt;strong&gt;Increment&lt;/strong&gt; .  当然还有&lt;strong&gt;afterloop&lt;/strong&gt;, 它总是&lt;code&gt;ret 0.0&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;ir解析-1&#34;&gt;IR解析&lt;/h4&gt;

&lt;p&gt;与&lt;code&gt;if/then/else&lt;/code&gt;的&lt;strong&gt;IR&lt;/strong&gt;指令相比较, 发现多了一条$\bold{uitofp}$指令.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;IR指令&lt;/th&gt;
&lt;th&gt;例子&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$\bold{fcmp}$&lt;/td&gt;
&lt;td&gt;$\color{red}{fcmp}$ $one$ $double$ ${\%booltmp}$,   $0.0e+00$&lt;/td&gt;
&lt;td&gt;比较指令, 相等则返回 0, 不相等返回 1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{call}$&lt;/td&gt;
&lt;td&gt;$\color{red}{call}$    $double$ $@ putchard(double$   $ 4.2000e+01)$&lt;/td&gt;
&lt;td&gt;调用函数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{br}$&lt;/td&gt;
&lt;td&gt;$\color{red}{br}$       ${label }$  ${\%loop}$&lt;/td&gt;
&lt;td&gt;直接跳转&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{br}$&lt;/td&gt;
&lt;td&gt;$\color{red}{br}$       $i1$  $\%loopcond$  $label$  $\%loop$,  $label$  $\%afterloop$&lt;/td&gt;
&lt;td&gt;条件跳转&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{phi}$&lt;/td&gt;
&lt;td&gt;$\color{red}{phi}$     ${double [1.0e+0, \%entry] }$, ${[\%nextvar, \%loop]}$&lt;/td&gt;
&lt;td&gt;调用${phi}$ 函数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{uitofp}$&lt;/td&gt;
&lt;td&gt;$\color{red}{uitofp}$ $i1$    $\%cmptmp$   $to$   $double$&lt;/td&gt;
&lt;td&gt;将bool(&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;0&lt;/sub&gt;)转换为double(1.0/0.0)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{ret}$&lt;/td&gt;
&lt;td&gt;$\color{red}{ret}$     $double$ $\% 0$&lt;/td&gt;
&lt;td&gt;函数返回&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Label&lt;/th&gt;
&lt;th&gt;means&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$\bold{entry}$&lt;/td&gt;
&lt;td&gt;函数入口&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{loop}$&lt;/td&gt;
&lt;td&gt;loop循环入口&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$\bold{afterloop}$&lt;/td&gt;
&lt;td&gt;loop循环结束&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;for-s-cfg&#34;&gt;for&amp;rsquo;s CFG&lt;/h3&gt;

&lt;p&gt;使用&lt;code&gt;opt -analyze -view-cfg loop.bc&lt;/code&gt;生成的CFG.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/docs-pic/llvm/loop.png&#34; alt=&#34;loop&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;builder流程图-1&#34;&gt;Builder流程图&lt;/h3&gt;

&lt;div class=&#34;mermaid&#34;&gt;
graph TB

    Start(&#34;Loop Codegen&#34;) --&gt; StartCodegen[&#34;Start-&gt;codegen();&#34;]
    StartCodegen --&gt; builderCreateBr[&#34;Builder.CreateBr&#34;]
    subgraph Loop
        builderSetInsertLoopBB[&#34;Builder.SetInsertPoint(LoopBB)&#34;]    
        builderCreatePHI[&#34;Builder.CreatePHI&#34;]
        BodyCodegen[&#34;Body-&gt;codegen();&#34;]

        builderSetInsertLoopBB --&gt; builderCreatePHI
        builderCreatePHI --&gt; BodyCodegen
        BodyCodegen --&gt; ifStep{&#34;Step != NULL&#34;}
        ifStep --Y--&gt; StepCodegen[&#34;Step-&gt;codegen();&#34;]
        ifStep --N--&gt; SetStep[&#34;Set Step to 1.0&#34;]
        StepCodegen --&gt; builderCreateFAdd[&#34;Builder.CreateFAdd&#34;]
        SetStep --&gt; builderCreateFAdd

        builderCreateFAdd --&gt; EndCodegen[&#34;End-&gt;codegen();&#34;] 
        EndCodegen --&gt; builderCreateFCmp[&#34;Builder.CreateFCmpOne&#34;] 
        builderCreateFCmp --&gt; builderCreateCondBr[&#34;Builder.CreateCondBr&#34;]
    end 

    builderCreateBr --&gt; builderSetInsertLoopBB

    subgraph afterloop
        builderSetInsertAfterBB[&#34;Builder.SetInsertPoint(AfterBB)&#34;]
    end 
    
    builderCreateCondBr --&gt; builderSetInsertAfterBB
    
    builderSetInsertAfterBB --&gt; End[&#34;End Codegen&#34;]


    style builderSetInsertLoopBB fill:#ffcc66
    style builderSetInsertAfterBB fill:#ffcc66

    
    style StartCodegen fill:#ff66cc
    style BodyCodegen fill:#ff66cc
    style StepCodegen fill:#ff66cc
    style EndCodegen fill:#ff66cc
    
    style Start fill:#ff9966
    style End fill:#ff9966

&lt;/div&gt;

&lt;h1 id=&#34;jit和优化&#34;&gt;JIT和优化&lt;/h1&gt;

&lt;p&gt;参考: &lt;a href=&#34;https://l0phtg.github.io/post/llvm/kaleidoscope-adding-jit-and-optimizer-support/&#34;&gt;Adding JIT and Optimizer Support&lt;/a&gt;&lt;/p&gt;

&lt;div class=&#34;mermaid&#34;&gt;
graph TB

    subgraph call
        funcall(&#34;foo(1);&#34;)
    end

    subgraph expr
        nodeExpr(&#34;1+2;&#34;)
    end
    
    jitAddModule[&#34;JIT中 添加此Module&#34;]
    jitRemoveModule[&#34;JIT中 删除此Module&#34;]
    
    anoCodegen[&#34;执行 匿名函数Codegen&#34;]
    AnonymousCall[&#34;匿名函数包装&#34;]
    optimizeFunc[&#34;执行 Pass优化&#34;]
    nodeExpr --&gt; AnonymousCall
    funcall --&gt; AnonymousCall
    AnonymousCall --&gt; anoCodegen
    anoCodegen --&gt; jitAddModule
    jitAddModule --&gt; optimizeFunc
    optimizeFunc --&gt; exec[&#34;jit运行此表达式, 并计算值&#34;]
    exec --&gt; jitRemoveModule
    
    subgraph func definition
        nodeFoo(&#34;def foo(x) x+1;&#34;)
        funcCodegen[&#34;执行 函数定义Codegen&#34;]
        nodeFoo --&gt; funcCodegen
    end
    
    funcCodegen --&gt; jitAddFuncModule[&#34;jit中 添加此Module&#34;]
    jitAddFuncModule --&gt; initPassManager[&#34;执行 pass优化&#34;]


    subgraph extern
        nodeExtern(&#34;extern sin(x);&#34;)
        protoCodegen[&#34;执行 函数申明Codegen&#34;]
        nodeExtern --&gt; protoCodegen
    end
    
    style jitAddModule fill:#f9f
    style jitRemoveModule fill:#f9f
    style jitAddFuncModule fill:#f9f
    
    style optimizeFunc fill:#ccff66
    style initPassManager fill:#ccff66
    
    style exec fill:#ff3300
    
&lt;/div&gt;

&lt;h1 id=&#34;driver&#34;&gt;Driver&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// top ::= definition | external | expression | &#39;;&#39;
static void MainLoop() {
  while (true) {
    fprintf(stderr, &amp;quot;ready&amp;gt; &amp;quot;);
    switch (CurTok) {
    case tok_eof:
      return;
    case &#39;;&#39;: // ignore top-level semicolons.
      getNextToken();
      break;
    case tok_def:
      HandleDefinition();
      break;
    case tok_extern:
      HandleExtern();
      break;
    default:
      HandleTopLevelExpression();
      break;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>书签整理</title>
      <link>https://l0phtg.github.io/post/life/%E4%B9%A6%E7%AD%BE%E6%95%B4%E7%90%86/</link>
      <pubDate>Mon, 15 Apr 2019 10:13:04 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/life/%E4%B9%A6%E7%AD%BE%E6%95%B4%E7%90%86/</guid>
      
        <description>&lt;p&gt;昨晚闲得无聊, 整理了一下自己的chrome书签.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/life/bookmark-update.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Kaleidoscope: Extending the Language Control Flow</title>
      <link>https://l0phtg.github.io/post/llvm/kaleidoscope-extending-the-language-control-flow/</link>
      <pubDate>Sun, 14 Apr 2019 14:43:17 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/llvm/kaleidoscope-extending-the-language-control-flow/</guid>
      
        <description>&lt;p&gt;translate from: &lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl05.html&#34;&gt;http://llvm.org/docs/tutorial/LangImpl05.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文为Kaleidoscope添加条件判断控制流和循环控制流.&lt;/p&gt;

&lt;p&gt;注意: 本文假定你已经阅读过前面几篇文章, 所以在词法解析和AST生成就写的比较简单(当然了, 这部分内容本身阅读起来就比较轻松), 着重介绍控制流的Codegen部分.&lt;/p&gt;

&lt;p&gt;因为这个系列主要是翻译, 所以基本没有涉及自己的理解. &lt;strong&gt;之后我会单独写一篇文章, 来对Kaleidoscope的前五章做一个总结&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/docs-pic/llvm/loop.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;chapter-5-introduction&#34;&gt;Chapter 5 Introduction&lt;/h1&gt;

&lt;p&gt;Welcome to Chapter 5 of the &amp;ldquo;Implementing a language with LLVM &amp;rdquo; tutorial.&lt;/p&gt;

&lt;p&gt;第一章到第四章描述了Kaleidoscope的简单的实现并且支持了LLVM IR的生成, 然后是优化和JIT编译器.&lt;/p&gt;

&lt;p&gt;不幸地是, 正如你现在现在看到的, Kaleidoscope 是几乎无用的:&lt;/p&gt;

&lt;p&gt;​   除了调用和返回之外, 它没有其他控制流. 这意味着你在代码中没有条件分支, 从而限制了它的功能.&lt;/p&gt;

&lt;p&gt;在本期 构建编译器中, 我们将会扩展Kaleidoscope, 使它拥有 &lt;strong&gt;if/then/else表达式&lt;/strong&gt;和一个简单的 &lt;strong&gt;for 循环&lt;/strong&gt;.&lt;/p&gt;

&lt;h1 id=&#34;if-then-else&#34;&gt;if/Then/Else&lt;/h1&gt;

&lt;p&gt;扩展Kaleidoscope来支持if/then/else是相当直接的. 它基本上就是为&lt;strong&gt;词法分析器, 解析器, AST, LLVM Code emitter&lt;/strong&gt;增加新的概念.&lt;/p&gt;

&lt;p&gt;例子是很不错的, 因为它表明了&lt;code&gt;随着时间的推移, 根据新的概念来对语言进行扩展是多么的容易&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;在我们进行扩展之前, 让我们讨论一下我们到底想要做什么.&lt;/p&gt;

&lt;p&gt;基本的意思是我们想要能够写出这样的代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;def fib(x)
  if x &amp;lt; 3 then
    1
  else
    fib(x-1)+fib(x-2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Kaleidoscope中, 每个构造都是一个表达式: 没有语句. 因此, &lt;strong&gt;if/then/else&lt;/strong&gt; 表达式需要像其他表达式一样返回值. 由于我们正在使用一个普遍的功能形式, 我们会计算它的条件, 然后根据条件的解析方式返回 &lt;strong&gt;then&lt;/strong&gt;或&lt;strong&gt;else&lt;/strong&gt;值.&lt;/p&gt;

&lt;p&gt;if/then/else的表达式的语义是: &lt;code&gt;它能够将条件计算为一个bool等价的值&lt;/code&gt;: 0.0被认为是false, everything else被认为是true. 如果条件为true, 则计算并返回第一个子表达式值; 如果条件为false, 则计算并返回第二个表达式值. 由于Kaleidoscope 允许产生副作用, 所以将该行为确定下来是非常重要的.&lt;/p&gt;

&lt;p&gt;现在我们知道了我们想要做什么, 下面让我们一起了解它的组成部分.&lt;/p&gt;

&lt;h2 id=&#34;if-then-else的lexer扩展&#34;&gt;if/then/else的Lexer扩展&lt;/h2&gt;

&lt;p&gt;词法分析扩展是相当直接的. 首先我们&lt;strong&gt;为新的tokens增加新的enum值&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// control
tok_if = -6,
tok_then = -7,
tok_else = -8,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一旦我们有了它们 我们就意识到了在词法分析器中有了新的&lt;strong&gt;keywords(关键字)&lt;/strong&gt;. This is pretty simple stuff:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;...
if (IdentifierStr == &amp;quot;def&amp;quot;)
  return tok_def;
if (IdentifierStr == &amp;quot;extern&amp;quot;)
  return tok_extern;
if (IdentifierStr == &amp;quot;if&amp;quot;)
  return tok_if;
if (IdentifierStr == &amp;quot;then&amp;quot;)
  return tok_then;
if (IdentifierStr == &amp;quot;else&amp;quot;)
  return tok_else;
return tok_identifier;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;if-then-else的ast-扩展&#34;&gt;if/then/else的AST 扩展&lt;/h2&gt;

&lt;p&gt;if/then/else 属于表达式, 所以==IfExprAST==继承自==ExprAST==.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// IfExprAST - Expression class for if/then/else.
class IfExprAST : public ExprAST {
  std::unique_ptr&amp;lt;ExprAST&amp;gt; Cond, Then, Else;

public:
  IfExprAST(std::unique_ptr&amp;lt;ExprAST&amp;gt; Cond, std::unique_ptr&amp;lt;ExprAST&amp;gt; Then,
            std::unique_ptr&amp;lt;ExprAST&amp;gt; Else)
    : Cond(std::move(Cond)), Then(std::move(Then)), Else(std::move(Else)) {}

  Value *codegen() override;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;if-then-else的parser扩展&#34;&gt;if/then/else的parser扩展&lt;/h2&gt;

&lt;p&gt;现在我们有了词法分析的tokens和AST节点, 我们现在的解析逻辑就相当直接了.&lt;/p&gt;

&lt;p&gt;首先我们定义一个新的解析函数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/// ifexpr ::= &#39;if&#39; expression &#39;then&#39; expression &#39;else&#39; expression
static std::unique_ptr&amp;lt;ExprAST&amp;gt; ParseIfExpr() {
  getNextToken();  // eat the if.

  // condition.
  auto Cond = ParseExpression();
  if (!Cond)
    return nullptr;

  if (CurTok != tok_then)
    return LogError(&amp;quot;expected then&amp;quot;);
  getNextToken();  // eat the then

  auto Then = ParseExpression();
  if (!Then)
    return nullptr;

  if (CurTok != tok_else)
    return LogError(&amp;quot;expected else&amp;quot;);

  getNextToken();

  auto Else = ParseExpression();
  if (!Else)
    return nullptr;

  return llvm::make_unique&amp;lt;IfExprAST&amp;gt;(std::move(Cond), std::move(Then),
                                      std::move(Else));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们将它与primay expression连接起来:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;static std::unique_ptr&amp;lt;ExprAST&amp;gt; ParsePrimary() {
  switch (CurTok) {
  default:
    return LogError(&amp;quot;unknown token when expecting an expression&amp;quot;);
  case tok_identifier:
    return ParseIdentifierExpr();
  case tok_number:
    return ParseNumberExpr();
  case &#39;(&#39;:
    return ParseParenExpr();
  case tok_if:
    return ParseIfExpr();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;if-then-else的llvm-ir&#34;&gt;if/then/else的LLVM IR&lt;/h2&gt;

&lt;p&gt;现在我们已经解析完成并且建立了抽象语法树, 最后的内容是增加==LLVM code generation support==. 这是 if/else/then的例子中最有趣的地方, &lt;strong&gt;因为它开始引入了新的概念&lt;/strong&gt;. 上面所有的代码都在以前的章节详细介绍过.&lt;/p&gt;

&lt;p&gt;为了产生我们想要得到的代码. 让我们看一个简单的例子. Consider:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;extern foo();
extern bar();
def baz(x) if x then foo() else bar();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果禁用优化, 你可以看到生成的IR是下面这样的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;declare double @foo()

declare double @bar()

define double @baz(double %x) {
entry:
  %ifcond = fcmp one double %x, 0.000000e+00
  br i1 %ifcond, label %then, label %else

then:       ; preds = %entry
  %calltmp = call double @foo()
  br label %ifcont

else:       ; preds = %entry
  %calltmp1 = call double @bar()
  br label %ifcont

ifcont:     ; preds = %else, %then
  %iftmp = phi double [ %calltmp, %then ], [ %calltmp1, %else ] ; 返回值
  ret double %iftmp
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了使流程图可视化:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;你能够使用LLVM &lt;strong&gt;opt&lt;/strong&gt; tool的一个漂亮的功能. 如果你将LLVM IR放到 &amp;ldquo;t.ll&amp;rdquo;中, 并且运行 &lt;code&gt;llvm-as &amp;lt; t.ll | opt -analyze -view-cfg&lt;/code&gt;, 一个window将会弹出, 并且你将会看到这幅图:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/docs-pic/llvm/if.png&#34; alt=&#34;if CFG&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;另一种方法: 可以通过调用 &lt;code&gt;F-&amp;gt;viewCFG()&lt;/code&gt; 或者&lt;code&gt;F-&amp;gt;viewCFGOnly()&lt;/code&gt;(where F is a &amp;ldquo;Function&amp;rdquo;)通过插入实际的调用到代码中并且重新编译, 可以得到我们想要的CFG图. 或者通过在编译器中调用他们. LLVM具有许多很友好的特性来可视化出各种各样的图形.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;回到我们的Codegen代码中, 它是相当简单地:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The entry block&lt;/strong&gt;: 计算条件表达式 (在我们的例子中是&amp;rdquo;x&amp;rdquo; ) 并且使用==fcmp one==指令将&lt;strong&gt;result&lt;/strong&gt;与&lt;strong&gt;0.0&lt;/strong&gt;相比较 ( &lt;strong&gt;one&lt;/strong&gt; 表示有序并且不相等). 基于该表达式的结果, 代码跳转到&lt;strong&gt;then block&lt;/strong&gt; 或者 &lt;strong&gt;else block&lt;/strong&gt;, which 包含 true/false cases的表达式.&lt;/p&gt;

&lt;p&gt;一旦 &lt;strong&gt;then/else block&lt;/strong&gt;执行完成了, 他们都返回到&lt;strong&gt;&amp;ldquo;ifcont&amp;rdquo; block&lt;/strong&gt;来执行 if/then/else 之后发生的代码. 在这种情况下, 唯一要做的事情就是返回到函数的调用者.&lt;/p&gt;

&lt;p&gt;现在我们的问题是: &lt;code&gt;代码是如何知道哪一个表达式要返回的呢?&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个问题的答案涉及重要的&lt;strong&gt;SSA 操作&lt;/strong&gt;: &lt;a href=&#34;https://en.wikipedia.org/wiki/Static_single_assignment_form&#34;&gt;the Phi operation&lt;/a&gt;(或者看我之前翻译的文章: &lt;a href=&#34;https://l0phtg.github.io/post/llvm/static-single-assignment/&#34;&gt;Staitc Single Assignment&lt;/a&gt;). 如果你不熟悉SSA, &lt;a href=&#34;https://en.wikipedia.org/wiki/Static_single_assignment_form&#34;&gt;the wikipedia article&lt;/a&gt;是一个很不错的入门并且你最喜欢的搜索引擎上各种其它的介绍.&lt;/p&gt;

&lt;p&gt;一个简单的对$phi$ 函数执行的介绍是: &lt;code&gt;可以确定我们是从哪一个表达式返回的&lt;/code&gt;. &lt;strong&gt;The phi operation&lt;/strong&gt;采用与输入控制块相对应的value.&lt;/p&gt;

&lt;p&gt;在这个例子中, 如果控制来自 &lt;strong&gt;&amp;ldquo;then&amp;rdquo; block&lt;/strong&gt;, 则它获得&lt;strong&gt;calltmp&lt;/strong&gt;的值.&lt;/p&gt;

&lt;p&gt;如果控制来自&lt;strong&gt;&amp;ldquo;else&amp;rdquo; block&lt;/strong&gt;, 它获得&lt;strong&gt;calltmp1&lt;/strong&gt;的值.&lt;/p&gt;

&lt;p&gt;此刻, 你可能已经开始思考了. &amp;ldquo;Oh no!&amp;rdquo; 这意味着我的简单优雅的前端必须开始生成SSA 才能使用LLVM. 幸运地是, 我们强烈建议不要在你的前端实现SSA构造算法除非你有一个非常好的理由这样做. 实际上,  对于你的命令行式编程语言来说,出现下面这两种情况时, 这表明此刻可能需要Phi nodes:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;代码涉及用户变量: x = 1; x = x + 1;&lt;/li&gt;
&lt;li&gt;Values可能隐式地在AST结构中, 例如在本例子中的Phi node.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在&lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl07.html&#34;&gt;第七章&lt;/a&gt;  (&amp;ldquo;多元变量&amp;rdquo;), 我们将讨论第一种情况. 现在, 请相信我你不需要SSA构造来处理这种情况.&lt;/p&gt;

&lt;p&gt;对于第二种情况, 你可以选择使用我们将为 #1描述的技术. 或者你能直接插入Phi 节点(如果方便的话).&lt;/p&gt;

&lt;p&gt;在我们这个例子中 产生 Phi code真的是简单的, 所以我们选择直接插入Phi节点.&lt;/p&gt;

&lt;p&gt;Okay. 我们已经了解了足够多, 让我们生成代码吧.&lt;/p&gt;

&lt;h2 id=&#34;if-then-else-的代码产生&#34;&gt;if/then/else 的代码产生&lt;/h2&gt;

&lt;p&gt;为了产生代码, 我们需要实现&lt;strong&gt;IfExpAST&lt;/strong&gt;的codegen方法.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Value *IfExprAST::codegen() {
  Value *CondV = Cond-&amp;gt;codegen();
  if (!CondV)
    return nullptr;

  // Convert condition to a bool by comparing non-equal to 0.0.
  // 转换条件到一个bool值. 
  CondV = Builder.CreateFCmpONE(
      CondV, ConstantFP::get(TheContext, APFloat(0.0)), &amp;quot;ifcond&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码很直接, 和我们之前看到的类似. 我们 emit the expression for the condition, 然后将值与0进行比较, 得到bool值.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Function *TheFunction = Builder.GetInsertBlock()-&amp;gt;getParent();

// Create blocks for the then and else cases.  Insert the &#39;then&#39; block at the
// end of the function.
// 创建then and else case的blocks. 
// 插入 &#39;then&#39; block在函数的最后

BasicBlock *ThenBB =
    BasicBlock::Create(TheContext, &amp;quot;then&amp;quot;, TheFunction);
BasicBlock *ElseBB = BasicBlock::Create(TheContext, &amp;quot;else&amp;quot;);
BasicBlock *MergeBB = BasicBlock::Create(TheContext, &amp;quot;ifcont&amp;quot;);

Builder.CreateCondBr(CondV, ThenBB, ElseBB);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个代码创建与 &lt;strong&gt;if/then/else&lt;/strong&gt;语句相关的&lt;strong&gt;basic block&lt;/strong&gt;, 并且直接对应于上例中的块.&lt;/p&gt;

&lt;p&gt;第一行获取当前正在构建的&lt;strong&gt;Function&lt;/strong&gt;对象: 它通过询问&lt;strong&gt;Builder&lt;/strong&gt;当前的&lt;strong&gt;BasicBlock&lt;/strong&gt;, 并询问当前&lt;strong&gt;Block的parent&lt;/strong&gt;, 来获取此信息.&lt;/p&gt;

&lt;p&gt;获得函数之后, 我们会创建三个Blocks. 注意: 它传递&amp;rdquo;TheFunction&lt;strong&gt;到&amp;rdquo;then&amp;rdquo;block的构造器中&lt;/strong&gt;. &lt;code&gt;这会导致构造函数会自动地在指定的函数中插入new block&lt;/code&gt;. &lt;strong&gt;其他的两个block被创建, 但是还没有被插入&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;一旦&lt;strong&gt;block&lt;/strong&gt;被创建, 我们就可以&lt;code&gt;emit the 在它们之间选择的条件分支&lt;/code&gt;. 注意, 创建新的&lt;strong&gt;block&lt;/strong&gt;不会隐式地影响&lt;strong&gt;IRBuilder&lt;/strong&gt;, 因此它仍然可以插入条件到进入的块中.  另外要注意, 它正在&lt;code&gt;创建到&amp;quot;then&amp;quot;block和&amp;quot;else&amp;quot;block的分支&lt;/code&gt;, 即使&amp;rdquo;else&amp;rdquo;block还未插入到函数中.&lt;/p&gt;

&lt;p&gt;This is all ok. 它是LLVM支持==forward references==的标准方法.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Emit then value.       
Builder.SetInsertPoint(ThenBB);

Value *ThenV = Then-&amp;gt;codegen();
if (!ThenV)
  return nullptr;

Builder.CreateBr(MergeBB);
// Codegen of &#39;Then&#39; can change the current block, update ThenBB for the PHI.
// &#39;Then&#39;的Codegen会改变目前的block, update ThenBB for the PHI.
ThenBB = Builder.GetInsertBlock();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在条件分支被插入之后, 我们move the builder来插入&amp;rdquo;then&amp;rdquo;block. 严格上来说, this call移动插入点到指定block的end. 然而, 由于 &amp;ldquo;then&amp;rdquo; block是空的, 所以它就会从block的开始进行插入.&lt;/p&gt;

&lt;p&gt;一旦插入点被设置了, 我们可以递归地从AST中codegen the &amp;ldquo;then&amp;rdquo;表达式. 为了完成&amp;rdquo;then&amp;rdquo;块, 我们为合并块创建了一个无条件分支.&lt;/p&gt;

&lt;p&gt;LLVM IR一个有趣的方面是&lt;strong&gt;它要求所有的BasicBlock都用控制流指令来中止(Ex: return and branch)&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;这意味着所有的控制流, including fall throughs, 必须在LLVM IR中被显示地指定. 如果违反此规则, 验证程序会报错.&lt;/p&gt;

&lt;p&gt;这里的最后一行相当&lt;strong&gt;微妙&lt;/strong&gt;, 但是是非常重要的. 基本问题就是当我们在&lt;strong&gt;merge block&lt;/strong&gt;中创建 Phi node时, 我们需要设置 &lt;strong&gt;block/value pairs&lt;/strong&gt; 来表明Phi是如何工作的. 重要的 , The Phi node 期待在CFG的块中每一个前节点都有一个entry.&lt;/p&gt;

&lt;p&gt;那么, 为什么在第 5 行, 我们设置ThenBB为获取当前块呢?  &amp;ldquo;Then&amp;rdquo;表达式实际上可能会改变当前的block.  例如, 它包含了一个嵌套的&amp;rdquo;if/then/else&amp;rdquo;表达式. 因为递归地调用codegen()会任意改变当前块的notion, 我们需要得到将要设置的Phi node代码的最新值.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// Emit else block. 
TheFunction-&amp;gt;getBasicBlockList().push_back(ElseBB);
Builder.SetInsertPoint(ElseBB);

Value *ElseV = Else-&amp;gt;codegen();
if (!ElseV)
  return nullptr;

Builder.CreateBr(MergeBB);
// codegen of &#39;Else&#39; can change the current block, update ElseBB for the PHI.
ElseBB = Builder.GetInsertBlock();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&amp;lsquo;else&amp;rsquo;&lt;/strong&gt;代码块的codegen与&lt;strong&gt;&amp;lsquo;then&amp;rsquo; block&lt;/strong&gt;的codegen基本相同. 唯一的显著差异是第一行: 它将&amp;rdquo;else&amp;rdquo;block 添加到函数中. 回想之前, 我们已经创建了&amp;rsquo;else&amp;rsquo;块, 但未添加到该函数中.&lt;/p&gt;

&lt;p&gt;现在&lt;strong&gt;then&lt;/strong&gt; 和 &lt;strong&gt;else&lt;/strong&gt; 代码块的IR都已经产生了, 我们现在可以完成我们的&lt;strong&gt;Merge&lt;/strong&gt;代码了.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;  // Emit merge block.
  TheFunction-&amp;gt;getBasicBlockList().push_back(MergeBB);
  Builder.SetInsertPoint(MergeBB);
  PHINode *PN =
    Builder.CreatePHI(Type::getDoubleTy(TheContext), 2, &amp;quot;iftmp&amp;quot;);

  PN-&amp;gt;addIncoming(ThenV, ThenBB);
  PN-&amp;gt;addIncoming(ElseV, ElseBB);
  return PN;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开始的两行是相似的: 第一行添加 &lt;strong&gt;&amp;ldquo;merge&amp;rdquo; block&lt;/strong&gt;到&lt;strong&gt;function object&lt;/strong&gt;中(之前merge block被创建之后, 还没有插入函数中). 第二行改变插入点位置, 所以新的codegen的代码会在&lt;strong&gt;Merge Block&lt;/strong&gt;中. 一旦做完这些之后, 我们需要创建PHI node并且给phi 节点设置一组值(block/value pairs).&lt;/p&gt;

&lt;p&gt;最后, CodeGen函数返回 phi nodes作为if/then/else表达式计算的值. 在我们上面的例子中, 返回值将会提供给顶级函数的代码中, 该函数将会创建返回指令.&lt;/p&gt;

&lt;p&gt;总的来说, 我们现在能够在Kaleidoscope中执行条件代码. 加入这项扩展之后, Kaleidoscope是一个相当完整的语言(因为它可以计算大量的数值函数).&lt;/p&gt;

&lt;p&gt;下一步我们将会添加另一个有用的表达式 that is familiar from non-functional languages.&lt;/p&gt;

&lt;h1 id=&#34;for-loop-expression&#34;&gt;&amp;lsquo;for&amp;rsquo; Loop Expression&lt;/h1&gt;

&lt;p&gt;现在我们知道了如何在语言中添加基本的控制流, 我们有了一些工具来添加更多强大的功能.&lt;/p&gt;

&lt;p&gt;让我们来做一些更有趣的, &lt;strong&gt;&amp;lsquo;for&amp;rsquo; expression&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;extern putchard(char);
def printstar(n)
  for i = 1, i &amp;lt; n, 1.0 in
    putchard(42);  # ascii 42 = &#39;*&#39;

# print 100 &#39;*&#39; characters
printstar(100);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在此例中, 这个表达式定义的一个新的变量(&amp;ldquo;i&amp;rdquo;), &lt;strong&gt;i&lt;/strong&gt; 从初始值开始迭代, 当条件( &lt;strong&gt;&amp;ldquo;i &amp;lt; n&amp;rdquo;&lt;/strong&gt; )为true时, 以步长(&lt;strong&gt;&amp;ldquo;1.0&amp;rdquo;&lt;/strong&gt;)开始增加.&lt;/p&gt;

&lt;p&gt;如果&lt;strong&gt;步长&lt;/strong&gt;被省略了, 默认设置它为1.0.&lt;/p&gt;

&lt;p&gt;当&lt;strong&gt;循环条件为true&lt;/strong&gt;时, 它会执行它的body expression. 因为我们没有什么要返回的, 所以我们定义&lt;strong&gt;the loop总是返回0.0&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;在未来当我们有&lt;strong&gt;可变变量&lt;/strong&gt;时, 它会变得更有用.&lt;/p&gt;

&lt;p&gt;像往常一样, 让我们开始讨论如何设计Kaleidoscope来支持 &lt;strong&gt;for循环&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&#34;lexer-extensions-for-the-for-loop&#34;&gt;Lexer Extensions for the &amp;lsquo;for&amp;rsquo; Loop&lt;/h2&gt;

&lt;p&gt;扩展词法分析器与 &lt;strong&gt;if/then/else&lt;/strong&gt;相似:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;... in enum Token ...
// control
tok_if = -6, tok_then = -7, tok_else = -8,
tok_for = -9, tok_in = -10

... in gettok ...
if (IdentifierStr == &amp;quot;def&amp;quot;)
  return tok_def;
if (IdentifierStr == &amp;quot;extern&amp;quot;)
  return tok_extern;
if (IdentifierStr == &amp;quot;if&amp;quot;)
  return tok_if;
if (IdentifierStr == &amp;quot;then&amp;quot;)
  return tok_then;
if (IdentifierStr == &amp;quot;else&amp;quot;)
  return tok_else;
if (IdentifierStr == &amp;quot;for&amp;quot;)
  return tok_for;
if (IdentifierStr == &amp;quot;in&amp;quot;)
  return tok_in;
return tok_identifier;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ast-extensions-for-the-for-loop&#34;&gt;AST Extensions for the &amp;lsquo;for&amp;rsquo; Loop&lt;/h2&gt;

&lt;p&gt;The AST node也很简单. 它基本上就是包含: &lt;strong&gt;节点中的变量名&lt;/strong&gt; 和 &lt;strong&gt;组成它的表达式&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// ForExprAST - Expression class for for/in.
class ForExprAST : public ExprAST {
  std::string VarName;  // 迭代器变量名称
  std::unique_ptr&amp;lt;ExprAST&amp;gt; Start, End, Step, Body;

public:
  ForExprAST(const std::string &amp;amp;VarName, std::unique_ptr&amp;lt;ExprAST&amp;gt; Start,
             std::unique_ptr&amp;lt;ExprAST&amp;gt; End, std::unique_ptr&amp;lt;ExprAST&amp;gt; Step,
             std::unique_ptr&amp;lt;ExprAST&amp;gt; Body)
    : VarName(VarName), Start(std::move(Start)), End(std::move(End)),
      Step(std::move(Step)), Body(std::move(Body)) {}

  Value *codegen() override;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;parser-extensions-for-the-for-loop&#34;&gt;Parser Extensions for the &amp;lsquo;for&amp;rsquo; Loop&lt;/h2&gt;

&lt;p&gt;解析器代码也是相当标准的.&lt;/p&gt;

&lt;p&gt;唯一有趣的事情是这里会处理可选的&lt;strong&gt;步长&lt;/strong&gt;. 解析器代码通过&lt;code&gt;检查第二个逗号是否存在来处理&lt;/code&gt;. &lt;code&gt;如果没有发现逗号, 我们会在AST节点中将步长设置为null&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/// forexpr ::= &#39;for&#39; identifier &#39;=&#39; expr &#39;,&#39; expr (&#39;,&#39; expr)? &#39;in&#39; expression
static std::unique_ptr&amp;lt;ExprAST&amp;gt; ParseForExpr() {
  getNextToken();  // eat the for.

  if (CurTok != tok_identifier)
    return LogError(&amp;quot;expected identifier after for&amp;quot;);

  std::string IdName = IdentifierStr;
  getNextToken();  // eat identifier.

  if (CurTok != &#39;=&#39;)
    return LogError(&amp;quot;expected &#39;=&#39; after for&amp;quot;);
  getNextToken();  // eat &#39;=&#39;.


  auto Start = ParseExpression();
  if (!Start)
    return nullptr;
  if (CurTok != &#39;,&#39;)
    return LogError(&amp;quot;expected &#39;,&#39; after for start value&amp;quot;);
  getNextToken();

  auto End = ParseExpression();
  if (!End)
    return nullptr;

  // The step value is optional.
  std::unique_ptr&amp;lt;ExprAST&amp;gt; Step;
  if (CurTok == &#39;,&#39;) {
    getNextToken();
    Step = ParseExpression();
    if (!Step)
      return nullptr;
  }

  if (CurTok != tok_in)
    return LogError(&amp;quot;expected &#39;in&#39; after for&amp;quot;);
  getNextToken();  // eat &#39;in&#39;.

  auto Body = ParseExpression();
  if (!Body)
    return nullptr;

  return llvm::make_unique&amp;lt;ForExprAST&amp;gt;(IdName, std::move(Start),
                                       std::move(End), std::move(Step),
                                       std::move(Body));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然了, 我们会将它作为主表达式的一部分.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;static std::unique_ptr&amp;lt;ExprAST&amp;gt; ParsePrimary() {
  switch (CurTok) {
  default:
    return LogError(&amp;quot;unknown token when expecting an expression&amp;quot;);
  case tok_identifier:
    return ParseIdentifierExpr();
  case tok_number:
    return ParseNumberExpr();
  case &#39;(&#39;:
    return ParseParenExpr();
  case tok_if:
    return ParseIfExpr();
  case tok_for:
    return ParseForExpr();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;llvm-ir-for-the-for-loop&#34;&gt;LLVM IR for the &amp;lsquo;for&amp;rsquo; loop&lt;/h2&gt;

&lt;p&gt;下一步, 我们现在需要为For循环产生IR. 根据上面的例子, 我们可以产生下面这样的IR(注意: 为了清楚起见, 我们在产生时关闭了优化):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;declare double @putchard(double)

define double @printstar(double %n) {
entry:
  ; initial value = 1.0 (inlined into phi)
  br label %loop

loop:       ; preds = %loop, %entry
  %i = phi double [ 1.000000e+00, %entry ], [ %nextvar, %loop ]
  ; body
  %calltmp = call double @putchard(double 4.200000e+01)
  ; increment
  %nextvar = fadd double %i, 1.000000e+00

  ; termination test
  %cmptmp = fcmp ult double %i, %n
  %booltmp = uitofp i1 %cmptmp to double
  %loopcond = fcmp one double %booltmp, 0.000000e+00
  br i1 %loopcond, label %loop, label %afterloop

afterloop:      ; preds = %loop
  ; loop always returns 0.0
  ret double 0.000000e+00
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该循环包含我们之前看到的相同的结构: &lt;strong&gt;a phi node&lt;/strong&gt;, &lt;strong&gt;several expressions&lt;/strong&gt;, and &lt;strong&gt;some basic blocks&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;CFG:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/docs-pic/llvm/loop.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;code-generation-for-the-for-loop&#34;&gt;Code Generation for the &amp;lsquo;for&amp;rsquo; Loop&lt;/h2&gt;

&lt;p&gt;codegen的第一部分是简单的, 我们只是输出&lt;strong&gt;循环的起始表达式&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Value *ForExprAST::codegen() {
  // Emit the start code first, without &#39;variable&#39; in scope.
  Value *StartVal = Start-&amp;gt;codegen();
  if (!StartVal)
    return nullptr;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在此之后, 下一步是为&lt;strong&gt;loop body&lt;/strong&gt;的启动设置&lt;strong&gt;LLVM basic block&lt;/strong&gt;. 在上面的例子中, 整个loop body是一个&lt;strong&gt;block&lt;/strong&gt;. 但是记住: &lt;code&gt;body node 本身可以包含多个blocks&lt;/code&gt;. (E.g: 它可以包含 if/then/else 或者 a for/in expression).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Make the new basic block for the loop header, inserting after current
// block.
// 为loop header make新的basic block, 在当前block之后插入
Function *TheFunction = Builder.GetInsertBlock()-&amp;gt;getParent();
BasicBlock *PreheaderBB = Builder.GetInsertBlock();
BasicBlock *LoopBB =
    BasicBlock::Create(TheContext, &amp;quot;loop&amp;quot;, TheFunction);

// Insert an explicit fall through from the current block to the LoopBB.
// 从当前块插入explicit fall through to the LoopBB
Builder.CreateBr(LoopBB);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码与我们在if/then/else中看到的代码相似. 因为之后我们将会需要它来创建一个Phi node, 所以我们保存了那个刚进入循环的块.&lt;/p&gt;

&lt;p&gt;在做完这些之后, 我们创建&lt;strong&gt;Loop Block&lt;/strong&gt;, 并且为两个块之前的连接创建一个无条件分支.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Start insertion in LoopBB.   开始插入
Builder.SetInsertPoint(LoopBB);

// Start the PHI node with an entry for Start. 

PHINode *Variable = Builder.CreatePHI(Type::getDoubleTy(TheContext),
                                      2, VarName.c_str());
Variable-&amp;gt;addIncoming(StartVal, PreheaderBB);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在 loop 的&lt;strong&gt;&amp;ldquo;preheader&amp;rdquo;&lt;/strong&gt;已经设置好了, 我们切换到为 loop body来emitting code.&lt;/p&gt;

&lt;p&gt;首先: 我们移动插入点, and &lt;strong&gt;为loop indunction 变量创建PHI node&lt;/strong&gt;. 由于我们已经知道起始值的传入值, 我们将它加入到PHI node 中.&lt;/p&gt;

&lt;p&gt;注意到Phi之后会最终获得备份的第二个值, 但是我们现在还不能set it up yet (因为它目前还不存在!)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Within the loop, the variable is defined equal to the PHI node.  If it
// shadows an existing variable, we have to restore it, so save it now.
Value *OldVal = NamedValues[VarName];
NamedValues[VarName] = Variable;

// Emit the body of the loop.  This, like any other expr, can change the
// current BB.  Note that we ignore the value computed by the body, but don&#39;t
// allow an error.
if (!Body-&amp;gt;codegen())
  return nullptr;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在代码开始变得有趣了,  我在符号表中为&lt;code&gt;for&lt;/code&gt; 循环引入了新的变量. 这意味着: 我们的符号表现在可以包含**函数参数 &lt;strong&gt;或者&lt;/strong&gt;循环变量&lt;strong&gt;. 为了处理这个问题, 在我们为循环体body 进行 codegen之前, 我们在符号表中添加&lt;/strong&gt;该循环变量的名称&lt;strong&gt;以及&lt;/strong&gt;它的当前值**.&lt;/p&gt;

&lt;p&gt;注意: &lt;code&gt;外部作用域可能会有相同的变量名称&lt;/code&gt;. 我们很容易会犯这个错误(就是如果已经存在varName, 我们会采取报错并且返回error这个措施).  &lt;strong&gt;但是我们选择了允许隐藏存在的变量&lt;/strong&gt;. 为了正确的实现该目标, 我们会保存之前存在的varName的值(当然了, 如果之前没有varName的话, 我们会设置它为null).&lt;/p&gt;

&lt;p&gt;一旦将循环变量加入到符号表中之后,  我们就可以&lt;strong&gt;递归地对Body进行Codegen&lt;/strong&gt;. 我们允许&lt;strong&gt;body使用循环变量&lt;/strong&gt;: 我们可以在符号表中找到循环变量, 来实现对它的引用.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Emit the step value.
Value *StepVal = nullptr;
if (Step) {
  StepVal = Step-&amp;gt;codegen();
  if (!StepVal)
    return nullptr;
} else {
  // If not specified, use 1.0.
  StepVal = ConstantFP::get(TheContext, APFloat(1.0));
}

Value *NextVar = Builder.CreateFAdd(Variable, StepVal, &amp;quot;nextvar&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在 the body is emitted,  我们计算迭代器的下一个值. (迭代器的下一个值= 迭代器当前的值+步长; 如果步长未被设置, 默认为 1.0)&lt;/p&gt;

&lt;p&gt;&amp;lsquo;&lt;strong&gt;NextValue&lt;/strong&gt;&amp;lsquo;将会是循环的下一次迭代的迭代器值.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Compute the end condition.
Value *EndCond = End-&amp;gt;codegen();
if (!EndCond)
  return nullptr;

// Convert condition to a bool by comparing non-equal to 0.0.
EndCond = Builder.CreateFCmpONE(
    EndCond, ConstantFP::get(TheContext, APFloat(0.0)), &amp;quot;loopcond&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后, 我们计算循环的退出值,  来决定是否退出循环. 这与 if/then/else 语句的条件值计算是一样的.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Create the &amp;quot;after loop&amp;quot; block and insert it.
BasicBlock *LoopEndBB = Builder.GetInsertBlock();
BasicBlock *AfterBB =
    BasicBlock::Create(TheContext, &amp;quot;afterloop&amp;quot;, TheFunction);

// Insert the conditional branch into the end of LoopEndBB.
Builder.CreateCondBr(EndCond, LoopBB, AfterBB);

// Any new code will be inserted in AfterBB.
Builder.SetInsertPoint(AfterBB);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;随着循环体的代码完成, 我们现在只需要为它完成控制流程. 该代码保存&lt;strong&gt;end block&lt;/strong&gt;(for the phi node), 然后为Loop exit(&amp;ldquo;afterloop&amp;rdquo;)创建 block. 基于退出条件的值, 它创建了一个条件分支来&lt;strong&gt;来在再一次执行循环和退出循环之前选择&lt;/strong&gt;. 任何之后创建的指令都会在 &lt;strong&gt;afterloop block&lt;/strong&gt; 中,  所以我们设置了Builder的插入位置.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  // Add a new entry to the PHI node for the backedge.
  Variable-&amp;gt;addIncoming(NextVar, LoopEndBB);

  // Restore the unshadowed variable.
  if (OldVal)
    NamedValues[VarName] = OldVal;
  else
    NamedValues.erase(VarName);

  // for expr always returns 0.0.
  return Constant::getNullValue(Type::getDoubleTy(TheContext));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后的代码处理各种cleanups: 现在我们有了 &lt;strong&gt;&amp;ldquo;NextVar&amp;rdquo; 值&lt;/strong&gt;, 我们可以将&lt;strong&gt;NextVar/LoopEndBB&lt;/strong&gt;添加到 Loop PHI node中. 在这之后, 我们从符号表中移除循环变量. 所以 for 循环完成之后, 它就不在作用域中了. 最后, for 循环的代码产生总是返回 0.0, 这就是我们从 ForExprAST::codegen()中返回的内容.&lt;/p&gt;

&lt;p&gt;现在我们总结本教程中 &amp;ldquo;adding control flow to Kaleidoscope&amp;rdquo; 这章.&lt;/p&gt;

&lt;p&gt;在本章, 我们增加了两个控制流结构, 通过实现我们了解到了 LLVM IR 的几个方面 (这些对于编译器前端实现者来说是很重要的).&lt;/p&gt;

&lt;p&gt;在下一章, 我们将会变得更疯狂并且我们会为我们的Kaleidoscope添加用户自定义的运算符.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Kaleidoscope: Adding JIT and Optimizer Support</title>
      <link>https://l0phtg.github.io/post/llvm/kaleidoscope-adding-jit-and-optimizer-support/</link>
      <pubDate>Sat, 13 Apr 2019 15:02:51 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/llvm/kaleidoscope-adding-jit-and-optimizer-support/</guid>
      
        <description>&lt;p&gt;translate from: &lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl04.html&#34;&gt;http://llvm.org/docs/tutorial/LangImpl04.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文介绍使用LLVM Pass对产生的LLVM IR进行优化, 以及为我们的Kaleidoscope添加JIT.&lt;/p&gt;

&lt;div class=&#34;mermaid&#34;&gt;
graph TB

    subgraph call
        funcall(&#34;foo(1);&#34;)
    end

    subgraph expr
        nodeExpr(&#34;1+2;&#34;)
    end
    
    jitAddModule[&#34;JIT中 添加此Module&#34;]
    jitRemoveModule[&#34;JIT中 删除此Module&#34;]
    
    anoCodegen[&#34;执行 匿名函数Codegen&#34;]
    AnonymousCall[&#34;匿名函数包装&#34;]
    optimizeFunc[&#34;执行 Pass优化&#34;]
    nodeExpr --&gt; AnonymousCall
    funcall --&gt; AnonymousCall
    AnonymousCall --&gt; anoCodegen
    anoCodegen --&gt; jitAddModule
    jitAddModule --&gt; optimizeFunc
    optimizeFunc --&gt; exec[&#34;JIT 运行此表达式, 并计算值&#34;]
    exec --&gt; jitRemoveModule
    
    subgraph func definition
        nodeFoo(&#34;def foo(x) x+1;&#34;)
        funcCodegen[&#34;执行 函数定义Codegen&#34;]
        nodeFoo --&gt; funcCodegen
    end
    
    funcCodegen --&gt; jitAddFuncModule[&#34;JIT中 添加此Module&#34;]
    jitAddFuncModule --&gt; initPassManager[&#34;执行 Pass优化&#34;]


    subgraph extern
        nodeExtern(&#34;extern sin(x);&#34;)
        protoCodegen[&#34;执行 函数申明Codegen&#34;]
        nodeExtern --&gt; protoCodegen
    end
    
    style jitAddModule fill:#f9f
    style jitRemoveModule fill:#f9f
    style jitAddFuncModule fill:#f9f
    
    style optimizeFunc fill:#ccff66
    style initPassManager fill:#ccff66
    
    style exec fill:#ff3300
    

&lt;/div&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;本章主要介绍了两个部分:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用Pass对LLVM IR进行优化.&lt;/li&gt;
&lt;li&gt;利用JIT. 处理顶级表达式和函数调用. 使他们 eveluate a value.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了实现这个目的, 我们需要实现这几个功能:&lt;/p&gt;

&lt;p&gt;a. 创建PassManager来对Pass进行管理.&lt;/p&gt;

&lt;p&gt;b. 为了可以通过FunctionPassManager来对顶级表达式做优化, 我们将每个顶级表达式都视为一个匿名函数. 并将每一个匿名函数作为一个module单独在JIT中处理, 计算完后在JIT中移除该module.&lt;/p&gt;

&lt;p&gt;c. 为了不在jit处理顶级函数调用表达式时移除我们定义的函数. 我们将每个定义的函数都放在一个单独的jit module中.&lt;/p&gt;

&lt;h1 id=&#34;chapter-4-介绍&#34;&gt;Chapter 4 介绍&lt;/h1&gt;

&lt;p&gt;Welcome to Chapter 4 of the &amp;ldquo;Implementing an language with LLVM&amp;rdquo; tutorial. Chapter 1-3 描述了一个简单语言的实现并且为产生LLVM IR添加了支持.&lt;/p&gt;

&lt;p&gt;本章描述两个新的技术: &lt;strong&gt;添加优化支持 to your language&lt;/strong&gt;, 和 &lt;strong&gt;添加JIT编译支持&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;这些新增的内容将会展示如何为Kaleidoscope提供更nice, efficient code.&lt;/p&gt;

&lt;h1 id=&#34;trivial-constant-folding&#34;&gt;Trivial Constant Folding&lt;/h1&gt;

&lt;p&gt;我们在第三章的展示是优雅的, 并且很容易扩展. 不幸地是, 它不能产生优秀的代码. The IR Builder, 当编译代码的时候, 它确实给了我们很明显的优化.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;ready&amp;gt; def test(x) 1+2+x;
Read function definition:
define double @test(double %x) {
entry:
        %addtmp = fadd double 3.000000e+00, %x
        ret double %addtmp
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码不是根据字面的AST直接转换的.&lt;/p&gt;

&lt;p&gt;如果按照输入的表达式字面值进行生成 IR, 应该是下面这样.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;ready&amp;gt; def test(x) 1+2+x;
Read function definition:
define double @test(double %x) {
entry:
        %addtmp = fadd double 2.000000e+00, 1.000000e+00
        %addtmp1 = fadd double %addtmp, %x
        ret double %addtmp1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;常量折叠&lt;/strong&gt;, 正如我们上面看到的. 这是一个非常普遍的和非常重要的优化: 以至于许多语言的实现者在其AST表示中就已经实现了常量折叠.&lt;/p&gt;

&lt;p&gt;在LLVM中, 你&lt;code&gt;不需要在AST中支持常量折叠&lt;/code&gt;. 由于所有build LLVM IR的调用都是通过LLVM IRBuilder, 当你调用它的时候, &lt;code&gt;Builder会自动检查是否可以进行常量折叠&lt;/code&gt;. 如果可以进行常量折叠, 它会直接进行操作并且返回一个常量而不是一条指令.&lt;/p&gt;

&lt;p&gt;Well, that was easy. 在实践中, 当产生像上面这样的代码的时候,  我们推荐使用&lt;strong&gt;IRBuilder&lt;/strong&gt;. 它的使用没有语法开销(你不需要在任何地方执行常量检查, 这将会使你的编译器很丑陋). 并且它在一些情况下, 会大大减少LLVM IR的数量.(特别是对于有大量&lt;strong&gt;宏的预处理&lt;/strong&gt;or &lt;strong&gt;很多常量的使用&lt;/strong&gt;)&lt;/p&gt;

&lt;p&gt;在另一方面, IRBuilder被以下事实所限制 that 它在构建代码时将所有的分析与代码内联.&lt;/p&gt;

&lt;p&gt;如果你执行一个稍微复杂的例子:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ready&amp;gt; def test(x) (1+2+x)*(x+(1+2));
ready&amp;gt; Read function definition:
define double @test(double %x) {
entry:
        %addtmp = fadd double 3.000000e+00, %x
        %addtmp1 = fadd double %x, 3.000000e+00
        %multmp = fmul double %addtmp, %addtmp1
        ret double %multmp
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在该情况下, LHS和RHS 是相同的值.&lt;/p&gt;

&lt;p&gt;我们其实是希望产生下面这样的 IR:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tmp = x + 3;       
result = tmp * tmp; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来代替 执行&amp;rdquo;&lt;strong&gt;x+3&lt;/strong&gt;&amp;ldquo;两次.&lt;/p&gt;

&lt;p&gt;不幸地是, 没有大量的本地分析能够检测并纠正这一点. 这需要两个转换:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;表达式的重新转换(to make the add&amp;rsquo;s lexically identical).&lt;/li&gt;
&lt;li&gt;公共的子表达式删除(CES) 来 删除冗余的添加指令.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;幸运的是, &lt;code&gt;LLVM 提供大量的优化来供你使用,所有的优化以&amp;quot;passes&amp;quot;的形式存在&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;llvm-optimization-passes&#34;&gt;LLVM Optimization Passes&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;Due to the transition to the new PassManager infrastructure this tutorial is based on llvm::legacy::FunctionPassManager which can be found in LegacyPassManager.h. For the purpose of the this tutorial the above should be used until the pass manager transition is complete.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;LLVM 提供了很多优化passes, 它可以做执行很多不同类型的操作并具有不同的权衡. 不像其他的系统一样, LLVM并不认为一组优化可以对所有语言和所有的情景适用. LLVM允许编译器实现者决定要使用什么样的优化, 按怎样的顺序, 或者在什么情景下.&lt;/p&gt;

&lt;p&gt;作为一个具体的例子, LLVM 支持 &amp;ldquo;&lt;strong&gt;whole module passes&lt;/strong&gt;&amp;rdquo;, which它看起来像很大的代码 (经常是整个文件, but 如果运行在链接时, 这可能是整个项目中的重要的一部分). 它也支持并包含&amp;rdquo;pre-function&amp;rdquo; passes which 一次操作一个函数, without looking at other function.&lt;/p&gt;

&lt;p&gt;想要了解更多关于pass的信息以及他们是怎么样运行的. see &lt;a href=&#34;http://llvm.org/docs/WritingAnLLVMPass.html&#34;&gt;Write An LLVM PASS&lt;/a&gt;文档和&lt;a href=&#34;http://llvm.org/docs/Passes.html&#34;&gt;List of LLVM Passes&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;对于Kaleidoscope来说, 我们目前正在动态生成函数, 一次一个. 当用户输入它们时. We aren&amp;rsquo;t shooting for the ultimate optimization experience in this setting, 但是我们也更想更快的抓住简单快捷的东西. 因此, 当用户输入时, 我们将会选择为每个函数都进行优化. 如果我们想要做一个&amp;rdquo;static Kaleidoscope compiler&amp;rdquo;, 我们将正常使用我们现在有的代码, 除了把优化推迟到整个文件被解析之后.&lt;/p&gt;

&lt;p&gt;为了让每个函数都进行优化, 我们需要设置一个&lt;strong&gt;&lt;a href=&#34;http://llvm.org/docs/WritingAnLLVMPass.html#what-passmanager-doesr&#34;&gt;FunctionPassManager&lt;/a&gt;&lt;/strong&gt;来hold and organize 我们想要运行的LLVM 优化. 一旦我们有了这个, 我们就可以添加一组优化来执行. 对于每个我们想要优化的模块, 我们都需要一个&lt;strong&gt;FunctionPassManager&lt;/strong&gt;, 所以我们将会写一个函数来创建并且初始化我们的&lt;strong&gt;module&lt;/strong&gt;和&lt;strong&gt;pass manager&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void InitializeModuleAndPassManager(void) {
  // Open a new module. 打开一个新的module
  TheModule = llvm::make_unique&amp;lt;Module&amp;gt;(&amp;quot;my cool jit&amp;quot;, TheContext);

  // Create a new pass manager attached to it. 创建一个新的pass manager并且关联到我们的module中
  TheFPM = llvm::make_unique&amp;lt;FunctionPassManager&amp;gt;(TheModule.get());

  // Do simple &amp;quot;peephole&amp;quot; optimizations and bit-twiddling optzns.
  TheFPM-&amp;gt;add(createInstructionCombiningPass());
  // Reassociate expressions.	重新关联表达式
  TheFPM-&amp;gt;add(createReassociatePass());
  // Eliminate Common SubExpressions.	消除公共的子表达式
  TheFPM-&amp;gt;add(createGVNPass());
  // Simplify the control flow graph (deleting unreachable blocks, etc). 简化控制流(例如: 删除到达不了的blocks)
  TheFPM-&amp;gt;add(createCFGSimplificationPass());

  TheFPM-&amp;gt;doInitialization();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该代码初始化全局module &lt;strong&gt;TheModule&lt;/strong&gt;, 和函数pass manager &lt;strong&gt;TheFPM&lt;/strong&gt;(which attached to TheModule). 一旦pass manager 被 set up, 我们使用一系列&amp;rdquo;&lt;strong&gt;add&lt;/strong&gt;&amp;ldquo;调用来加入 &lt;strong&gt;一堆LLVM passes&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;在这个例子中, 我们选择增加四个优化passes. 我们这里选择的pass是一组相当标准的&amp;rdquo;&lt;strong&gt;cleanup&lt;/strong&gt;&amp;rdquo; 优化 (对大多数代码都是适用的). 我不会深挖它们的实现, 请相信我, they are a good starting place :)&lt;/p&gt;

&lt;p&gt;一旦PassManager被 set up, 我们就需要使用它.    在我们的新函数被构造之后(in FunctionAST::codegen()), 在 returned to the client之前, we do this by running it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;if (Value *RetVal = Body-&amp;gt;codegen()) {
  // Finish off the function.
  Builder.CreateRet(RetVal);

  // Validate the generated code, checking for consistency.
  verifyFunction(*TheFunction);

  // Optimize the function.
  TheFPM-&amp;gt;run(*TheFunction);

  return TheFunction;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正如你看到的, 这是相当直接的. The &lt;strong&gt;FunctionPassManager&lt;/strong&gt;优化并更新LLVM Funtion* in place, 改进他们的body.&lt;/p&gt;

&lt;p&gt;有了这个, 我们可以再次尝试我们的test:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;ready&amp;gt; def test(x) (1+2+x)*(x+(1+2));
ready&amp;gt; Read function definition:
define double @test(double %x) {
entry:
        %addtmp = fadd double %x, 3.000000e+00
        %multmp = fmul double %addtmp, %addtmp
        ret double %multmp
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正如我们期待的,  我们现在得到了不错的, 优化后的代码, 这个函数的每次运行都只有一个浮点add指令.&lt;/p&gt;

&lt;p&gt;LLVM 提供了大量的优化, 可以被用在当前的情况下. &lt;code&gt;Some [pass文档](http://llvm.org/docs/Passes.html)可以获得&lt;/code&gt;, 但是那不是全部.  另一个不错的想法是: &lt;code&gt;可以阅读clang启动时运行的pass&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;The **opt** 允许你从命令行来对pass进行测试&lt;/code&gt;, 所以你可以看看它到底做了些什么.&lt;/p&gt;

&lt;p&gt;现在我们的前端代码已经很NB了, let&amp;rsquo;s talk about executing it!&lt;/p&gt;

&lt;h1 id=&#34;adding-a-jit-compiler&#34;&gt;Adding a JIT Compiler&lt;/h1&gt;

&lt;p&gt;LLVM IR中提供的代码可以应用各种工具. 例如, 你可以对它进行优化(as we did above), 你能dump it out in 文本或者二进制格式, 你可以编译代码到 assembly file(.s) for some target, 或者你能够JIT compiler it.&lt;/p&gt;

&lt;p&gt;LLVM IR表示的好处是: 它是在编译器中, 许多不同部分的&amp;rdquo;common currency&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;在本节, &lt;strong&gt;我们将会为我们的解释器添加JIT支持&lt;/strong&gt;. 添加JIT基本思想是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我们想要现在这样用户输入函数体, 但是就要立刻计算他们输入的顶级表达式. 例如, 如果他们输入 &amp;ldquo;1+2&amp;rdquo;,  我们应该 &lt;strong&gt;立即让他输出&lt;/strong&gt; 3.&lt;/li&gt;
&lt;li&gt;如果他们定义了一个函数, 他们应该能够被&lt;strong&gt;从命令行上被调用&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了做这个, 我们首先要准备环境来为本机目标创建代码并申明和初始化JIT. 这可以通过调用 &lt;code&gt;InitializeNativeTarget*&lt;/code&gt; 函数来做, 并且添加一个JIT的全局变量, 并在main中初始化:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;static std::unique_ptr&amp;lt;KaleidoscopeJIT&amp;gt; TheJIT;
...
int main() {
  InitializeNativeTarget();
  InitializeNativeTargetAsmPrinter();
  InitializeNativeTargetAsmParser();

  // Install standard binary operators.
  // 1 is lowest precedence.
  BinopPrecedence[&#39;&amp;lt;&#39;] = 10;
  BinopPrecedence[&#39;+&#39;] = 20;
  BinopPrecedence[&#39;-&#39;] = 20;
  BinopPrecedence[&#39;*&#39;] = 40; // highest.

  // Prime the first token.
  fprintf(stderr, &amp;quot;ready&amp;gt; &amp;quot;);
  getNextToken();

  TheJIT = llvm::make_unique&amp;lt;KaleidoscopeJIT&amp;gt;();

  // Run the main &amp;quot;interpreter loop&amp;quot; now.
  MainLoop();

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们还需要为JIT设置data layout(数据布局):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void InitializeModuleAndPassManager(void) {
  // Open a new module.
  TheModule = llvm::make_unique&amp;lt;Module&amp;gt;(&amp;quot;my cool jit&amp;quot;, TheContext);
  TheModule-&amp;gt;setDataLayout(TheJIT-&amp;gt;getTargetMachine().createDataLayout());

  // Create a new pass manager attached to it.
  TheFPM = llvm::make_unique&amp;lt;FunctionPassManager&amp;gt;(TheModule.get());
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kaleidoscope JIT类是一个专门为这个tutorial构建的simple JIT, 可以在 &lt;code&gt;llvm-src/examples/Kaleidoscope/include/Kaleidoscope.h&lt;/code&gt;这里找到. 在之后的章节, 我们将会看到它是怎么样工作的并且给它扩展一些新特性, 但是现在我们假设它是直接给定的.&lt;/p&gt;

&lt;p&gt;它的API 是非常简单的:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;addModule&lt;/strong&gt; 会在JIT中增加一个LLVM IR module, 使其功能是可以执行的;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;removeModule&lt;/strong&gt;会移除一个module, 释放在这个模块中与之相关联的代码;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;findSymbol&lt;/strong&gt;允许我们查找编译代码的指针.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们可以改变我们的解析顶级表达式的代码, 在其中添加对这几个简单API的调用.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;static void HandleTopLevelExpression() {
  // Evaluate a top-level expression into an anonymous function. 将顶级表达式计算为匿名函数
  if (auto FnAST = ParseTopLevelExpr()) {
    if (FnAST-&amp;gt;codegen()) {

      // JIT the module containing the anonymous expression, keeping a handle so
      // we can free it later.
      auto H = TheJIT-&amp;gt;addModule(std::move(TheModule));
      InitializeModuleAndPassManager();

      // Search the JIT for the __anon_expr symbol.
      auto ExprSymbol = TheJIT-&amp;gt;findSymbol(&amp;quot;__anon_expr&amp;quot;);
      assert(ExprSymbol &amp;amp;&amp;amp; &amp;quot;Function not found&amp;quot;);

      // Get the symbol&#39;s address and cast it to the right type (takes no
      // arguments, returns a double) so we can call it as a native function.
      // 得到symbol的地址, 并且将它转换为正确的类型(无参数, 返回值为double类型)
      double (*FP)() = (double (*)())(intptr_t)ExprSymbol.getAddress();
      fprintf(stderr, &amp;quot;Evaluated to %f\n&amp;quot;, FP());

      // Delete the anonymous expression module from the JIT.
      TheJIT-&amp;gt;removeModule(H);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果&lt;strong&gt;parsing&lt;/strong&gt; and &lt;strong&gt;codegen&lt;/strong&gt; 成功, 下一步是将包含顶级表达式的module添加到JIT. 我们通过调用&lt;strong&gt;addModule&lt;/strong&gt;来 do this, 调用addModule会触发对此module中的所有函数进行codegen,  并且返回一个handle(在之后删除此module时会用到). 一旦module已经被加到JIT中, 它不再被修改,  所以现在我们可以调用&lt;strong&gt;InitializeModuleAndPassManager()&lt;/strong&gt;来打开一个module, 以便于hold subsequent code (后续的代码).&lt;/p&gt;

&lt;p&gt;一旦我们将模块添加到JIT中, 我们需要获得指向最终生成代码的指针. 我们通过调用JIT&amp;rsquo;s &lt;strong&gt;findSymbol&lt;/strong&gt;方法来做这个, and 传递顶级表达式的名称: &lt;strong&gt;__anon_expr&lt;/strong&gt;. 由于我们刚刚添加了这个函数, 所以我们确定findSymbol一定会返回结果.&lt;/p&gt;

&lt;p&gt;下一步, 我们通过调用&lt;strong&gt;getAddress()&lt;/strong&gt;on the symbol来获取&lt;strong&gt;__anoy_expr&lt;/strong&gt;函数的内存地址. 回想一下, 我们将顶级表达式编译为一个 self-contained LLVM function(不带参数, 并且返回double). 因为 LLVM JIT 编译器匹配本地平台的ABI, 这意味着你可以将结果指针强制转换为该类型的函数指针并调用它. This means, JIT编译的代码和静态链接到应用程序的本地机器码没有区别.&lt;/p&gt;

&lt;p&gt;最终, 由于我们不支持 re-evaluation 顶级表达式, 当我们完成时, 我们从JIT中移除该module来释放相关的内存.&lt;/p&gt;

&lt;p&gt;回忆一下 , 我们之前创建的几行代码(&lt;strong&gt;InitializeModuleAndPassManager&lt;/strong&gt;)  is still open and waiting for new code to be added.(????)&lt;/p&gt;

&lt;p&gt;With just these two changes, let&amp;rsquo;s see Kaleidoscope works how!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;ready&amp;gt; 4+5;
Read top-level expression:
define double @0() {
entry:
  ret double 9.000000e+00
}

Evaluated to 9.000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这看起来基本是有效的, The dump of the function展示了&amp;rdquo;没有参数并总是返回double类型&amp;rdquo;, we synthesize for 每一个输入的顶级表达式.&lt;/p&gt;

&lt;p&gt;这展示了最基本的功能, 但是我们还可以如何做更多呢?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;ready&amp;gt; def testfunc(x y) x + y*2;
Read function definition:
define double @testfunc(double %x, double %y) {
entry:
  %multmp = fmul double %y, 2.000000e+00
  %addtmp = fadd double %multmp, %x
  ret double %addtmp
}

ready&amp;gt; testfunc(4, 10);		#注意: 由于此刻testfunc的函数定义与testfunc的函数调用的匿名表达式在同一个module, 所以此刻调用testfunc之后会删除testfunc的函数定义.
Read top-level expression:
define double @1() {
entry:
  %calltmp = call double @testfunc(double 4.000000e+00, double 1.000000e+01)
  ret double %calltmp
}

Evaluated to 24.000000

ready&amp;gt; testfunc(5, 10);
ready&amp;gt; LLVM ERROR: Program used external function &#39;testfunc&#39; which could not be resolved!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数定义和调用都正常工作了, 但是最后一行出现了一点问题. 该调用看起来是有效的, so what happened?&lt;/p&gt;

&lt;p&gt;正如你从API看到的那样, module是JIT分配的单元, and &lt;strong&gt;testfunc&lt;/strong&gt;是相同的module中的一部分(它包含匿名表达式). 当我们从JIT中移除module以便于释放匿名表达式的内存时, 我们&lt;strong&gt;删除了testfunc的定义&lt;/strong&gt;. 然后, 当我们试图调用第二次调用testfunc时, JIT找不到该函数的定义.&lt;/p&gt;

&lt;p&gt;最简单的fix this的方法是: &lt;code&gt;将匿名表达式放在与函数定义不同的module中&lt;/code&gt;. 只要每个被调用的函数都有一个原型, JIT很乐意解决跨模块边界的函数调用, 并在调用之前添加到JIT中. 通过把匿名表达式放到不同的module下, 我们可以删除它并且不影响其他的函数.&lt;/p&gt;

&lt;p&gt;事实上, 我们将更进一步, 将每个函数放到它自己的module中. 这样做可以允许我们利用KaileidoscopeJIT的有用的属性 that (will 使我们的环境更REPL-like: 函数能够被多次添加到JIT中)(与每个函数一定有一个定义的模块不同).&lt;/p&gt;

&lt;p&gt;当你在KaleidoscopeJIT中查找符号时, 它将返回最新的定义:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;ready&amp;gt; def foo(x) x + 1;
Read function definition:
define double @foo(double %x) {
entry:
  %addtmp = fadd double %x, 1.000000e+00
  ret double %addtmp
}

ready&amp;gt; foo(2);
Evaluated to 3.000000

ready&amp;gt; def foo(x) x + 2;
define double @foo(double %x) {
entry:
  %addtmp = fadd double %x, 2.000000e+00
  ret double %addtmp
}

ready&amp;gt; foo(2);
Evaluated to 4.000000

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了让每个函数都存在自己的模块中, 我们需要一个方法来re-generate以前的函数声明到每个我们打开的新模块中:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt; static std::unique_ptr&amp;lt;KaleidoscopeJIT&amp;gt; TheJIT;

...

Function *getFunction(std::string Name) {
  // First, see if the function has already been added to the current module.
  // 首先, 观察是否函数已经被添加到当前module中.
  if (auto *F = TheModule-&amp;gt;getFunction(Name))
    return F;

  // If not, check whether we can codegen the declaration from some existing
  // prototype.
  // if not, 检查是否我们可以codegen
  auto FI = FunctionProtos.find(Name);
  if (FI != FunctionProtos.end())
    return FI-&amp;gt;second-&amp;gt;codegen();

  // If no existing prototype exists, return null.
  return nullptr;
}
...

Value *CallExprAST::codegen() {
  // Look up the name in the global module table.
  Function *CalleeF = getFunction(Callee);

...

Function *FunctionAST::codegen() {
  // Transfer ownership of the prototype to the FunctionProtos map, but keep a
  // reference to it for use below.
  auto &amp;amp;P = *Proto;
  FunctionProtos[Proto-&amp;gt;getName()] = std::move(Proto);
  Function *TheFunction = getFunction(P.getName());
  if (!TheFunction)
    return nullptr;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了实现这个目的, 我们首先会添加一个新的全局变量: &lt;strong&gt;FunctionProtos&lt;/strong&gt;,  它包含每个函数的最新声明.  我们将添加一个方便的方法, &lt;strong&gt;getFunction()&lt;/strong&gt;, 来替换对&lt;strong&gt;TheModule-&amp;gt;getFunction()&lt;/strong&gt;的调用. 我们的便利的方法在TheModule中搜索现有的存在的函数声明, 如果找不到函数声明, 则回退到从FunctionProtos生成一个新的声明.  In &lt;strong&gt;CallExprAST::codegen()&lt;/strong&gt; 我们 just 需要替换对TheModule-&amp;gt;getFunction()的调用. 在&lt;strong&gt;FunctionAST::codegen()&lt;/strong&gt;中, 我们首先需要更新&lt;strong&gt;FunctionProtos map&lt;/strong&gt;, 然后调用 &lt;strong&gt;getFunction()&lt;/strong&gt;. 通过这样做, 我们总是可以在当前module中获得任何以前声明的函数的函数声明.&lt;/p&gt;

&lt;p&gt;我们也需要更新 &lt;strong&gt;HandleDefinition&lt;/strong&gt; and &lt;strong&gt;HandleExtern&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt; static void HandleDefinition() {
  if (auto FnAST = ParseDefinition()) {
    if (auto *FnIR = FnAST-&amp;gt;codegen()) {
      fprintf(stderr, &amp;quot;Read function definition:&amp;quot;);
      FnIR-&amp;gt;print(errs());
      fprintf(stderr, &amp;quot;\n&amp;quot;);
      TheJIT-&amp;gt;addModule(std::move(TheModule));
      InitializeModuleAndPassManager();
    }
  } else {
    // Skip token for error recovery.
     getNextToken();
  }
}

static void HandleExtern() {
  if (auto ProtoAST = ParseExtern()) {
    if (auto *FnIR = ProtoAST-&amp;gt;codegen()) {
      fprintf(stderr, &amp;quot;Read extern: &amp;quot;);
      FnIR-&amp;gt;print(errs());
      fprintf(stderr, &amp;quot;\n&amp;quot;);
      FunctionProtos[ProtoAST-&amp;gt;getName()] = std::move(ProtoAST);
    }
  } else {
    // Skip token for error recovery.
    getNextToken();
  }
}
 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在HandleDefinition中, 我们添加了两行代码来将定义的函数传递给JIT, 并打开一个new module. In HandleExtern, 我们只需要添加一行来增加函数原型到&lt;strong&gt;FunctionProtos&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;在做了这些改变之后, 让我们再次尝试我的REPL (这次我删除了匿名函数的dump, you should get the idea by now :):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;ready&amp;gt; def foo(x) x + 1;
ready&amp;gt; foo(2);
Evaluated to 3.000000

ready&amp;gt; def foo(x) x + 2;
ready&amp;gt; foo(2);
Evaluated to 4.000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即使这些功能很简单, 我们也可以得到surprisingly powerful capbilities - check this out:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;ready&amp;gt; extern sin(x);
Read extern:
declare double @sin(double)

ready&amp;gt; extern cos(x);
Read extern:
declare double @cos(double)

ready&amp;gt; sin(1.0);
Read top-level expression:
define double @2() {
entry:
  ret double 0x3FEAED548F090CEE
}

Evaluated to 0.841471

ready&amp;gt; def foo(x) sin(x)*sin(x) + cos(x)*cos(x);
Read function definition:
define double @foo(double %x) {
entry:
  %calltmp = call double @sin(double %x)
  %multmp = fmul double %calltmp, %calltmp
  %calltmp2 = call double @cos(double %x)
  %multmp4 = fmul double %calltmp2, %calltmp2
  %addtmp = fadd double %multmp, %multmp4
  ret double %addtmp
}

ready&amp;gt; foo(4.0);
Read top-level expression:
define double @3() {
entry:
  %calltmp = call double @foo(double 4.000000e+00)
  ret double %calltmp
}

Evaluated to 1.000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;whoa, JIT是怎么知道 &lt;strong&gt;sin&lt;/strong&gt;和 &lt;strong&gt;cos&lt;/strong&gt;的呢?&lt;/p&gt;

&lt;p&gt;答案是相当简单的: The kaleidoscopeJIT 有一个直接的符号解析规则, 用于查找当前给定模块中不可用的符号:  首先它搜索添加到JIT中的所有模块, 从最新的到以前的为了找到最新的定义. 如果JIT中找不到定义, 它将会在自身进程上运行 &amp;ldquo;dlsym(sin)&amp;rdquo;. 由于 &amp;ldquo;&lt;strong&gt;sin&lt;/strong&gt;&amp;ldquo;是在JIT的地址空间中定义的, 它只是简单的patches up calls 在模块中, 以直接调用到libm版本的sin.&lt;/p&gt;

&lt;p&gt;但是在某些情况下,  这甚至会做更多: 正如 &lt;strong&gt;sin&lt;/strong&gt;和 &lt;strong&gt;cos&lt;/strong&gt; 是标准的数学函数, 当我们使用 &lt;strong&gt;sin(1.0)&lt;/strong&gt;进行常量调用时, the constant folder会直接计算调用的结果.&lt;/p&gt;

&lt;p&gt;在未来, 我们将会看到如何调整符号解析规则以启用各种有用的特性,  &lt;strong&gt;from security (限制JIT代码可以使用的符号集合), to基于符号名称的动态代码执行, and even lazy complication&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;符号解析规则的一个好处是: 我们可以通过写任意的c++代码来扩展语言.&lt;/p&gt;

&lt;p&gt;For example, if we add:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#ifdef _WIN32
#define DLLEXPORT __declspec(dllexport)
#else
#define DLLEXPORT
#endif

/// putchard - putchar that takes a double and returns 0.
extern &amp;quot;C&amp;quot; DLLEXPORT double putchard(double X) {
  fputc((char)X, stderr);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意: 对于 windows, 我们实际上需要导出函数, 因为dynamic symbol loader将会使用&lt;strong&gt;GetProcAddress&lt;/strong&gt;来寻找symbol.&lt;/p&gt;

&lt;p&gt;现在我们可以通过输入: &amp;ldquo;extern putchard(x); putchard(20);&amp;rdquo; 产生简单的输出到控制台上. 类似的代码可以被用来实现 I/O, 控制台输入, 和其他许多Kaleidoscope的特性.&lt;/p&gt;

&lt;p&gt;这就是JIT和优化器的教程.&lt;/p&gt;

&lt;p&gt;此时, 我们能够编译一个非图灵完备的编程语言, 优化并且JIT编译它 in a user-driver way.&lt;/p&gt;

&lt;p&gt;接下来我们会研究使用控制流构造来扩展语言, 解决一些有趣的LLVM IR问题.&lt;/p&gt;

&lt;h1 id=&#34;full-code-list&#34;&gt;Full Code List&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl04.html#adding-a-jit-compiler&#34;&gt;http://llvm.org/docs/tutorial/LangImpl04.html#adding-a-jit-compiler&lt;/a&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Kaleidoscope: Code Generation to LLVM IR</title>
      <link>https://l0phtg.github.io/post/llvm/kaleidoscope-code-generation-to-llvm-ir/</link>
      <pubDate>Fri, 12 Apr 2019 16:55:05 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/llvm/kaleidoscope-code-generation-to-llvm-ir/</guid>
      
        <description>&lt;p&gt;translate from: &lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl03.html&#34;&gt;http://llvm.org/docs/tutorial/LangImpl03.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;介绍四个基本表达式和函数申明与定义的Codegen.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/docs-pic/llvm/Codegen.png&#34; alt=&#34;codegen .png&#34; /&gt;
&lt;/p&gt;

&lt;h1 id=&#34;3-1-chapter-3-introduction&#34;&gt;3.1 Chapter 3 Introduction&lt;/h1&gt;

&lt;p&gt;本章将会向你介绍如何转换为AST. built in Chapter2, into LLVM IR. 这将会教给你a little bit about LLVM是如何做这个的. 以及展示它的实用性. 构建一个词法分析器和解析器要比生成LLVM IR代码的工作多得多.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;please note&lt;/strong&gt;: 本章和之后的代码是基于LLVM 3.7 and later. LLVM 3.6 和之前的版本将不会工作for this code. 也要注意, 你需要一个匹配你的LLVM Release版本的tutorial.&lt;/p&gt;

&lt;h1 id=&#34;3-2-code-generation-setup&#34;&gt;3.2 Code Generation Setup&lt;/h1&gt;

&lt;p&gt;为了产生LLVM IR, 我们想要一些简单的setup来start. 首先我们定义virtual code generation(codegen)方法在每一个AST类中.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// ExprAST - Base class for all expression nodes.
class ExprAST {
public:
  virtual ~ExprAST() {}
  virtual Value *codegen() = 0;
};

/// NumberExprAST - Expression class for numeric literals like &amp;quot;1.0&amp;quot;.
class NumberExprAST : public ExprAST {
  double Val;

public:
  NumberExprAST(double Val) : Val(Val) {}
  virtual Value *codegen();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;codegen()表示为AST节点依赖它们来产生IR , 并且他们都返回一个&lt;strong&gt;Value&lt;/strong&gt;对象(被用来表示&amp;rdquo;Static Single Assigment(SSA) register&amp;rdquo; or &amp;ldquo;SSA value&amp;rdquo;in LLVM).&lt;/p&gt;

&lt;p&gt;SSA值的最独特的方面是当相关指令执行时, 他们的值被计算. 并且在指令再次执行之前, 它不会获得新值. 换句话说, 没有方法来改变SSA值. 为了了解更多关于SSA的信息, please read up on &lt;a href=&#34;https://l0phtg.github.io/post/llvm/static-single-assignment/&#34;&gt;Static Single Assignment&lt;/a&gt; - 一旦你理解了它, the concepts are really quite natural.&lt;/p&gt;

&lt;p&gt;请注意, 不是将虚方法添加到ExprAST的类层次结构中, 使用访问者模式或者其他方式对此进行建模也是有意义的.&lt;/p&gt;

&lt;p&gt;Again, 本教程将不再讨论良好的软件工程实践: 出于我们的目的, 添加虚拟方法是最简单的.&lt;/p&gt;

&lt;p&gt;我们想要的第二件事情, 是像我们在编写解析器时那样, 当发生错误时报告error. (例如, 对一个未声明参数的使用).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;static LLVMContext TheContext;
static IRBuilder&amp;lt;&amp;gt; Builder(TheContext);
static std::unique_ptr&amp;lt;Module&amp;gt; TheModule;
static std::map&amp;lt;std::string, Value *&amp;gt; NamedValues;

Value *LogErrorV(const char *Str) {
  LogError(Str);
  return nullptr;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在代码产生阶段, 静态变量将会被使用. TheContext 是一个掌握了大量的核心LLVM data 结构不透明的对象, 例如the type and 常量value tables. 我们不必关注它的细节, 我们仅仅需要一个简单的实例, 直接将它传到我们需要的API中即可.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;Builder object&lt;/strong&gt; 帮助我们使产生IR这件事变得很容易. &lt;strong&gt;IRBuilder&lt;/strong&gt;类的实例模板来&lt;strong&gt;跟踪当前插入指令的位置&lt;/strong&gt;并且&lt;strong&gt;提供创建新指令的方法&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TheModule&lt;/strong&gt; 是一个LLVM construct(包含函数和全局变量). In many ways, 它是一个LLVM IR用于包含代码的顶级结构.它将会掌控我们产生的IR的内存 (这就是为什么 codegen() method返回一个&lt;strong&gt;raw value&lt;/strong&gt;*, 而不是&lt;strong&gt;unique_ptr&lt;Value&gt;&lt;/strong&gt;).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The NamedValues map&lt;/strong&gt; 会跟踪&lt;strong&gt;当前作用域&lt;/strong&gt;中&lt;strong&gt;定义的值&lt;/strong&gt;以及它们的LLVM表示形式. (换句话说, 它是代码的符号表). &lt;code&gt;在 Kaleidoscope的形式中, 能被引用的唯一的things 是函数参数. 因此, 当为函数体进行Codegen时, 函数参数将会存在于该map中&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;有了这些基础知识, 我们可以开始讨论如何为每个表达式 generate code. 注意: this 假定已经设置了Builder来生成代码. 现在, 我们假设已经完成了, 我们将会just 用它来emit code.&lt;/p&gt;

&lt;h1 id=&#34;3-3-expression-code-generation&#34;&gt;3.3 Expression Code Generation&lt;/h1&gt;

&lt;p&gt;为每一个表达式产生LLVM code是非常直接的.&lt;/p&gt;

&lt;h2 id=&#34;numexpr&#34;&gt;numExpr&lt;/h2&gt;

&lt;p&gt;First we&amp;rsquo;ll do &lt;strong&gt;numberic literals&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Value *NumberExprAST::codegen() {
  return ConstantFP::get(TheContext, APFloat(Val));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在LLVM IR中, 数字常量用&lt;strong&gt;ConstantFP&lt;/strong&gt;类来表示, (在内部保存APFloat的值)(
APFloat 具有保存任意精度的浮点常数的能力). 这段代码基本就是创建并返回了一个&lt;strong&gt;ConstantFP&lt;/strong&gt;. 注意 在LLVM IR中, 常量都是唯一的, 并且被共享. 出于这个原因, The &lt;strong&gt;API use the &amp;ldquo;foo::(..)&amp;ldquo;而不是 &amp;ldquo;new foo(&amp;hellip;)&amp;rdquo; or &amp;ldquo;foo::Create(..)&amp;rdquo;&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&#34;variableexpr&#34;&gt;VariableExpr&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Value *VariableExprAST::codegen() {
  // Look this variable up in the function.
  Value *V = NamedValues[Name];
  if (!V)
    LogErrorV(&amp;quot;Unknown variable name&amp;quot;);
  return V;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用LLVM对变量的引用也非常简单. 在我们simple Kaleidoscope中, 我们假定变量已经被emitted somewhere 并且它的值是可用的. 实际上,  In the namedValues map 的唯一的值是函数参数. 此代码只是检查指定的name是否在map中. (如果没有, 未知变量将会被引用) 并且返回value for it. 在未来的章节, we&amp;rsquo;ll 将会在符号表和局部变量中增加&lt;strong&gt;Loop Induction variables&lt;/strong&gt; (可以阅读第5章: 对 Loop 进行 codegen的部分).&lt;/p&gt;

&lt;h2 id=&#34;binaryexprast&#34;&gt;BinaryExprAST&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Value *BinaryExprAST::codegen() {
  Value *L = LHS-&amp;gt;codegen();
  Value *R = RHS-&amp;gt;codegen();
  if (!L || !R)
    return nullptr;

  switch (Op) {
  case &#39;+&#39;:
    return Builder.CreateFAdd(L, R, &amp;quot;addtmp&amp;quot;);
  case &#39;-&#39;:
    return Builder.CreateFSub(L, R, &amp;quot;subtmp&amp;quot;);
  case &#39;*&#39;:
    return Builder.CreateFMul(L, R, &amp;quot;multmp&amp;quot;);
  case &#39;&amp;lt;&#39;:
    L = Builder.CreateFCmpULT(L, R, &amp;quot;cmptmp&amp;quot;);
    // Convert bool 0/1 to double 0.0 or 1.0
    return Builder.CreateUIToFP(L, Type::getDoubleTy(TheContext),
                                &amp;quot;booltmp&amp;quot;);
  default:
    return LogErrorV(&amp;quot;invalid binary operator&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二元操作符开始变得有趣.&lt;/p&gt;

&lt;p&gt;这里的基本思想: &lt;code&gt;我们递归地为表达式的左侧emit code, 然后是右侧, 然后我们计算二进制表达式的结果. 在这个代码中, 我们做一个简单的switch on the opcode来创建正确的LLVM 指令&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;在上面的例子中, LLVM Builder类开始显示其值. &lt;strong&gt;IRBuilder知道在哪里插入新创建的指令, 你所做的就是要指定什么指令将会被创建&lt;/strong&gt; (例如, 使用 &lt;strong&gt;CreateFAdd&lt;/strong&gt;), which &lt;strong&gt;使用哪些操作数(L and R here)&lt;/strong&gt; 并且optionally &lt;strong&gt;为生成的指令提供一个名字&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;关于LLVM, 一个不错的事情是名称就像一个提示.  例如, 如果上面的代码emit 多条 &amp;ldquo;addtmp&amp;rdquo; &lt;strong&gt;变量&lt;/strong&gt;, LLVM将自动地为每个变量提供一个递增的, 独特的数字suffix(后缀). 指令的本地值名称purely可选择的, but 它的名称应该要更方便我们阅读.&lt;/p&gt;

&lt;p&gt;LLVM 指令是被严格的规则所限制: For Example, &lt;strong&gt;一个指令的左边和右边的操作符一定要有相同的类型&lt;/strong&gt;, 并且add的&lt;strong&gt;结果类型一定要匹配操作数类型&lt;/strong&gt;. 因为in Kaleidoscope所有的值都是doubles, this makes for very simple code for add, sub, mul.&lt;/p&gt;

&lt;p&gt;在另一方面, LLVM 指定 &lt;strong&gt;fcmp&lt;/strong&gt; 指令总是返回一个 &amp;ldquo;i1&amp;rdquo; 值( 1 比特整型). 问题是 Kaleidoscope希望值是&lt;strong&gt;0.0&lt;/strong&gt;或者&lt;strong&gt;1.0&lt;/strong&gt;. 为了获得这些语义, 我们将&lt;strong&gt;fcmp指令&lt;/strong&gt;与&lt;strong&gt;uitofp指令&lt;/strong&gt;(unsigned integer to float point)结合起来. 该指令通过将它的输入整数转换为浮点值by 将输入视为无符号值. 相反, 如果我们使用&lt;strong&gt;sitofp指令&lt;/strong&gt;, The kaleidoscope &amp;lsquo;&amp;lt;&amp;rsquo; 操作符将会返回&lt;strong&gt;0.0&lt;/strong&gt;和&lt;strong&gt;-1.0&lt;/strong&gt;, 具体依赖于输入值.&lt;/p&gt;

&lt;h2 id=&#34;callexprast&#34;&gt;CallExprAST&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Value *CallExprAST::codegen() {
  // Look up the name in the global module table. 在全局module table中寻找name
  Function *CalleeF = TheModule-&amp;gt;getFunction(Callee);
  if (!CalleeF)
    return LogErrorV(&amp;quot;Unknown function referenced&amp;quot;);

  // If argument mismatch error.
  if (CalleeF-&amp;gt;arg_size() != Args.size())
    return LogErrorV(&amp;quot;Incorrect # arguments passed&amp;quot;);

  std::vector&amp;lt;Value *&amp;gt; ArgsV;
  for (unsigned i = 0, e = Args.size(); i != e; ++i) {
    ArgsV.push_back(Args[i]-&amp;gt;codegen());
    if (!ArgsV.back())
      return nullptr;
  }

  return Builder.CreateCall(CalleeF, ArgsV, &amp;quot;calltmp&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用LLVM来产生函数调用的codegen是相当简单直接的.&lt;/p&gt;

&lt;p&gt;上面的代码最开始会在LLVM Module&amp;rsquo;s 符号表中 寻找函数的名称. 回想一下, LLVM Module是一个可以包含我们正在执行的JIT函数的容器. 通过给每一个函数指定与用户指定的相同的名称, 我们可以使用LLVM 符号表来解析我们的函数名称.&lt;/p&gt;

&lt;p&gt;一旦我们有函数要调用, 我们递归地codegen(编码)每一个我们要传入的参数, 并且创建一个LLVM调用指令. 注意, LLVM默认使用本地的c调用规定, 允许这些调用来调用标准库函数(like &amp;ldquo;sin&amp;rdquo; and &amp;ldquo;cos&amp;rdquo;)是轻松的, 不需要任何额外的工作.&lt;/p&gt;

&lt;p&gt;这包含了我们对四个基本表达式(in Kaileidoscope)的处理. 当然, 你可以随意添加更多. 例如, 通过浏览 &lt;a href=&#34;http://llvm.org/docs/LangRef.html&#34;&gt;LLVM Language reference&lt;/a&gt;. 你将会找到其他一些有趣的指令, 并且将他们加到我们的框架中是非常简单的.&lt;/p&gt;

&lt;h1 id=&#34;3-4-function-code-generation&#34;&gt;3.4 Function Code Generation&lt;/h1&gt;

&lt;p&gt;函数申明和函数定义的代码生成要处理大量的细节, which 这使得它们的代码生成不如expression 的代码生成 漂亮, but 这允许我们说明一些重要的点.&lt;/p&gt;

&lt;h2 id=&#34;prototypeast&#34;&gt;PrototypeAST&lt;/h2&gt;

&lt;p&gt;首先, 我们先讨论函数申明的代码产生: 他们可以用于函数体, 也可以用于外部函数申明.&lt;/p&gt;

&lt;p&gt;The code starts with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Function *PrototypeAST::codegen() {
  // Make the function type:  double(double,double) etc.
  std::vector&amp;lt;Type*&amp;gt; Doubles(Args.size(),
                             Type::getDoubleTy(TheContext));
  FunctionType *FT =
    FunctionType::get(Type::getDoubleTy(TheContext), Doubles, false);

  Function *F =
    Function::Create(FT, Function::ExternalLinkage, Name, TheModule.get());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码将大量的功能集成到几行. First注意, 这个函数返回了一个&amp;rdquo;&lt;strong&gt;Function&lt;/strong&gt;&amp;ldquo;而不是&amp;rdquo;&lt;strong&gt;Value&lt;/strong&gt;&amp;rdquo;. 因为&amp;rdquo;prototype&amp;rdquo;是在讨论函数的外部接口(而不是表达式计算的值), 当codegen时, 返回LLVM Function是有意义的.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FunctionType::get&lt;/strong&gt;的调用创建&lt;strong&gt;FunctionType&lt;/strong&gt;(that 被用于给定的声明). 由于Kaleidoscope中所有的函数参数都是double类型的, 第一行创建了一个&amp;rdquo;N个double类型的vector&amp;rdquo;. 然后使用&lt;strong&gt;FunctionType::get&lt;/strong&gt;创建了接收N个double类型参数的函数. 返回一个double作为结果,(那不是可变参数(false表示这一点)). 注意 LLVM中类型是和常量一样唯一的, 所以你不用&amp;rdquo;new a type&amp;rdquo;, you &amp;ldquo;get&amp;rdquo; it.&lt;/p&gt;

&lt;p&gt;上面的最后一行实际上创建了与Prototype相对应的IR函数. 这表明了要使用的类型, 链接, 名称, 以及要插入的模块. &amp;ldquo;external linkage&amp;rdquo;意味着该函数可能在当前模块之外定义. and or 它能够被模块外面的函数所调用. 传入的名称是用户指定的名称: 由于指定了&amp;rdquo;TheModule&amp;rdquo;, 因此该名称在&amp;rdquo;TheModule&amp;rdquo;符号表中被注册.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Set names for all arguments. 设置所有参数的名称
unsigned Idx = 0;
for (auto &amp;amp;Arg : F-&amp;gt;args())
  Arg.setName(Args[Idx++]);

return F;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后, 我们根据Prototype中的名称设置每个函数参数的名称. 这一步并不是严格需要的, 但是保持名称的一致是IR的可读性更强, 并允许后面的代码直接引用其名称的参数, 而不需要在PrototypeAST中查找他们.&lt;/p&gt;

&lt;h2 id=&#34;functionast&#34;&gt;FunctionAST&lt;/h2&gt;

&lt;p&gt;我们有一个没有函数体的function prototype.  这是LLVM IR表示函数申明的方式. 对于在Kaileidoscope中的extern表达式来说, 这正是我们想要表达的. 然而对于函数定义来说,我们需要codegen并且attach a 函数体:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Function *FunctionAST::codegen() {
    // First, check for an existing function from a previous &#39;extern&#39; declaration.
  Function *TheFunction = TheModule-&amp;gt;getFunction(Proto-&amp;gt;getName());

  if (!TheFunction)
    TheFunction = Proto-&amp;gt;codegen();

  if (!TheFunction)
    return nullptr;

  if (!TheFunction-&amp;gt;empty())
    return (Function*)LogErrorV(&amp;quot;Function cannot be redefined.&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于函数定义来说, 我们首先在TheModule的符号表中搜索此函数的现有版本.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一种case是:using &amp;ldquo;extern&amp;rdquo; 语句时, 符号表就被创建了. 如果 Module::getFunction 返回 null, 则意味着不存在先前的版本, 所以我们就需要根据申明来进行Prototype Codegen.&lt;/li&gt;
&lt;li&gt;在另一种case中, 我们想要在我们开始之前, assert函数是empty(i.e. 还没有函数体)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Create a new basic block to start insertion into.  创建一个新的basic block 来插入.
BasicBlock *BB = BasicBlock::Create(TheContext, &amp;quot;entry&amp;quot;, TheFunction);
Builder.SetInsertPoint(BB);

// Record the function arguments in the NamedValues map. 在NamedValue mao中记录函数参数.
NamedValues.clear();
for (auto &amp;amp;Arg : TheFunction-&amp;gt;args())
  NamedValues[Arg.getName()] = &amp;amp;Arg;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们可以开始建立Builder了:&lt;/p&gt;

&lt;p&gt;第一行创建了一个&lt;strong&gt;new basic block(named &amp;ldquo;entry&amp;rdquo;)&lt;/strong&gt;, 被直接插入到函数中. 第二行告诉我们新的指令应该被插在&lt;strong&gt;new basic block&lt;/strong&gt;的末尾. 在LLVM中&lt;code&gt;Basic Block&lt;/code&gt;(define the &lt;strong&gt;Control Flow Graph&lt;/strong&gt;)是函数中重要的一部分. 因为我们没有任何控制流, 所以此时我们的函数只包含一个Block. &lt;strong&gt;we&amp;rsquo;ll fix this in Chapter 5&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;现在我们添加函数参数到&lt;strong&gt;NamedValues map&lt;/strong&gt;中(当然了, 首先它会被清空) 以便于它们可以被VariableExprAST节点所获取.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;if (Value *RetVal = Body-&amp;gt;codegen()) {
  // Finish off the function.
  Builder.CreateRet(RetVal);

  // Validate the generated code, checking for consistency.
  verifyFunction(*TheFunction);

  return TheFunction;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;一旦在&lt;strong&gt;设置了插入点&lt;/strong&gt;, 并且填充了&lt;strong&gt;NamedValues&lt;/strong&gt;之后, 我们调用codegen() 方法作为function的 root 表达式.&lt;/li&gt;
&lt;li&gt;如果没有error发生, &lt;strong&gt;this emits code&lt;/strong&gt;计算表达式到 &lt;strong&gt;entry block&lt;/strong&gt; 并返回计算出的值.&lt;/li&gt;
&lt;li&gt;假设没有error, 我们然后创建&lt;strong&gt;an LLVM ret instruction&lt;/strong&gt; (表示函数完成).&lt;/li&gt;
&lt;li&gt;一旦函数被构建后, 我们就会调用&lt;strong&gt;verifyFunction&lt;/strong&gt;(which provided by LLVM). 该函数对产生的IR做大量的一致性检测, 来确定是否我们的编译代码都是正确的. 使用它是相当重要地, 它能够捕获大量的bugs. 一旦一个函数完成并验证后, 我们就会返回它.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;  // Error reading body, remove function.
  TheFunction-&amp;gt;eraseFromParent();
  return nullptr;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后剩下的唯一一件事情就是处理error case. 简单起见, 我们仅仅通过使用&lt;strong&gt;earseFromParent&lt;/strong&gt;方法来删除我们Codegen的函数. 这允许用户重新定义他们之前输入错误的函数: 如果我们不删除它,  它将会继续保存在符号表中, 并且它还有body, 阻止我们之后定义.&lt;/p&gt;

&lt;p&gt;这代码有一个bug, 如果&lt;strong&gt;FunctionAST::codegen()&lt;/strong&gt;方法发现了一个存在的IR Function. 它不会根据自己的申明来验证其签名. 这意味着: 一个更早的&lt;code&gt;extern&lt;/code&gt;申明将会优先于函数定义的签名, 这可能导致codegen失败. 例如, 如果函数参数的名称不同.(what means ? 以后再研究)&lt;/p&gt;

&lt;p&gt;有很多方法可以解决这个问题, see what you can come up with! Here is a testcase:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;extern foo(a);     # ok, defines foo.
def foo(b) b;      # Error: Unknown variable name. (decl using &#39;a&#39; takes precedence).
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;3-5-driver-changes-and-closing-thoughts&#34;&gt;3.5 Driver Changes and Closing Thoughts&lt;/h1&gt;

&lt;p&gt;到目前为止, 除了我们可以查看漂亮的LLVM调用之外, LLVM的Codegen并没有给我们带来太多的帮助. The sample code 将对codegen的调用插入到 &amp;ldquo;HandleDefinition&amp;rdquo;, &amp;ldquo;HandleExtern&amp;rdquo;等函数中, 然后dump out the LLVM IR.&lt;/p&gt;

&lt;p&gt;这里有一个简单的方法来查看LLVM IR. Ex:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;ready&amp;gt; 4+5;
Read top-level expression:
define double @0() {
entry:
  ret double 9.000000e+00
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意 解析器是如何将顶级表达式转换为我们的anonymous函数. 当我们在下一章添加JIT Support时, 这会很便利.&lt;/p&gt;

&lt;p&gt;另外, 代码是literally transcribed, 除了IRBuilder会进行简单的常量折叠外, 不会执行任何优化. 下一章, 我们将会添加一些隐式地优化.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;ready&amp;gt; def foo(a b) a*a + 2*a*b + b*b;
Read function definition:
define double @foo(double %a, double %b) {
entry:
  %multmp = fmul double %a, %a
  %multmp1 = fmul double 2.000000e+00, %a
  %multmp2 = fmul double %multmp1, %b
  %addtmp = fadd double %multmp, %multmp2
  %multmp3 = fmul double %b, %b
  %addtmp4 = fadd double %addtmp, %multmp3
  ret double %addtmp4
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里展示了一些简单的表达式运算.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;ready&amp;gt; def bar(a) foo(a, 4.0) + bar(31337);
Read function definition:
define double @bar(double %a) {
entry:
  %calltmp = call double @foo(double %a, double 4.000000e+00)
  %calltmp1 = call double @bar(double 3.133700e+04)
  %addtmp = fadd double %calltmp, %calltmp1
  ret double %addtmp
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里展示了一些函数调用.&lt;/p&gt;

&lt;p&gt;Note 如果你调用它的话, 这个函数将会花大量时间来执行.&lt;/p&gt;

&lt;p&gt;在未来, 我们将会添加一些条件控制流来使递归变得可以使用.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;ready&amp;gt; extern cos(x);
Read extern:
declare double @cos(double)

ready&amp;gt; cos(1.234);
Read top-level expression:
define double @1() {
entry:
  %calltmp = call double @cos(double 1.234000e+00)
  ret double %calltmp
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里展示了一个extern for libm &amp;ldquo;cos&amp;rdquo; 函数, and call to it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-LLVM&#34;&gt;ready&amp;gt; ^D
; ModuleID = &#39;my cool jit&#39;

define double @0() {
entry:
  %addtmp = fadd double 4.000000e+00, 5.000000e+00
  ret double %addtmp
}

define double @foo(double %a, double %b) {
entry:
  %multmp = fmul double %a, %a
  %multmp1 = fmul double 2.000000e+00, %a
  %multmp2 = fmul double %multmp1, %b
  %addtmp = fadd double %multmp, %multmp2
  %multmp3 = fmul double %b, %b
  %addtmp4 = fadd double %addtmp, %multmp3
  ret double %addtmp4
}

define double @bar(double %a) {
entry:
  %calltmp = call double @foo(double %a, double 4.000000e+00)
  %calltmp1 = call double @bar(double 3.133700e+04)
  %addtmp = fadd double %calltmp, %calltmp1
  ret double %addtmp
}

declare double @cos(double)

define double @1() {
entry:
  %calltmp = call double @cos(double 1.234000e+00)
  ret double %calltmp
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当你退出demo时(在 linux 上通过CTRL+D,or  windows上通过CTRL+Z来发送EOF), 它将会显示该module产生的所有IR.&lt;/p&gt;

&lt;p&gt;这就是Kaleidoscope tutorial 第三章的内容.&lt;/p&gt;

&lt;p&gt;接下来, 我们会展示如何添加JIT Codegen和优化器支持, 以便于我们之后可以开始运行代码.&lt;/p&gt;

&lt;h1 id=&#34;3-6-full-code-listing&#34;&gt;3.6 Full Code Listing&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl03.html&#34;&gt;http://llvm.org/docs/tutorial/LangImpl03.html&lt;/a&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Kaleidoscope: Implementing a Parser and AST</title>
      <link>https://l0phtg.github.io/post/llvm/kaleidoscope-implementing-a-parser-and-ast/</link>
      <pubDate>Thu, 11 Apr 2019 15:41:17 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/llvm/kaleidoscope-implementing-a-parser-and-ast/</guid>
      
        <description>&lt;p&gt;translate from: &lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl02.html&#34;&gt;http://llvm.org/docs/tutorial/LangImpl02.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/docs-pic/dots/uml/ExprAst-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;介绍AST(抽象语法树)和Parser.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;2-1-introduction&#34;&gt;2.1 Introduction&lt;/h1&gt;

&lt;p&gt;本章介绍如何使用&lt;strong&gt;Lexer&lt;/strong&gt;, 来build一个完整的&lt;strong&gt;parser&lt;/strong&gt; for our Kaleidoscope language. 一旦我们有了parser, 我们将会定义并且build 一个 AST.&lt;/p&gt;

&lt;h1 id=&#34;2-2-ast&#34;&gt;2.2 AST&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/llvm/chapter2-AST.png&#34; alt=&#34;Chapter2 AST&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;2-3-parser-basic&#34;&gt;2.3 Parser Basic&lt;/h1&gt;

&lt;p&gt;现在我们有了AST, 我们需要定义parser code来build it. 这里的想法是我们要解析类似于&amp;rdquo;&lt;strong&gt;x+y&lt;/strong&gt;&amp;rdquo;(由词法分析器会返回3个Token)到AST中, 可以通过下面的代码产生:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;auto LHS = llvm::make_unique&amp;lt;VariableExprAST&amp;gt;(&amp;quot;x&amp;quot;);
auto RHS = llvm::make_unique&amp;lt;VariableExprAST&amp;gt;(&amp;quot;y&amp;quot;);
auto Result = std::make_unique&amp;lt;BinaryExprAST&amp;gt;(&#39;+&#39;, std::move(LHS),
                                              std::move(RHS));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Log&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// LogError* - These are little helper functions for error handling.
std::unique_ptr&amp;lt;ExprAST&amp;gt; LogError(const char *Str) {
  fprintf(stderr, &amp;quot;LogError: %s\n&amp;quot;, Str);
  return nullptr;
}
std::unique_ptr&amp;lt;PrototypeAST&amp;gt; LogErrorP(const char *Str) {
  LogError(Str);
  return nullptr;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;2-4-basic-expression-parsing&#34;&gt;2.4 Basic Expression Parsing&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;ParseNumberExpr&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// numberexpr ::= number
static std::unique_ptr&amp;lt;ExprAST&amp;gt; ParseNumberExpr() {
  auto Result = llvm::make_unique&amp;lt;NumberExprAST&amp;gt;(NumVal);
  getNextToken(); // consume the number
  return std::move(Result);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;ParseParenExpr&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;这里有一些有趣的点. 最主要的一点是 this routine eats all of the tokens that correspond to the production. 并且将next token返回到词法缓冲区中. (这不是一定要要求的), 这是一个实现递归下降parser的相当标准的写法.&lt;/p&gt;

&lt;p&gt;a better example, 括号运算符的parser defined like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// parenexpr ::= &#39;(&#39; expression &#39;)&#39;
static std::unique_ptr&amp;lt;ExprAST&amp;gt; ParseParenExpr() {  
  getNextToken(); // eat (.
  auto V = ParseExpression();
  if (!V)
    return nullptr;

  if (CurTok != &#39;)&#39;)
    return LogError(&amp;quot;expected &#39;)&#39;&amp;quot;);
  getNextToken(); // eat ).
  return V;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该函数说明了大量关于parser的有趣的事情:&lt;/p&gt;

&lt;p&gt;1) 展示了我们可以怎么样使用&lt;strong&gt;LogError&lt;/strong&gt;. 当被调用的时候, 该函数期待current token是 &amp;lsquo;&lt;strong&gt;(&lt;/strong&gt;&amp;rsquo;, 然后之后开始解析subexpression, (可能没有&amp;rsquo;)&amp;rsquo; waiting), 如果用户输入&amp;rdquo;(4 x&amp;rdquo; 代替 &amp;ldquo;(4)&amp;rdquo;, the parser应该弹一个error. 因为error发生了, parser需要一种方法来表明error发生时, 程序会做什么.在我们的解析器中, 当&lt;strong&gt;error&lt;/strong&gt;发生时, 我们会返回&lt;strong&gt;null&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;2) 另一个有趣的点是&lt;strong&gt;该函数使用了递归来调用ParserExpression&lt;/strong&gt;(我们不久将会看到&lt;strong&gt;ParserExpression&lt;/strong&gt;中调用了&lt;strong&gt;ParserParentExpr&lt;/strong&gt;). 这是一种处理递归语法的相当不错的方法. 并且它保证每个过程都十分simple. 注意, &lt;strong&gt;括号并不会引起AST node的构造&lt;/strong&gt;. 当我们这样做的时候, 括号最重要的角色就是&lt;strong&gt;知道parser来提供grouping&lt;/strong&gt;. 一旦parser成功构造了AST, 括号就不再被需要的.&lt;/p&gt;

&lt;p&gt;下面的例子是处理变量引用和函数调用:&lt;/p&gt;

&lt;p&gt;变量后面跟括号, 代表函数调用. 如果不是, 代码变量为identifier.&lt;/p&gt;

&lt;h1 id=&#34;2-5-binary-expression-parsing&#34;&gt;2.5 Binary Expression Parsing&lt;/h1&gt;

&lt;p&gt;二元表达式很难解析, 因为它们通常是模棱两可的. 例如, 当给 the string &amp;ldquo;x+y*z&amp;rdquo;, the parser可以选择&amp;rdquo;(x+y)*z&amp;rdquo;, 也可以选择&amp;rdquo;x+(y&lt;em&gt;z)&amp;ldquo;, 根据数学的定义, 我们的理解后面的是正确的. 因为 &amp;ldquo;&lt;/em&gt;&amp;ldquo;的优先级比&amp;rdquo;+&amp;ldquo;更高.&lt;/p&gt;

&lt;p&gt;有很多种方法来处理它, 但是一种优雅的和有效的方法是&lt;strong&gt;Operator-Precedence-Parsing&lt;/strong&gt;. 这种解析技术使用优先级来指导二元操作符递归处理. To start with, we need a table of precedences:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// BinopPrecedence - This holds the precedence for each binary operator that is
/// defined.
static std::map&amp;lt;char, int&amp;gt; BinopPrecedence;

/// GetTokPrecedence - Get the precedence of the pending binary operator token.
static int GetTokPrecedence() {
  if (!isascii(CurTok))
    return -1;

  // Make sure it&#39;s a declared binop.
  int TokPrec = BinopPrecedence[CurTok];
  if (TokPrec &amp;lt;= 0) return -1;
  return TokPrec;
}

int main() {
  // Install standard binary operators.
  // 1 is lowest precedence.
  BinopPrecedence[&#39;&amp;lt;&#39;] = 10;
  BinopPrecedence[&#39;+&#39;] = 20;
  BinopPrecedence[&#39;-&#39;] = 20;
  BinopPrecedence[&#39;*&#39;] = 40;  // highest.
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于Kaleidoscope基本的形式来说, 我们只支持4种二元操作符(很明显你可以扩展它, our brave and interpid reader). The &lt;strong&gt;GetTokPrecedence&lt;/strong&gt;返回目前token的优先级, 如果&lt;strong&gt;不是二元操作符的话, 返回 -1&lt;/strong&gt;. 通过一个map来增加一些操作符是一种不错的方法. 并且这很容易比较优先级.&lt;/p&gt;

&lt;p&gt;有了上面的定义, 我们就可以解析二元操作符了. 运算符优先级解析的基本思想是:&lt;strong&gt;将具有可能不明确的二元运算符的表达式分成多个&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Ex: 表达式&amp;rdquo;&lt;strong&gt;a+b+(c+d)*e*f+g&lt;/strong&gt;. operator precedence 将该表达式视为一个primary expressions流 separated by binary operators. 它将会先解析&lt;strong&gt;a&lt;/strong&gt;, 然后[+, b] [+, (c+d)] [&lt;em&gt;, e] [&lt;/em&gt;, f] and [+, g]. 注意括号也是primary expressions. 二元表达式不用担心它的subexpressions like (c+d) at all .&lt;/p&gt;

&lt;p&gt;To start, an expression is a primary expression. 可能后面跟着[binop, primaryexpr].&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// expression
///   ::= primary binoprhs
///
static std::unique_ptr&amp;lt;ExprAST&amp;gt; ParseExpression() {
  auto LHS = ParsePrimary();
  if (!LHS)
    return nullptr;

  return ParseBinOpRHS(0, std::move(LHS));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;ParseBinOpRHS&lt;/strong&gt;是一个函数来解析一系列的&lt;strong&gt;pairs&lt;/strong&gt;. 它需要一个优先级和指向表达式的指针.&lt;/p&gt;

&lt;p&gt;注意 that &amp;ldquo;&lt;strong&gt;x&lt;/strong&gt;&amp;rdquo; 是一个完全有效的表达式, 例如: &amp;ldquo;binoprhs&amp;rdquo; 可以是空的. 在这种情况下, it returns the expression that is passed into it. 在我们上面的例子中, 代码传递表达式&amp;rdquo;a&amp;rdquo;到ParseBinOpRHS 并且当前的token是 &amp;ldquo;+&amp;rdquo;;&lt;/p&gt;

&lt;p&gt;传递给ParseBinOpRHS的优先级值表示函数被允许eat 的 the minimal operator precedence.
例如, 如果目前的pair stream is [+, x] and ParseBinOpRHS被传递的优先级是40, 它将不会消耗任何tokens(因为&amp;rsquo;+&amp;lsquo;的优先级是20). 根据这种思想, ParseBinOpRHS starts with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// binoprhs
///   ::= (&#39;+&#39; primary)*
static std::unique_ptr&amp;lt;ExprAST&amp;gt; ParseBinOpRHS(int ExprPrec,
                                              std::unique_ptr&amp;lt;ExprAST&amp;gt; LHS) {
  // If this is a binop, find its precedence.
  while (1) {
    int TokPrec = GetTokPrecedence();

    // If this is a binop that binds at least as tightly as the current binop,
    // consume it, otherwise we are done.
    if (TokPrec &amp;lt; ExprPrec)
      return LHS;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该代码获得当前token的优先级, 并且检查它是否是too low. 因为我们定义无效的tokens的优先级是-1, 所以这隐式地可以知道(当run out of binary operators时, pair-stream就结束了).如果this check succeed, 我们知道token是一个二元表达式并且它将被included in this expression:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;    // Okay, we know this is a binop.
    int BinOp = CurTok;
    getNextToken();  // eat binop
    
    // Parse the primary expression after the binary operator.
    auto RHS = ParsePrimary();
    if (!RHS)
      return nullptr;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As such, this code eats(and remembers) 二元表达式 and 解析primary expression that follows. This build up the whole pair, the first of which is [+, b] for the running example.&lt;/p&gt;

&lt;p&gt;现在我们解析表达式的左边和一组RHS sequence, 我们不得不决定which way the expression associates. 特别地, 我们 have &amp;ldquo;(a+b)&amp;rdquo; binop unparsed or &amp;ldquo;a+(b binop unparsed&amp;rdquo;. 为了确定这个, 我们look ahead at &amp;ldquo;binop&amp;rdquo; to 确定它的优先级并且将它与BinOp&amp;rsquo;s 优先级比较(which is &amp;lsquo;+&amp;rsquo; in this case):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// If BinOp binds less tightly with RHS than the operator after RHS, let
// the pending operator take RHS as its LHS.
int NextPrec = GetTokPrecedence();
if (TokPrec &amp;lt; NextPrec) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果binop在&amp;rdquo;RHS&amp;rdquo;右侧的优先级低于或者等于我们当前运算符的优先级. in our example, 目前的操作符是&amp;rdquo;+&amp;rdquo; 并且下一个操作符是&amp;rdquo;+&amp;ldquo;, 我们明白他们有相同的优先级. in this case 我们将会创建node for &amp;ldquo;a+b&amp;rdquo;, and then continue parsing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;      ... if body omitted ...
    }

    // Merge LHS/RHS.
    LHS = llvm::make_unique&amp;lt;BinaryExprAST&amp;gt;(BinOp, std::move(LHS),
                                           std::move(RHS));
  }  // loop around to the top of the while loop.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在我们的例子中. 这将把 &amp;ldquo;a + b&amp;rdquo; into &amp;ldquo;(a + b)&amp;ldquo;并且来执行下一次循环的迭代. with &amp;ldquo;+&amp;rdquo; as the current token. 上面的代码将被eat, remember, and parse (&amp;ldquo;c + d&amp;rdquo;) as the primary expression, which makes the 目前的pair equal to [+, (c + d)]. 它将会评估上面的&amp;rdquo;if&amp;rdquo;条件, 并将&amp;rdquo;&lt;em&gt;&amp;ldquo;作为右侧的binop. 在该case中, 优先级 of &amp;ldquo;&lt;/em&gt;&amp;rdquo; 是比+的优先级更高, 因此if条件将会被输入.&lt;/p&gt;

&lt;p&gt;关键的问题是: if条件如何解析右边的全部? In particular, 为了在我们的例子中正确的build AST. 它需要将&amp;rdquo;(c + d)*e*f&amp;rdquo;作为RHS表达式变量. 执行该操作的代码相当简单.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;    // If BinOp binds less tightly with RHS than the operator after RHS, let
    // the pending operator take RHS as its LHS.
    int NextPrec = GetTokPrecedence();
    if (TokPrec &amp;lt; NextPrec) {
      RHS = ParseBinOpRHS(TokPrec+1, std::move(RHS));
      if (!RHS)
        return nullptr;
    }
    // Merge LHS/RHS.
    LHS = llvm::make_unique&amp;lt;BinaryExprAST&amp;gt;(BinOp, std::move(LHS),
                                           std::move(RHS));
  }  // loop around to the top of the while loop.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这一点上, 我们知道我们主要的RHS的二元运算符优于我们当前正在解析的binop. 因此, 我们知道任何运算符都优先于&amp;rdquo;+&amp;ldquo;的序列应该一起解析并作为&amp;rdquo;RHS&amp;rdquo;返回.&lt;/p&gt;

&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;

&lt;p&gt;递归构造.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;a+b*c*(d+e) + f&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;第一次循环:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!--1. [0, a] 和 [+, b]; [0, a] 为LHS; 0 &amp;lt; +,  [1+, b] 继续ParseBinOpRHS--&amp;gt;
&amp;lt;!--2. [+, b] 和 [*, c]; [+, b] 为LHS; + &amp;lt; *,  [*, c] 继续ParseBinOpRHS--&amp;gt;
&amp;lt;!--3. [*, c] 和 [(), d+e]; [*, c]为LHS     --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;mermaid&#34;&gt;
graph TB
    1((a)) 
    2((b))
    3((c))
    4((d))
    5((e))
    
    7((+))
    8((*))
    9((*))
    10((+))
    
    7 --&gt; 1
    
    8 --&gt; 2
    8 --&gt; 3
    9 --&gt; 8
    9 --&gt; 10
    10 --&gt; 4
    10 --&gt; 5
    
    7 --&gt; 9
&lt;/div&gt;

&lt;p&gt;第二次循环&lt;/p&gt;

&lt;div class=&#34;mermaid&#34;&gt;
graph TB
    1((a)) 
    2((b))
    3((c))
    4((d))
    5((e))
    6((f))
    7((+))
    8((*))
    9((*))
    10((+))
    11((+))
    
    7 --&gt; 1
    
    8 --&gt; 2
    8 --&gt; 3
    9 --&gt; 8
    9 --&gt; 10
    10 --&gt; 4
    10 --&gt; 5
    
    7 --&gt; 9
    
    subgraph TB
    11 --&gt; 7
    11 --&gt; 6
    end
&lt;/div&gt;

&lt;h1 id=&#34;2-6-parse-the-rest&#34;&gt;2.6 Parse the Rest&lt;/h1&gt;

&lt;p&gt;下一件事情是解析函数申明. in Kaleidoscope, &lt;code&gt;extern&lt;/code&gt;函数申明以及函数体定义. 代码是相当直接的, not very interesting(once you&amp;rsquo;re survived expressions):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// prototype
///   ::= id &#39;(&#39; id* &#39;)&#39;
static std::unique_ptr&amp;lt;PrototypeAST&amp;gt; ParsePrototype() {
  if (CurTok != tok_identifier)
    return LogErrorP(&amp;quot;Expected function name in prototype&amp;quot;);

  std::string FnName = IdentifierStr;
  getNextToken();

  if (CurTok != &#39;(&#39;)
    return LogErrorP(&amp;quot;Expected &#39;(&#39; in prototype&amp;quot;);

  // Read the list of argument names.
  std::vector&amp;lt;std::string&amp;gt; ArgNames;
  while (getNextToken() == tok_identifier)
    ArgNames.push_back(IdentifierStr);
  if (CurTok != &#39;)&#39;)
    return LogErrorP(&amp;quot;Expected &#39;)&#39; in prototype&amp;quot;);

  // success.
  getNextToken();  // eat &#39;)&#39;.

  return llvm::make_unique&amp;lt;PrototypeAST&amp;gt;(FnName, std::move(ArgNames));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然了, 函数定义是相当简单的, just &lt;strong&gt;一个申明&lt;/strong&gt;加&lt;strong&gt;一个表达式&lt;/strong&gt;来实现函数体.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// definition ::= &#39;def&#39; prototype expression
static std::unique_ptr&amp;lt;FunctionAST&amp;gt; ParseDefinition() {
  getNextToken();  // eat def.
  auto Proto = ParsePrototype();
  if (!Proto) return nullptr;

  if (auto E = ParseExpression())
    return llvm::make_unique&amp;lt;FunctionAST&amp;gt;(std::move(Proto), std::move(E));
  return nullptr;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，我们支持&lt;code&gt;extern&lt;/code&gt;来声明&lt;code&gt;sin&lt;/code&gt;和&lt;code&gt;cos&lt;/code&gt;之类的函数，以及支持用户函数的前向声明。这些&lt;code&gt;extern&lt;/code&gt;只是没有身体的原型:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// external ::= &#39;extern&#39; prototype
static std::unique_ptr&amp;lt;PrototypeAST&amp;gt; ParseExtern() {
  getNextToken();  // eat extern.
  return ParsePrototype();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后, 我们让用户输入任意顶级表达式并evaluate them. 我们将会处理this by defining anonymous nullary(zero argument) functions for them:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// toplevelexpr ::= expression
static std::unique_ptr&amp;lt;FunctionAST&amp;gt; ParseTopLevelExpr() {
  if (auto E = ParseExpression()) {
    // Make an anonymous proto.
    auto Proto = llvm::make_unique&amp;lt;PrototypeAST&amp;gt;(&amp;quot;&amp;quot;, std::vector&amp;lt;std::string&amp;gt;());
    return llvm::make_unique&amp;lt;FunctionAST&amp;gt;(std::move(Proto), std::move(E));
  }
  return nullptr;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们have all the pieces, let&amp;rsquo;s build a little driver that will let us actually execute this code we&amp;rsquo;ve built!&lt;/p&gt;

&lt;h1 id=&#34;2-7-the-driver&#34;&gt;2.7 The Driver&lt;/h1&gt;

&lt;p&gt;The Driver仅仅是通过调用所有的解析pieces.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/// top ::= definition | external | expression | &#39;;&#39;
static void MainLoop() {
  while (1) {
    fprintf(stderr, &amp;quot;ready&amp;gt; &amp;quot;);
    switch (CurTok) {
    case tok_eof:
      return;
    case &#39;;&#39;: // ignore top-level semicolons.
      getNextToken();
      break;
    case tok_def:
      HandleDefinition();
      break;
    case tok_extern:
      HandleExtern();
      break;
    default:
      HandleTopLevelExpression();
      break;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一件有趣的事情是:  我们忽略了顶级&amp;rdquo;;&amp;ldquo;.&lt;/p&gt;

&lt;h1 id=&#34;2-8-conclusions&#34;&gt;2.8 Conclusions&lt;/h1&gt;

&lt;p&gt;通过这仅仅400行的代码, 我们定义了我们的最小的语言, 包含一个词法分析器, 解析器, 和AST builder.&lt;/p&gt;

&lt;p&gt;这是一个简单的交互例子:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./a.out
ready&amp;gt; def foo(x y) x+foo(y, 4.0);
Parsed a function definition.
ready&amp;gt; def foo(x y) x+y y;
Parsed a function definition.
Parsed a top-level expr
ready&amp;gt; def foo(x y) x+y );
Parsed a function definition.
Error: unknown token when expecting an expression
ready&amp;gt; extern sin(a);
ready&amp;gt; Parsed an extern
ready&amp;gt; ^D
$
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;2-9-full-code-listing&#34;&gt;2.9 Full Code Listing&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl02.html#the-abstract-syntax-tree-ast&#34;&gt;http://llvm.org/docs/tutorial/LangImpl02.html#the-abstract-syntax-tree-ast&lt;/a&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Kaleidoscope: Tutorial Introduction and Lexer</title>
      <link>https://l0phtg.github.io/post/kaleidoscope-tutorial-introduction-and-lexer/</link>
      <pubDate>Wed, 10 Apr 2019 10:17:08 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/kaleidoscope-tutorial-introduction-and-lexer/</guid>
      
        <description>&lt;p&gt;translate from &lt;a href=&#34;http://llvm.org/docs/tutorial/LangImpl01.html&#34;&gt;http://llvm.org/docs/tutorial/LangImpl01.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本tutorial将会介绍一个简单语言的实现.
&lt;/p&gt;

&lt;h1 id=&#34;1-1-tutorial-introduction&#34;&gt;1.1 Tutorial Introduction&lt;/h1&gt;

&lt;h1 id=&#34;1-2-the-basic-language&#34;&gt;1.2 The Basic Language&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;Kaleidoscope&lt;/code&gt;是一个过程语言. 它允许你定义函数, 使用条件分支, math, etc.&lt;/p&gt;

&lt;p&gt;在本tutorial中,  我们将会扩展Kaleidoscope来支持&lt;strong&gt;if/then/else 判断&lt;/strong&gt;, &lt;strong&gt;for循环&lt;/strong&gt;, &lt;strong&gt;用户自定义operators&lt;/strong&gt;, &lt;strong&gt;用一个简单的命令行接口的JIT 编译&lt;/strong&gt; , etc.&lt;/p&gt;

&lt;p&gt;因为我们都想要把事情做的简单. 所以in Kaleidoscope中, 唯一的数据类型是&lt;strong&gt;64-bit floating point type&lt;/strong&gt;. 因此, 所有的values都隐式地&lt;strong&gt;double&lt;/strong&gt;类型.&lt;/p&gt;

&lt;p&gt;下面是使用Kaleidoscope来计算Fibonacci numbers的一个simple example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//Compute the x&#39;th fibonacci number.
def fib(x)
    if x &amp;lt; 3 then 
        1
    else
        fib(x-1) + fib(x-2)

# This expression will compute the 40th number        
fib(40)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们也允许Kaleidoscope来调用标准库函数. 这意味着, 你可以在函数前面加关键字&amp;rdquo;&lt;strong&gt;extern&lt;/strong&gt;&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;For Example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;extern sin(arg);
extern cos(arg);
extern atan2(arg2, arg2);

atan2(sin(.4), cos(42))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第6章包含更有趣的例子, 我们使用Kaleidoscope写了一个小型应用 display a Mandelbrot Set at various levels of magnification.&lt;/p&gt;

&lt;p&gt;下面让我们探究Kaleidoscope的实现吧!!!.&lt;/p&gt;

&lt;h1 id=&#34;1-3-lexer&#34;&gt;1.3 Lexer&lt;/h1&gt;

&lt;p&gt;Token类型:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// The lexer returns tokens [0-255] if it is an unknown character, otherwise one
// of these for known things.
enum Token {
  tok_eof = -1,

  // commands
  tok_def = -2,
  tok_extern = -3,

  // primary
  tok_identifier = -4,
  tok_number = -5,
};

static std::string IdentifierStr; // Filled in if tok_identifier
static double NumVal;             // Filled in if tok_number
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从标准输入中返回next token&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// gettok - Return the next token from standard input.
static int gettok() {
  static int LastChar = &#39; &#39;;

  // Skip any whitespace.
  while (isspace(LastChar))
    LastChar = getchar();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;判断token是否为标识符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;if (isalpha(LastChar)) { // identifier: [a-zA-Z][a-zA-Z0-9]*
  IdentifierStr = LastChar;
  while (isalnum((LastChar = getchar())))
    IdentifierStr += LastChar;

  if (IdentifierStr == &amp;quot;def&amp;quot;)
    return tok_def;
  if (IdentifierStr == &amp;quot;extern&amp;quot;)
    return tok_extern;
  return tok_identifier;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;判断token是否为数字&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;if (isdigit(LastChar) || LastChar == &#39;.&#39;) {   // Number: [0-9.]+
  std::string NumStr;
  do {
    NumStr += LastChar;
    LastChar = getchar();
  } while (isdigit(LastChar) || LastChar == &#39;.&#39;);

  NumVal = strtod(NumStr.c_str(), 0);
  return tok_number;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;判断是否为注释&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;if (LastChar == &#39;#&#39;) {
  // Comment until end of line.
  do
    LastChar = getchar();
  while (LastChar != EOF &amp;amp;&amp;amp; LastChar != &#39;\n&#39; &amp;amp;&amp;amp; LastChar != &#39;\r&#39;);

  if (LastChar != EOF)
    return gettok();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是否文件末尾&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Check for end of file.  Don&#39;t eat the EOF.
if (LastChar == EOF)
      return tok_eof;

// Otherwise, just return the character as its ascii value.
int ThisChar = LastChar;
LastChar = getchar();
return ThisChar;
}
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>Static Single Assignment</title>
      <link>https://l0phtg.github.io/post/llvm/static-single-assignment/</link>
      <pubDate>Tue, 09 Apr 2019 21:54:49 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/llvm/static-single-assignment/</guid>
      
        <description>&lt;p&gt;translate from: &lt;a href=&#34;https://en.wikipedia.org/wiki/Static_single_assignment_form&#34;&gt;https://en.wikipedia.org/wiki/Static_single_assignment_form&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;单一变量赋值
&lt;img src=&#34;https://l0phtg.github.io/llvm/SSA_example1.2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;每个变量只被赋值一次.&lt;/p&gt;

&lt;p&gt;在编译器设计中, &lt;strong&gt;static single assigment form&lt;/strong&gt; (经常被称为&lt;strong&gt;SSA form&lt;/strong&gt; 或者 简化为 &lt;strong&gt;SSA&lt;/strong&gt;) 是IR的属性. 这要求每个变量只被assigment一次, 并且变量要在使用前定义. 原始IR中的已经存在的变量被划分为多个版本, 新的变量在文本中被显示为原始变量名称加下标的, 以便于每一个定义都有他们自己的版本.&lt;/p&gt;

&lt;h1 id=&#34;benefits&#34;&gt;Benefits&lt;/h1&gt;

&lt;p&gt;SSA的主要用途: 来自于它通过简化变量的属性来同时简化和改进各种编译器优化的结果.&lt;/p&gt;

&lt;p&gt;例如, 考虑这段代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;y := 1
y := 2
x := y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以一眼就看到第一行代码是不必要的, 第三行使用的y的值来自于第二行y的赋值. 一个程序必须执行 &lt;strong&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Reaching_definition&#34;&gt;reaching definition analysis&lt;/a&gt;&lt;/strong&gt; to 决定这个. 但是如果一个程序是SSA形式, 这些都是直接的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;y1 := 1
y2 := 2
x1 := y2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过SSA的包含使用, &lt;a href=&#34;https://en.wikipedia.org/wiki/Optimizing_compiler&#34;&gt;编译器优化&lt;/a&gt;
算法增强了很多:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Constant propagation 常量传播&lt;/li&gt;
&lt;li&gt;Value range propagation&lt;/li&gt;
&lt;li&gt;Sparse conditional constant propagation&lt;/li&gt;
&lt;li&gt;Dead code elimination&lt;/li&gt;
&lt;li&gt;Global value numbering          全局值编号&lt;/li&gt;
&lt;li&gt;Partial redundancy elimination  部分冗余代码消除&lt;/li&gt;
&lt;li&gt;Strength reduction&lt;/li&gt;
&lt;li&gt;Register allocation&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;converting-to-ssa&#34;&gt;Converting to SSA&lt;/h1&gt;

&lt;p&gt;将普通代码转换为SSA形式主要是通过&lt;strong&gt;使用新变量替换每个赋值的目标&lt;/strong&gt;.
and replacing each use of a variable with the &amp;ldquo;version&amp;rdquo; of the variable reaching that point.&lt;/p&gt;

&lt;p&gt;例如, consider the following &lt;a href=&#34;https://en.wikipedia.org/wiki/Control-flow_graph&#34;&gt;control flow graph&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/llvm/SSA_example1.1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;更改 &amp;ldquo;x -&amp;gt; x - 3&amp;rdquo; 左侧的名称, 并将之后对x的使用更改为新名称将使程序保持不变. 这可以通过在ssa中创建两个新的变量: x1 and x2 来利用, 每个变量只被分配一次. 同样, 给所有其他的变量也赋予不一样的下标.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/llvm/ssa-example1.2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;每一个使用都是很清楚的, 除了&lt;strong&gt;one case: 在底部block中,$\bold{y}$的使用应该是$\bold{y_1}$还是$\bold{y_2}$呢?&lt;/strong&gt; 取决于控制流的path.&lt;/p&gt;

&lt;p&gt;为了解决这个问题&lt;/p&gt;

&lt;p&gt;在最后的块中插入了一个特殊语句$\bold{\phi(phi)} $  函数. 这个表达式将会产生$\bold{y}$的新的定义, 通过选择$\bold{ y_1}$或者$\bold{y_2}$(取决于过去的控制流).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/llvm/ssa-example1.3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在, 最后一个块可以轻松使用$\bold{y_3}$ , 并且可以获得正确的值. 一个$\bold{\phi}$ 函数 for $\bold{x}$ 是不必要的: 因为只有一个$\bold{x}$ 的版本. （换句话说: $\bold{\phi(x_2, x_2) = x_2}$ 是不必要的.&lt;/p&gt;

&lt;p&gt;给定任意一个控制流图, 很难说出&lt;strong&gt;哪里需要插入 $\bold{\phi}$函数, and for which variables&lt;/strong&gt; .&lt;/p&gt;

&lt;p&gt;这个普遍的问题有一个有效的解决方案: &lt;strong&gt;dominance frontiers(支配边界)&lt;/strong&gt; . (see below)&lt;/p&gt;

&lt;p&gt;在大多数机器上: $\bold{\phi}$函数都没有被实现作为一个机器操作.&lt;/p&gt;

&lt;p&gt;编译器只需在存储器(或者相同的寄存器)中即可轻松地实现$\bold{\phi}$ 函数.  (存储器或寄存器作为一个$\bold{\phi}$函数输入的任何操作的目的地).  然而, 当simultaneous operations are speculatively producing inputs to a $\bold{\phi}$ 函数(就像很多机器上发生的那样), 该方法就不起作用了.&lt;/p&gt;

&lt;p&gt;通常, 大多数机器都有一个选择指令被用于该情况中, 这可以被我们的编译器用于实现$\bold{\phi}$函数.&lt;/p&gt;

&lt;p&gt;根据 Kenny Zadeck , $\bold{\phi}$ 函数最初被称为phony functions. 正式的名字是在学术paper上第一次发表时引入的.&lt;/p&gt;

&lt;h2 id=&#34;computing-minimal-ssa-using-dominance-frontiers-使用dominance边界计算最小的ssa&#34;&gt;computing minimal SSA using dominance frontiers(使用dominance边界计算最小的SSA)&lt;/h2&gt;

&lt;p&gt;首先, 我们需要了解&lt;strong&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Dominator_(graph_theory)&#34;&gt;dominator&lt;/a&gt;&lt;/strong&gt;的概念: 如果&lt;strong&gt;不先经过节点 A 就到不了节点 B&lt;/strong&gt;, 我们就称节点 A 在控制流中严格支配节点 B. 这很有用, 因为如果我们已经到达节点 B , 就证明 A 中的代码也都正在工作. 如果 &lt;strong&gt;A 严格支配 B&lt;/strong&gt; 或者 A = B, 我们就说 A dominates B ( 或者 B is dominated by A)&lt;/p&gt;

&lt;p&gt;现在, 我们可以定义 the &lt;strong&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Dominator_(graph_theory)&#34;&gt;dominance frontier&lt;/a&gt;&lt;/strong&gt; : 如果节点 A 不严格支配节点 B, 但是支配了一些 B的前面节点(predecessor), 就称为节点 B 在节点 A 的*dominace frontier*中. ( 可能节点 A 是 节点 B 的直接前节点. 然后, 因为任何节点都 &lt;em&gt;dominates&lt;/em&gt; 它自身, 并且节点 A &lt;em&gt;dominates&lt;/em&gt; 它自身, 所以节点 B 是处于节点 A的支配边界).&lt;/p&gt;

&lt;p&gt;从 A 的角度看, 那是在其他控制路径上不经过A的 最早出现的节点.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Dominance frontiers&lt;/em&gt; 可以精准地确定我们需要$\bold{\phi}$ 函数的地方:  如果节点A定义了某个变量, then that definition and that definition alone (or redefinitions) will reach every node A dominates. 只有当我们离开这些节点并进入&lt;em&gt;dominance frontiers&lt;/em&gt; 时,我们必须考虑其他流是否引入了相同变量的另外一个定义.此外, 控制流图中不需要处理其他 $\bold{\phi}$ 函数, 我们可以做到 no less.&lt;/p&gt;

&lt;p&gt;一个算法可以用来计算&lt;em&gt;dominance frontier set&lt;/em&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for each node b
   dominance_frontier(b) := {}
for each node b
    if the number of immediate predecessors of b ≥ 2
        for each p in immediate predecessors of b
            runner := p
            while runner ≠ idom(b)
                dominance_frontier(runner) := dominance_frontier(runner) ∪ { b }
                runner := idom(runner)
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>Dominator(graph Theory)</title>
      <link>https://l0phtg.github.io/post/dominatorgraph-theory/</link>
      <pubDate>Sat, 06 Apr 2019 18:00:53 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/dominatorgraph-theory/</guid>
      
        <description>&lt;p&gt;translate from : &lt;a href=&#34;https://en.wikipedia.org/wiki/Dominator_(graph_theory)&#34;&gt;https://en.wikipedia.org/wiki/Dominator_(graph_theory)&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;最近在学习SSA(Static Single Assignment)时, 遇到了${dominance frontier}$的概念, 所以google之, 简单翻译了一下wikipedia上对Dominator内容的介绍.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;dominator-graph-theory&#34;&gt;Dominator (graph theory)&lt;/h1&gt;

&lt;p&gt;在计算机科学中, 在控制流图中, 如果从入口点到节点 $\bold{n}$ 的每条路径都经过节点 $\bold{d}$, 则称节点 $\bold{d}$ dominates 节点 $\bold{n}$&lt;/p&gt;

&lt;p&gt;被写作 $\bold{d}$ dom $\bold{n}$ (or $\bold{d} \gg \bold {n}$).&lt;/p&gt;

&lt;p&gt;另外我们定义, 每个节点都 dominates 它自身.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/llvm/300px-Dominator_control_flow_graph.svg.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这里有一些相关的概念:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;节点 $\bold{d}$ &lt;em&gt;strictly dominates&lt;/em&gt; (严格支配) 节点 $\bold {n} $ : $\bold{d}$ dominates $\bold{n}$ 并且 $\bold{d} $ 与 $\bold{n}$ 不相等.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;节点 $\bold{n}$ 的 &lt;em&gt;immediate dominator&lt;/em&gt; (直接支配者) or &lt;strong&gt;idom&lt;/strong&gt; : 一个节点严格支配 $\bold{n}$ 但是不严格支配其他严格支配$\bold{n}$ 的节点. 除了入口点之外, 每一个节点都有一个直接支配者.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;节点 $\bold{d}$ 的 &lt;em&gt;dominance frontier&lt;/em&gt; :  所有节点$\bold{n}$ 的集合, 使得 $\bold{d}$ 支配 $\bold{n}$ 的 immediate predecessor. 但是 $\bold{d} $ 不严格支配节点 $\bold{n}$ . 这是一组 $\bold{d&amp;rsquo;s}$ dominance 停止的节点集合.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一个 &lt;em&gt;dominator tree&lt;/em&gt; : 一颗树, 这棵树每个节点的子节点是它直接支配的节点. 因为直接支配者是独一无二的, 所以它是一棵树. 开始节点是树的根节点.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;$\color{black}{dom}$&lt;/th&gt;
&lt;th&gt;$\color{Gray}{1}$&lt;/th&gt;
&lt;th&gt;$\color{Red}{2}$&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;6&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;$\color{black}{dom}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$\color{Gray}{2}$&lt;/td&gt;
&lt;td&gt;$\color{Red}{3}$&lt;/td&gt;
&lt;td&gt;$\color{Red}{4}$&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;$\color{Red}{6}$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;$\color{black}{dom}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$\color{Gray}{3}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;$\color{black}{dom}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$\color{Gray}{4}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;$\color{black}{dom}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$\color{Gray}{5}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;$\color{black}{dom}$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$\color{Gray}{6}$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;与 domination关系相对应&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$灰色的节点\color{Gray}{灰色的节点}$ 是 非严格 dominated&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$红色的节点\color{Red}{红色的节点}$ 是 直接 dominated&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;dominator tree:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/llvm/300px-Dominator_tree.svg.png&#34; alt=&#34;dominator tree&#34; /&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>如果你冲动删除了python</title>
      <link>https://l0phtg.github.io/post/%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%86%B2%E5%8A%A8%E5%88%A0%E9%99%A4%E4%BA%86python/</link>
      <pubDate>Tue, 02 Apr 2019 21:12:17 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%86%B2%E5%8A%A8%E5%88%A0%E9%99%A4%E4%BA%86python/</guid>
      
        <description>&lt;p&gt;在你经历了痛苦的pip安装, 各种报错之后. 一气之前, 你决定卸载python, 重新安装. 那么, 既然要卸载, 就要卸载的彻底!&lt;/p&gt;

&lt;p&gt;所以你输入了下面的几行命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#hahaha
$sudo apt remove python
$sudo apt remove python3
$sudo apt remove pip
$sudo apt remove pip3
#一定删除的不彻底, 我要彻底删除
$sudo apt autoremove -f 
看到要删除600+M, 毅然决然的按了 y.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;Bingo 然后你看到了我这篇文章.
&lt;/p&gt;

&lt;h1 id=&#34;一-基础知识&#34;&gt;一、基础知识&lt;/h1&gt;

&lt;h2 id=&#34;1-重新安装python和pip&#34;&gt;1. 重新安装python和pip&lt;/h2&gt;

&lt;h3 id=&#34;1-1-安装python&#34;&gt;1.1 安装python&lt;/h3&gt;

&lt;p&gt;由于ubuntu16.04默认安装的python版本是 &lt;strong&gt;python2.7&lt;/strong&gt;  和 &lt;strong&gt;python3.5&lt;/strong&gt; .&lt;/p&gt;

&lt;p&gt;所以&lt;strong&gt;为了满足系统的需要&lt;/strong&gt;, 我们&lt;strong&gt;需要重新安装python2.7 和 python3.5&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;安装方式很简单:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#安装python2.7和python3.5
$sudo apt install python  # 默认安装的python2.7
$sudo apt install python3 # 默认安装的python3.5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除此之外, 我们还需要安装一些&lt;strong&gt;python的dev库&lt;/strong&gt; ,  因为系统和很多软件运行时都依赖它(这也是我们删除python 并 autoremove后, 发现系统gg的一部分原因)&lt;/p&gt;

&lt;p&gt;安装方式同样很简单:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#安装dev库
$sudo apt install libpython2.7 libpython2.7-dev
$sudo apt install libpython3.5 libpython3.5-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: 虽然系统的apt源不直接提供python3.6以及更高版本的python程序. 但是&lt;strong&gt;提供了python全版本的libdev库&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;所以, 如果你想要安装&lt;strong&gt;libpython3.6&lt;/strong&gt;的话, 也是可以的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#安装python3.6的dev库
$sudo apt install libpython3.6 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是如果想要安装&lt;strong&gt;python3.6&lt;/strong&gt;及以上的包, 该怎么办呢?&lt;/p&gt;

&lt;p&gt;方法有很多, 这里推荐&lt;strong&gt;源安装的方式&lt;/strong&gt; :&lt;/p&gt;

&lt;p&gt;可以参考(&lt;a href=&#34;https://linuxize.com/post/how-to-install-python-3-7-on-ubuntu-18-04/&#34;&gt;https://linuxize.com/post/how-to-install-python-3-7-on-ubuntu-18-04/&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;具体操作:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 安装python3.6 above
$sudo apt update
$sudo apt install software-properties-common

$sudo add-apt-repository ppa:deadsnakes/ppa   #加入python源, 并按[enter]确认

$sudo apt update      # 之后重新更新我们的源库

# 现在就可以安装python的其他版本了
$sudo apt install python3.6       # 例如你想安装python3.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://l0phtg.github.io/life/python-install.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;1-2-安装pip&#34;&gt;1.2 安装pip&lt;/h3&gt;

&lt;p&gt;安装pip, 这里只推荐一种方式:&lt;/p&gt;

&lt;p&gt;参照官方安装文档: &lt;a href=&#34;https://pip.pypa.io/en/stable/installing/&#34;&gt;https://pip.pypa.io/en/stable/installing/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首先, 下载&lt;strong&gt;get-pip.py&lt;/strong&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#使用curl命令(如果未安装, 先{sudo apt install curl}) 来下载get-pip.py  
$curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py # 下载get-pip.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后, 安装&lt;strong&gt;你需要的pip版本&lt;/strong&gt; , (注意: 这里有&lt;strong&gt;全局安装&lt;/strong&gt;和&lt;strong&gt;user安装&lt;/strong&gt; 两种方式) :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#安装pip3.6
$ sudo python3.6 get-pip.py    # 全局安装

$ python3.6 get-pip.py --user  # user安装
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-pip使用&#34;&gt;2. pip使用&lt;/h2&gt;

&lt;h3 id=&#34;2-1-全局安装package和user安装package&#34;&gt;2.1 全局安装package和user安装package&lt;/h3&gt;

&lt;p&gt;我们在使用pip 安装 &lt;strong&gt;package&lt;/strong&gt; 时, 有两种选择:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;全局安装&lt;/strong&gt; package, 对所有系统用户生效&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; 
$sudo pip2.7 install {package}   # python2.7使用pip2.7安装package 
$sudo pip3.5 install {package}   # python3.5使用pip3.5安装package 
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;user安装&lt;/strong&gt; package, 只对user(当前用户生效)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#
$pip2.7 install --user {package} 
$pip3.5 install --user {package}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相信&lt;strong&gt;sudo&lt;/strong&gt;和&lt;strong&gt;&amp;ndash;user&lt;/strong&gt;大家一眼就可以看到.&lt;/p&gt;

&lt;p&gt;那么除了这两个地方的不同, 还有哪些不同值得我们了解的呢?&lt;/p&gt;

&lt;h3 id=&#34;2-2-两种安装package方式的不同&#34;&gt;2.2 两种安装package方式的不同&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;dist-packages&lt;/strong&gt; : 这是我们package安装后的存放目录.&lt;/p&gt;

&lt;p&gt;肯定地, &lt;strong&gt;全局安装&lt;/strong&gt;和 &lt;strong&gt;user安装&lt;/strong&gt; 的&lt;strong&gt;package存放路径是不同的&lt;/strong&gt; .&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;全局安装&lt;/strong&gt;时的&lt;strong&gt;package存放路径&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 
$sudo pip3.6 --version
pip 19.0.3 from /usr/local/lib/python3.6/dist-packages/pip (python 3.6)
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;user安装&lt;/strong&gt;时的&lt;strong&gt;package存放路径&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#
$ pwd             # 查看当前绝对路径
/home/l0phtg

$ pip3.6 install --user neovim  # 注意这里显示的路径是相对路径
Requirement already satisfied: neovim in ./.local/lib/python3.6/site-packages (0.3.1)
Requirement already satisfied: pynvim&amp;gt;=0.3.1 in ./.local/lib/python3.6/site-packages (from neovim) (0.3.2)
Requirement already satisfied: msgpack&amp;gt;=0.5.0 in ./.local/lib/python3.6/site-packages (from pynvim&amp;gt;=0.3.1-&amp;gt;neovim) (0.6.1)
Requirement already satisfied: greenlet in ./.local/lib/python3.6/site-packages (from pynvim&amp;gt;=0.3.1-&amp;gt;neovim) (0.4.15)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即&lt;strong&gt;user安装python3.6的package时&lt;/strong&gt;, package 默认存放在了 &lt;strong&gt;~/.local/lib/python3.6/site-packages&lt;/strong&gt; .路径下.&lt;/p&gt;

&lt;h1 id=&#34;二-安装被你意外删掉的库&#34;&gt;二、 安装被你意外删掉的库&lt;/h1&gt;

&lt;p&gt;在安装了前面所需的python2.7, python3.5, pip2.7, pip3.5, libpython2.7,  libpython2.7-dev, libpython3.5, libpython3.5-dev 之后, 你需要安装ubuntu系统的一些库.&lt;/p&gt;

&lt;p&gt;ubuntu系统所需的库为&lt;strong&gt;ubuntu-minimal, ubuntu-standard, ubuntu-desktop&lt;/strong&gt; .&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$sudo apt install ubuntu-minimal ubuntu-standard ubuntu-desktop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时, 系统就已经可以&lt;strong&gt;正常启动, 并正常进入和显示桌面&lt;/strong&gt; 了.&lt;/p&gt;

&lt;p&gt;最后,  因为你的操作, 可能导致&lt;strong&gt;一些三方应用不能启动&lt;/strong&gt; , 这时你只能自行重装了.&lt;/p&gt;

&lt;p&gt;我这里已经知道的影响到的三方软件为: Chrome浏览器, wps.&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>本科应届生安全岗面试总结</title>
      <link>https://l0phtg.github.io/post/%E6%9C%AC%E7%A7%91%E5%BA%94%E5%B1%8A%E7%94%9F%E5%AE%89%E5%85%A8%E5%B2%97%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>Tue, 02 Apr 2019 11:24:31 +0800</pubDate>
      
      <guid>https://l0phtg.github.io/post/%E6%9C%AC%E7%A7%91%E5%BA%94%E5%B1%8A%E7%94%9F%E5%AE%89%E5%85%A8%E5%B2%97%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</guid>
      
        <description>&lt;p&gt;很久没有更新博客了, 主要原因是因为现在笔记都记在了有道云笔记中. 并且 很多篇文章都只写了一半, 也不想发出来.&lt;/p&gt;

&lt;p&gt;近期时间充裕, 应该会保持每周一更, 将以前写的或者近期学到的知识总结一下发在博客里.&lt;/p&gt;

&lt;p&gt;本篇文章是19年春节写的, 主要记录了自己在18年的几次面试记录, 和大学期间的一些学习经历.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;个人简介&#34;&gt;个人简介&lt;/h1&gt;

&lt;p&gt;L0phTg&lt;/p&gt;

&lt;p&gt;学习方向: 二进制, 移动安全.&lt;/p&gt;

&lt;p&gt;专业: 信息安全.&lt;/p&gt;

&lt;h2 id=&#34;学习经历&#34;&gt;学习经历&lt;/h2&gt;

&lt;h3 id=&#34;大一&#34;&gt;大一&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;在未加入实验室之前, 我处于&amp;rdquo;野生, 放养&amp;rdquo;的状态
(就是没有目的的学习, 乱七八糟买了很多计算机类的书, 应该大多数人都经历过这个阶段, 其实在这个阶段就是要多了解熟悉各个计算机专业方向, 所以也没有必要一直苦恼, 分清主次, 打好基础就对了.)&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;大一主要学习了一段时间c/c++,( 此处推荐  &lt;code&gt;&amp;lt;&amp;lt; c语言程序设计现代方法&amp;gt;&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;&amp;lt; c++Primer&amp;gt;&amp;gt;&lt;/code&gt; ). 由于当时看到很多人推荐 &lt;code&gt;&amp;lt;&amp;lt;深入理解计算机系统&amp;gt;&amp;gt;&lt;/code&gt;, 所以耐不住诱惑, 就买了一本来看, 我的汇编知识最初就是在这本书上看到的.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当然其实大一虽然没有过多接触信息安全领域的专业知识, 但是由于一直在微博, 知乎关注着很多安全届大佬, 对安全领域也有了基本的概念与印象, 知道安全基本分为web和二进制等之类, 也了解到安全届有heige和tk两位妇科圣手, 这些多少都给无聊的大学生活增添了许多乐趣.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;关于安全学习的方向其实确定起来不是那么容易的, 最初了解到的是余弦、heige，所以多少想从事web安全领域. 但是在最终确定学习方向的时候, 还是考虑了自己的实际情况, 自身学习路线与兴趣爱好.  在大一暑假, 总结了一下自己大一看过的书有关于c/c++的, 汇编的, 和w32的, 以及阅读了 &lt;code&gt;&amp;lt;&amp;lt;加密与解密&amp;gt;&amp;gt;&lt;/code&gt;, 而且熟悉了linux下的基本操作. 至于web方向的试探, 只是停留在w3c上看过一点h5. 所以, 理所当然的就决定了之后走二进制这条路线.(方向领域的确定还是要根据自己实际情况考虑, 如果不考研, 且决定大三要找工作的话)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;移动安全领域入门, 是在大二, 至于是发生了什么导致自己想要向android安全靠拢的, 保密.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;大二&#34;&gt;大二&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;大二在历经艰辛进入实验室后, 生活就比较顺风顺水了, 就抱着一本 &lt;code&gt;&amp;lt;&amp;lt; android软件安全与逆向分析&amp;gt;&amp;gt;&lt;/code&gt;看了一个学期, 大二上就是这么过的.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;大二下主要是接触了一些android逆向与脱壳, 跟着f8left的视频, 自己尝试着去调试.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;大二暑期尝试去绿盟实习, 无奈面试失败. (失败+1)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;大三&#34;&gt;大三&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;大三由于面临着找工作这个大难题, 所以想着做些什么能够让自己的简历有亮眼之处. 所以就想着写些项目.
所以大三上和寒假就一直在coding. 主要写了两个项目: 一个ptrace相关, 一个arm相关.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;大三下就是春招， 阿里腾讯面试失败. (失败+2)  (面试失败对自己的打击是很大的, 所以失败后自己也在反思总结, 然后期待之后的公司面试能够顺利通过, 具体面试体验等看下一部分)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;之后面试小米. (成功+1) 面试小米成功之后, 就直接去了小米实习, 几个月的实习生活中, 学习到了很多. (具体看之后的实习经历)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;大四&#34;&gt;大四&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;大四秋招.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;我的面试经历其实并不顺畅, 但是之后的内容不会写的太具体, 只写一些主要的, 希望对大家有所帮助.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;拿到offer之后. 追剧, 玩游戏, 看直播&amp;hellip;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;面试准备&#34;&gt;面试准备&lt;/h1&gt;

&lt;p&gt;其实面试的准备内容是根据自己的面试岗位变化的. 例如游戏安全偏c/c++, app安全可能会涉及java. 但是自己擅长的一定要多做准备. 可以根据每次面试自己的发挥, 以及面试官的提问重点, 来针对性的复习和学习.&lt;/p&gt;

&lt;p&gt;移动安全岗位问到的相关内容包括(简历上写的基本都可能会问到):
c/c++,
java,
smali,
android逆向,
简单数据结构和算法,
简单加密算法, 分组加密的模式
hook等.&lt;/p&gt;

&lt;h1 id=&#34;面试经历&#34;&gt;面试经历&lt;/h1&gt;

&lt;h2 id=&#34;春招&#34;&gt;春招&lt;/h2&gt;

&lt;p&gt;春招印象最深的是腾讯的几次面试:&lt;/p&gt;

&lt;p&gt;第一次面的是tx游戏安全, 由于自己当时对hook没有了解, 并且在最后回答c++方向的问题时, 表现不好, 所以gg. ( 但是这次面试失败后, 就疯狂恶补了hook方向的内容. 这也使得自己在秋招面试一些公司时, 得以不在hook方向被打出gg)&lt;/p&gt;

&lt;p&gt;还有一次也是tx的另一个二进制部门, 面试失败的原因, 我归结为自己没有对一些安全知识做过总结. 所以在面试时, 发挥不好. (经常性的总结自己学过的知识, 是挺重要的. 这次面试失败之后, 就开了个有道云笔记会员, 硬广一波, 主要优势 跨平台. hhhhaaa.)&lt;/p&gt;

&lt;p&gt;小米面试, 是我春招的结尾, 一周面了三面技术面, 体验最好.
一面组长面, 对我写的一个项目问了有40min, 注意, 一个项目, 问到我怀疑人生. 二面: 智力面? 问了几个算法, 回答的一般, 但还是挺过去了. 终面(boss面): 自己在经历过春招的几场面试失败后, 对android安全做了一些系统的总结. 所以boss在问到对android安全的认识和了解的时候, 以及linker模块的时候,  把自己系统总结过的表达出来, 就通过面试了.&lt;/p&gt;

&lt;h2 id=&#34;秋招&#34;&gt;秋招&lt;/h2&gt;

&lt;p&gt;在经历过春招之后, 秋招相对来说轻松一些. 因为自己相对来说有了更多的经验, 也基本不会惨死在基础知识上(但还是有), 就算参加有些公司的面试, 即使失败了, 也没有那么多的抱怨和后悔.&lt;/p&gt;

&lt;h2 id=&#34;实习经历&#34;&gt;实习经历&lt;/h2&gt;

&lt;p&gt;实习时间(2018-4-15~~2018-8.30).&lt;/p&gt;

&lt;p&gt;实习单位: 小米MIUI系统组.&lt;/p&gt;

&lt;p&gt;在小米实习的日子, 是非常开心快乐的, 我也慢慢地从一个路人变成了一个米粉. 在实习期间, 学习到了很多:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;刷机.&lt;/li&gt;
&lt;li&gt;gdb调试android系统和应用.&lt;/li&gt;
&lt;li&gt;对android底层的art虚拟机有了一定的了解.&lt;/li&gt;
&lt;li&gt;method hook.&lt;/li&gt;
&lt;li&gt;总结了很多android加固方法.&lt;/li&gt;
&lt;li&gt;实现了一个加固demo.&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
  </channel>
</rss>