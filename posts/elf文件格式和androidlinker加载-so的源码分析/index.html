<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<meta property="og:title" content="elf文件格式和AndroidLinker加载.so的源码分析" />
<meta property="og:description" content="最近在学习android应用的加壳和混淆方法, 所以遇到了一些有关.so是如何加载到android中去的问题, 看了一些视频和文章, 所以想在此总结一下. 首先我们先分析一下elf的文件格式, 然后再分析linker的源码. elf文件格式 本文只对elf文件格式进行简单的分析, 如果要进行深入的了解, 推荐&lt;&lt;程序员的自我修养&gt;&gt;中第3章. /usr/includ/elf.h中定义了elf文件头结构和相关的常数. 分析elf文件时, 建议使用010 editor这款十六进制编辑软件, 运行elf模板后可以清晰的将文件格式显示出来, 大致的显示是(坑, 此处应该用图片的)
NAME Value Start Size Color Comment struct file 0h 109Ch struct elf_header 0h 34h struct program_header_table 34h 120h struct section_header_table 1B274h 460h struct dynamic_symbol_table 18Ch F10h  可以看到, 一个elf文件中包含一个header, 3个table, 我们一个一个的来分析一下. 首先分析Elf header, 它位于每一个elf文件开始的地方:
typedef struct typedef struct { { unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */ unsigned char e_ident[EI_NIDENT]; Elf32_Half e_type; /* Object file type */ Elf64_Half e_type; Elf32_Half e_machine; /* Architecture */ Elf64_Half e_machine; Elf32_Word e_version; /* Object file version */ Elf64_Word e_version; Elf32_Addr e_entry; /* Entry point virtual address */ Elf64_Addr e_entry; Elf32_Off e_phoff; /* Program header table file offset */ Elf64_Off e_phoff; Elf32_Off e_shoff; /* Section header table file offset */ Elf64_Off e_shoff; Elf32_Word e_flags; /* Processor-specific flags */ Elf64_Word e_flags; Elf32_Half e_ehsize; /* ELF header size in bytes */ Elf64_Half e_ehsize; Elf32_Half e_phentsize; /* Program header table entry size */ Elf64_Half e_phentsize; Elf32_Half e_phnum; /* Program header table entry count */ Elf64_Half e_phnum; Elf32_Half e_shentsize; /* Section header table entry size */ Elf64_Half e_shentsize; Elf32_Half e_shnum; /* Section header table entry count */ Elf64_Half e_shnum; Elf32_Half e_shstrndx; /* Section header string table index */ Elf64_Half e_shstrndx; } Elf32_Ehdr; } Elf64_Ehdr;  可以看到, header中包含了magic number, 文件类型, 目标文件版本, 入口地址(如果为0, 说明此文件为可重定位文件), program header的开始地址(即为在so文件中的offset), section header的开始地址, 标志位, elf头本身的大小, program header和section header的size和数量, 最后是section header中string section在section中的下标." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://example.com/posts/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%92%8Candroidlinker%E5%8A%A0%E8%BD%BD-so%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" /><meta property="article:published_time" content="2017-03-19T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2017-03-19T00:00:00&#43;00:00"/>
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="elf文件格式和AndroidLinker加载.so的源码分析"/>
<meta name="twitter:description" content="最近在学习android应用的加壳和混淆方法, 所以遇到了一些有关.so是如何加载到android中去的问题, 看了一些视频和文章, 所以想在此总结一下. 首先我们先分析一下elf的文件格式, 然后再分析linker的源码. elf文件格式 本文只对elf文件格式进行简单的分析, 如果要进行深入的了解, 推荐&lt;&lt;程序员的自我修养&gt;&gt;中第3章. /usr/includ/elf.h中定义了elf文件头结构和相关的常数. 分析elf文件时, 建议使用010 editor这款十六进制编辑软件, 运行elf模板后可以清晰的将文件格式显示出来, 大致的显示是(坑, 此处应该用图片的)
NAME Value Start Size Color Comment struct file 0h 109Ch struct elf_header 0h 34h struct program_header_table 34h 120h struct section_header_table 1B274h 460h struct dynamic_symbol_table 18Ch F10h  可以看到, 一个elf文件中包含一个header, 3个table, 我们一个一个的来分析一下. 首先分析Elf header, 它位于每一个elf文件开始的地方:
typedef struct typedef struct { { unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */ unsigned char e_ident[EI_NIDENT]; Elf32_Half e_type; /* Object file type */ Elf64_Half e_type; Elf32_Half e_machine; /* Architecture */ Elf64_Half e_machine; Elf32_Word e_version; /* Object file version */ Elf64_Word e_version; Elf32_Addr e_entry; /* Entry point virtual address */ Elf64_Addr e_entry; Elf32_Off e_phoff; /* Program header table file offset */ Elf64_Off e_phoff; Elf32_Off e_shoff; /* Section header table file offset */ Elf64_Off e_shoff; Elf32_Word e_flags; /* Processor-specific flags */ Elf64_Word e_flags; Elf32_Half e_ehsize; /* ELF header size in bytes */ Elf64_Half e_ehsize; Elf32_Half e_phentsize; /* Program header table entry size */ Elf64_Half e_phentsize; Elf32_Half e_phnum; /* Program header table entry count */ Elf64_Half e_phnum; Elf32_Half e_shentsize; /* Section header table entry size */ Elf64_Half e_shentsize; Elf32_Half e_shnum; /* Section header table entry count */ Elf64_Half e_shnum; Elf32_Half e_shstrndx; /* Section header string table index */ Elf64_Half e_shstrndx; } Elf32_Ehdr; } Elf64_Ehdr;  可以看到, header中包含了magic number, 文件类型, 目标文件版本, 入口地址(如果为0, 说明此文件为可重定位文件), program header的开始地址(即为在so文件中的offset), section header的开始地址, 标志位, elf头本身的大小, program header和section header的size和数量, 最后是section header中string section在section中的下标."/>



    <link rel="canonical" href="https://example.com/posts/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%92%8Candroidlinker%E5%8A%A0%E8%BD%BD-so%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <title>
      
        elf文件格式和AndroidLinker加载.so的源码分析 | Bootstrap demo
      
    </title>

    
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" integrity="sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB" crossorigin="anonymous">

    <link href="https://example.com/css/style.css" rel="stylesheet">

    

    

    
  </head>
  <body>
    
      <header class="blog-header">
    <nav class="navbar navbar-expand-md navbar-light bg-light">
        <a class="navbar-brand" href="/">
            Bootstrap demo
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false"
            aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse justify-content-between" id="navbarNav">
            <ul class="navbar-nav">
                
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/">Home</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/about/">About</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/contact/">Contact</a>
                    
                </li>
                
            </ul>
            
            <ul class="navbar-nav">
                <li class="nav-item dropdown">
                    <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                        Language
                    </a>
                    <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown">
                        
                            <a class="dropdown-item" href="https://example.com/">English</a>
                        
                            <a class="dropdown-item" href="https://example.com/es/">Español</a>
                        
                            <a class="dropdown-item" href="https://example.com/de/">Deutsch</a>
                        
                    </div>
                </li>
            </ul>
            
        </div>
    </nav>
</header>
    

    
    <div class="container">
      <div class="row">
        <div class="col-12 col-lg-8 blog-main">

          

<header>
    <h2 class="blog-post-title">
        <a class="text-dark" href="/posts/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%92%8Candroidlinker%E5%8A%A0%E8%BD%BD-so%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">elf文件格式和AndroidLinker加载.so的源码分析</a>
    </h2>
    


<div class="blog-post-date text-secondary">
    
        Mar 19, 2017
    
    
        by <span rel="author">John Doe</span>
    
</div>

    
<div class="blog-post-tags text-secondary">
    <strong>Tags:</strong>
    
        <a class="badge badge-primary" href="/tags/%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F">文件格式</a>
    
        <a class="badge badge-primary" href="/tags/android%E6%BA%90%E7%A0%81">Android源码</a>
    
</div>

    
<div class="blog-post-categories text-secondary">
    <strong>Categories:</strong>
    
        <a class="badge badge-primary" href="/categories/android">Android</a>
    
</div>

    <hr>
</header>
<article class="blog-post">
    

<p>最近在学习android应用的加壳和混淆方法, 所以遇到了一些有关.so是如何加载到android中去的问题, 看了一些视频和文章, 所以想在此总结一下.
首先我们先分析一下elf的文件格式, 然后再分析linker的源码.
<!-- more --></p>

<h2 id="elf文件格式">elf文件格式</h2>

<p>本文只对elf文件格式进行简单的分析, 如果要进行深入的了解, 推荐<code>&lt;&lt;程序员的自我修养&gt;&gt;</code>中第3章.
/usr/includ/elf.h中定义了elf文件头结构和相关的常数.
分析elf文件时, 建议使用<code>010 editor</code>这款十六进制编辑软件, 运行elf模板后可以清晰的将文件格式显示出来, 大致的显示是(坑, 此处应该用图片的)</p>

<pre><code class="language-c">                NAME                           Value            Start       Size        Color       Comment
    struct file                                                 0h          109Ch
        struct elf_header                                       0h          34h
        struct program_header_table                             34h         120h
        struct section_header_table                             1B274h      460h
        struct dynamic_symbol_table                             18Ch        F10h
</code></pre>

<p>可以看到, 一个elf文件中包含一个header, 3个table, 我们一个一个的来分析一下.
首先分析<code>Elf header</code>, 它位于每一个elf文件开始的地方:</p>

<pre><code class="language-c">typedef struct                                                            typedef struct
{                                                                         {
    unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */     unsigned char e_ident[EI_NIDENT];
    Elf32_Half    e_type;         /* Object file type */                    Elf64_Half    e_type;     
    Elf32_Half    e_machine;      /* Architecture */                        Elf64_Half    e_machine;  
    Elf32_Word    e_version;      /* Object file version */                 Elf64_Word    e_version;  
    Elf32_Addr    e_entry;        /* Entry point virtual address */         Elf64_Addr    e_entry;    
    Elf32_Off e_phoff;        /* Program header table file offset */        Elf64_Off e_phoff;        
    Elf32_Off e_shoff;        /* Section header table file offset */        Elf64_Off e_shoff;        
    Elf32_Word    e_flags;        /* Processor-specific flags */            Elf64_Word    e_flags;    
    Elf32_Half    e_ehsize;       /* ELF header size in bytes */            Elf64_Half    e_ehsize;   
    Elf32_Half    e_phentsize;        /* Program header table entry size */ Elf64_Half    e_phentsize;
    Elf32_Half    e_phnum;        /* Program header table entry count */    Elf64_Half    e_phnum;    
    Elf32_Half    e_shentsize;        /* Section header table entry size */ Elf64_Half    e_shentsize;
    Elf32_Half    e_shnum;        /* Section header table entry count */    Elf64_Half    e_shnum;    
    Elf32_Half    e_shstrndx;     /* Section header string table index */   Elf64_Half    e_shstrndx; 
} Elf32_Ehdr;                                                              } Elf64_Ehdr;
</code></pre>

<p>可以看到, header中包含了magic number, 文件类型, 目标文件版本, 入口地址(如果为0, 说明此文件为可重定位文件), program header的开始地址(即为在so文件中的offset), section header的开始地址, 标志位, elf头本身的大小, program header和section header的size和数量, 最后是section header中string section在section中的下标.(用010 editor可以看到清楚的看到一个.so文件包含众多的program header 和 section header, 这两个段在做.so混淆时会经常分析)</p>

<p>现在分析<code>program header</code></p>

<pre><code class="language-c">/* Program segment header.  */

typedef struct                                                      typedef struct
{                                                                   {
    Elf32_Word    p_type;         /* Segment type */                    Elf64_Word    p_type;   
    Elf32_Off p_offset;       /* Segment file offset */                 Elf64_Off p_offset;     
    Elf32_Addr    p_vaddr;        /* Segment virtual address */         Elf64_Addr    p_vaddr;  
    Elf32_Addr    p_paddr;        /* Segment physical address */        Elf64_Addr    p_paddr;  
    Elf32_Word    p_filesz;       /* Segment size in file */            Elf64_Word    p_filesz; 
    Elf32_Word    p_memsz;        /* Segment size in memory */          Elf64_Word    p_memsz;  
    Elf32_Word    p_flags;        /* Segment flags */                   Elf64_Word    p_flags;  
    Elf32_Word    p_align;        /* Segment alignment */               Elf64_Word    p_align;  
} Elf32_Phdr;                                                       } Elf64_Phdr;
</code></pre>

<p>接下来分析<code>section header</code>, section相信了解过汇编的同学都非常熟悉了, 这个section header里面就存放了我们elf中各个段的信息.
看一下section header段描述符的结构:(64位的与32位的结构体大致相同, 只是把类型改为了Elf64的类型)</p>

<pre><code class="language-c">typedef struct
{
    Elf32_Word    sh_name;        /* Section name (string tbl index) 段名*/
    Elf32_Word    sh_type;        /* Section type 段类型*/
    Elf32_Word    sh_flags;       /* Section flags 标志位*/
    Elf32_Addr    sh_addr;        /* Section virtual addr at execution 段虚拟地址*/
    Elf32_Off sh_offset;          /* Section file offset 段偏移*/
    Elf32_Word    sh_size;        /* Section size in bytes 段的长度*/
    Elf32_Word    sh_link;        /* Link to another section 段的链接信息*/
    Elf32_Word    sh_info;        /* Additional section information 段链接的相关信息*/
    Elf32_Word    sh_addralign;   /* Section alignment 段地址对齐*/
    Elf32_Word    sh_entsize;     /* Entry size if section holds table 项的长度*/
} Elf32_Shdr;
</code></pre>

<p>最后分析动态符号表(<code>symbol table</code>):</p>

<pre><code class="language-c">typedef struct
{
    Elf32_Word    st_name;        /* Symbol name (string tbl index) */
    Elf32_Addr    st_value;       /* Symbol value */
    Elf32_Word    st_size;        /* Symbol size */
    unsigned char st_info;        /* Symbol type and binding */
    unsigned char st_other;       /* Symbol visibility */
    Elf32_Section st_shndx;       /* Section index */
} Elf32_Sym;
</code></pre>

<p>包含的信息有符号名, 符号相对应的值, 符号大小, 符号类型和绑定信息, 符号所在的段.</p>

<h2 id="android-linker加载-so的源码分析">Android Linker加载.so的源码分析</h2>

<p>Android中的本地文件.so是通过Linker加载到内存中去并且执行的.(本文分析的源码为Android4.4.4)
                &mdash;- 推荐一款好用的源码阅读工具 source Insight</p>

<pre><code class="language-cpp">java层:  System.LoadLibrary(&quot;function&quot;);
native:         ---&gt;  Dalvik/vm/native/java_lang_Runtime.cpp: Dalvik_java_lang_Runtime_nativeLoad 
                        ---&gt;Dalvik/vm/Native.cpp: dvmLoadNativeCode(const char* fileName, Object* ClassLoader, char** reason)
                                ---&gt;bionic/linker/dlfcn.c: dlopen(const char* pathName, RTLD_LAZY)
                                        ---&gt;bionic/linker/linker.cpp: do_dlopen(const char* name, int flags)
</code></pre>

<ol>
<li>核心函数为<code>do_dlopen</code>:
<code>cpp
soinfo* do_dlopen(const char* name, int flags) {  // 函数的参数为
if ((flags &amp; ~(RTLD_NOW|RTLD_LAZY|RTLD_LOCAL|RTLD_GLOBAL)) != 0) {
    DL_ERR(&quot;invalid flags to dlopen: %x&quot;, flags);
    return NULL;
}
set_soinfo_pool_protection(PROT_READ | PROT_WRITE); // 设置so信息池的访问权限为可读可写
soinfo* si = find_library(name);                    // 找到name函数, 装载so, 并返回指向.soinfo的指针
if (si != NULL) {
                  si-&gt;CallConstructors();           // 初始化so库
}
set_soinfo_pool_protection(PROT_READ);              // 设置so信息池的访问权限为只读
return si;
}
</code></li>

<li><p>查看<code>find_library</code>函数可以发现它调用了<code>find_library_internal</code>函数,</p>

<pre><code class="language-cpp">static soinfo* find_library(const char* name) {
soinfo* si = find_library_internal(name);
if (si != NULL) {
    si-&gt;ref_count++;
}
return si;
}
</code></pre>

<p>分析<code>find_library_internal</code>函数, 发现其主要调用了<code>load_library()</code>函数和 <code>soinfo_link_image()</code> 函数.
_</p>

<pre><code class="language-cpp">static soinfo* find_library_internal(const char* name) {
if (name == NULL) {
    return somain;
}
soinfo* si = find_loaded_library(name);         // 判断.so是否完全加载, 如果加载: 返回有效的指针;如果没有加载, 返回null;
if (si != NULL) {                               // 如果已经加载，返回
    if (si-&gt;flags &amp; FLAG_LINKED) {
        return si;
    }
    DL_ERR(&quot;OOPS: recursive link to \&quot;%s\&quot;&quot;, si-&gt;name);
    return NULL;
}

TRACE(&quot;[ '%s' has not been loaded yet.  Locating...]&quot;, name);  // 打印so还没有加载
si = load_library(name);        // 加载.so
if (si == NULL) {
    return NULL;
}
// At this point we know that whatever is loaded @ base is a valid ELF
// shared library whose segments are properly mapped in.
TRACE(&quot;[ init_library base=0x%08x sz=0x%08x name='%s' ]&quot;,
        si-&gt;base, si-&gt;size, si-&gt;name);

if (!soinfo_link_image(si)) {       // 完成.so的重定位
    munmap(reinterpret_cast&lt;void*&gt;(si-&gt;base), si-&gt;size);
    soinfo_free(si);
    return NULL;
}
return si;
}
</code></pre></li>
</ol>

<p>分析<code>load_library</code>函数, 会找到elf_read.<code>Load()</code>方法, 这个方法就是load</p>

<pre><code class="language-cpp">static soinfo* load_library(const char* name) {
// Open the file.
    int fd = open_library(name);                        // 打开文件, 获取fd
    if (fd == -1) {
        DL_ERR(&quot;library \&quot;%s\&quot; not found&quot;, name);
        return NULL;
    }

    // Read the ELF header and load the segments.
    ElfReader elf_reader(name, fd);                     // 初始化elfReader对象
    if (!elf_reader.Load()) {                           // 通过elfReader对象的Load()方法, 将so文件装载到内存
        return NULL;
    }

    const char* bname = strrchr(name, '/');
    soinfo* si = soinfo_alloc(bname ? bname + 1 : name);    // 分配so_info结构, 并按照装载结果更新相应的成员变量
    if (si == NULL) {
        return NULL;
    }
    si-&gt;base = elf_reader.load_start();
    si-&gt;size = elf_reader.load_size();
    si-&gt;load_bias = elf_reader.load_bias();
    si-&gt;flags = 0;
    si-&gt;entry = 0;
    si-&gt;dynamic = NULL;
    si-&gt;phnum = elf_reader.phdr_count();
    si-&gt;phdr = elf_reader.loaded_phdr();

    return si;
}

这里放一个ElfReader结构:
class ElfReader {
public:
    ElfReader(const char* name, int fd);
    ~ElfReader();

    bool Load();

    size_t phdr_count() { return phdr_num_; }
    Elf32_Addr load_start() { return reinterpret_cast&lt;Elf32_Addr&gt;(load_start_); }
    Elf32_Addr load_size() { return load_size_; }
    Elf32_Addr load_bias() { return load_bias_; }
    const Elf32_Phdr* loaded_phdr() { return loaded_phdr_; }

private:
    bool ReadElfHeader();
    bool VerifyElfHeader();
    bool ReadProgramHeader();
    bool ReserveAddressSpace();
    bool LoadSegments();
    bool FindPhdr();
    bool CheckPhdr(Elf32_Addr); 

    const char* name_;
    int fd_;    

    Elf32_Ehdr header_;
    size_t phdr_num_;   

    void* phdr_mmap_;
    Elf32_Phdr* phdr_table_;
    Elf32_Addr phdr_size_;  

    // First page of reserved address space.
    void* load_start_;
    // Size in bytes of reserved address space.
    Elf32_Addr load_size_;
    // Load bias.
    Elf32_Addr load_bias_;

    // Loaded phdr.
    const Elf32_Phdr* loaded_phdr_;
};
</code></pre>

<p>这里是<code>Load()</code>函数</p>

<pre><code class="language-cpp">bool ElfReader::Load() {
    return ReadElfHeader() &amp;&amp;                   // 读取
        VerifyElfHeader() &amp;&amp;                // 验证
        ReadProgramHeader() &amp;&amp;              // 读取Program header
        ReserveAddressSpace() &amp;&amp;            // 根据Program header计算so需要的内存size并分配相应的空间
        LoadSegments() &amp;&amp;                   // 将so按照segment为单位装载到内存
        FindPhdr();                     // on 装载到内存的so中找到program header, 方便以后链接过程use
}
</code></pre>

<ul>
<li>首先是<code>ReadElfHeader</code>()函数, 发现其是直接调用<code>read</code>函数读取到header中的.
<code>cpp
bool ElfReader::ReadElfHeader() {
ssize_t rc = TEMP_FAILURE_RETRY(read(fd_, &amp;header_, sizeof(header_)));  // use read() function 直接将elfheader读取到header中
</code>//////////////////////////////
return true;
}
```</li>
<li>然后是<code>VerifyElfread</code>()函数, 对Elfheader进行验证识别: 是否为32位，大小端，类型和版本.</li>

<li><p>之后<code>ReadProgramHeader</code>()函数(加载program header table从elf文件到一个只读的私有匿名的mmap-ed block中):</p>

<pre><code class="language-cpp">bool ElfReader::ReadProgramHeader() {
phdr_num_ = header_.e_phnum;                                        
//  将program header on内存中中单独映射一份, use于解析时临时use, on so装载到内存后, 便会释放这块内存, 转而使use装载后的so中的program header

// Like the kernel, we only accept program header tables that
// are smaller than 64KiB.
if (phdr_num_ &lt; 1 || phdr_num_ &gt; 65536/sizeof(Elf32_Phdr)) {
    DL_ERR(&quot;\&quot;%s\&quot; has invalid e_phnum: %d&quot;, name_, phdr_num_);
    return false;
}

Elf32_Addr page_min = PAGE_START(header_.e_phoff);
Elf32_Addr page_max = PAGE_END(header_.e_phoff + (phdr_num_ * sizeof(Elf32_Phdr)));
Elf32_Addr page_offset = PAGE_OFFSET(header_.e_phoff);  

phdr_size_ = page_max - page_min;

void* mmap_result = mmap(NULL, phdr_size_, PROT_READ, MAP_PRIVATE, fd_, page_min);
    if (mmap_result == MAP_FAILED) {
    DL_ERR(&quot;\&quot;%s\&quot; phdr mmap failed: %s&quot;, name_, strerror(errno));
    return false;
}

phdr_mmap_ = mmap_result;
phdr_table_ = reinterpret_cast&lt;Elf32_Phdr*&gt;(reinterpret_cast&lt;char*&gt;(mmap_result) + page_offset);
return true;
}
</code></pre></li>

<li><p><code>ReverveAddressSpace</code>()函数(准备虚拟内存足够的大来存放Program header中的<code>Load</code>段(两个Load段～～) 通过<code>mmap with PROT_NONE</code> 实现</p></li>
</ul>

<pre><code class="language-cpp">bool ElfReader::ReserveAddressSpace() {
    Elf32_Addr min_vaddr;
    load_size_ = phdr_table_get_load_size(phdr_table_, phdr_num_, &amp;min_vaddr);  // 获取so on 内存中需要的空间load_size
    if (load_size_ == 0) {
          DL_ERR(&quot;\&quot;%s\&quot; has no loadable segments&quot;, name_);
              return false;
    }

    uint8_t* addr = reinterpret_cast&lt;uint8_t*&gt;(min_vaddr);
    void* start = mmap(addr, load_size_, PROT_NONE, mmap_flags, -1, 0);         // use mmap匿名映射, 预留出相应的空间
    int mmap_flags = MAP_PRIVATE | MAP_ANONYMOUS;
    if (start == MAP_FAILED) {
        DL_ERR(&quot;couldn't reserve %d bytes of address space for \&quot;%s\&quot;&quot;, load_size_, name_);
        return false;
    }

    load_start_ = start;
    load_bias_ = reinterpret_cast&lt;uint8_t*&gt;(start) - addr;              // so可以指定加载的基址, 但是so指定的加载基址可能不是页对齐的, 这种情况
    return true;                                                            // 会导致实际映射地址和指定的加载地址有一个偏差, 这个偏差便是load_bias
}
</code></pre>

<ul>
<li><p><code>LoadSegments</code>()函数(在进程地址空间中加载所有可加载的段(假设你已经预留了空间为这个library)):
```cpp
bool ElfReader::LoadSegments() {<br />
for (size_t i = 0; i &lt; phdr<em>num</em>; ++i) {
const Elf32_Phdr* phdr = &amp;phdr<em>table</em>[i];   // 遍历program header table</p>

<p>if (phdr-&gt;p_type != PT_LOAD) {          // 加载所有p_type == PT_LOAD的段
    continue;
}</p>

<p>``` 之后就是一些设置段地址，段偏移, 之后mmap的一些操作</p>

<p>return true;
}</p></li>
</ul>

<pre><code>
 * `FindPhdr`()(返回program header table加载到内存中的地址, 因为之后还要执行.so的重定位).
现在回到我们`find_library_internal`()这里，在执行完load_library()之后, 还有一个重要的函数为 `soinfo_link_image`(soinfo* si):

```cpp
这个函数会完成.so的动态链接，其中包含我们加载的.so库的重定位过程:
 1. 定位动态section,将动态section的虚拟地址和项数和读写权限存在dynamic, dynamic_count, dynamic_flags中.
    size_t dynamic_count;
    Elf32_Word dynamic_flags;
    phdr_table_get_dynamic_section(phdr, phnum, base, &amp;si-&gt;dynamic,     // 定位dynamic section
                                       &amp;dynamic_count, &amp;dynamic_flags);     // 

 2. 解析Dynamic section
 3. 调用find_library, 返回所有依赖的.so的soinfo指针并存放在数组中.
 4. 重定位(处理plt_rel(延迟绑定)和rel):
    可以看到, 处理两个重定位表的函数都是soinfo_relocate函数.
    if (si-&gt;plt_rel != NULL) {
        DEBUG(&quot;[ relocating %s plt ]&quot;, si-&gt;name );
        if (soinfo_relocate(si, si-&gt;plt_rel, si-&gt;plt_rel_count, needed)) {
            return false;
        }
    }
    if (si-&gt;rel != NULL) {
        DEBUG(&quot;[ relocating %s ]&quot;, si-&gt;name );
        if (soinfo_relocate(si, si-&gt;rel, si-&gt;rel_count, needed)) {       
            return false;
        }
    }       
</code></pre>

<p>现在分析soinfo_relocate函数</p>

<pre><code class="language-cpp">












</code></pre>


    

    


</article>



        </div>

        <aside class="col-12 col-lg-3 ml-auto blog-sidebar">
    
        


    
    
        <section>
    
        
    
        
        <h4>Categories</h4>
        <p>
            
            <a class="badge badge-primary" href="/categories/android">android</a>
            
            <a class="badge badge-primary" href="/categories/life">life</a>
            
            <a class="badge badge-primary" href="/categories/vuls">vuls</a>
            
        </p>
        
    
        
        <h4>Tags</h4>
        <p>
            
            <a class="badge badge-primary" href="/tags/android">android</a>
            
            <a class="badge badge-primary" href="/tags/android%E6%BA%90%E7%A0%81">android源码</a>
            
            <a class="badge badge-primary" href="/tags/capstone">capstone</a>
            
            <a class="badge badge-primary" href="/tags/jni">jni</a>
            
            <a class="badge badge-primary" href="/tags/%E5%8A%A0%E5%9B%BA">加固</a>
            
            <a class="badge badge-primary" href="/tags/%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F">文件格式</a>
            
            <a class="badge badge-primary" href="/tags/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB">日常生活</a>
            
            <a class="badge badge-primary" href="/tags/%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6">漏洞研究</a>
            
        </p>
        
    
</section>
    
</aside>

      </div>
    </div>
    

    
      






<footer class="blog-footer w-100">
    <nav class="navbar navbar-light bg-light">
        <p class="w-100 text-center">Hugo template made with ❤ by <a href="https://github.com/Xzya">Xzya</a>, inspired by <a href="https://github.com/alanorth/hugo-theme-bootstrap4-blog">hugo-theme-bootstrap4-blog</a></p>
        <p class="w-100 text-center"><a href="#">Back to top</a></p>
    </nav>
</footer>

    

    
    
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js" integrity="sha384-smHYKdLADwkXOn1EmN1qk/HfnUcbVRZyYmZ4qpPea6sjB/pTJ0euyQp0Mk8ck+5T" crossorigin="anonymous"></script>
  </body>
</html>
