<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Kaleidoscope: Implementing a Parser and AST - L0phTg&#39;s Blog</title>
  <link rel="alternate" hreflang="zh-cn" href="https://l0phtg.github.io/" />

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="L0phTg" />
  <meta name="description" content="translate from: http://llvm.org/docs/tutorial/LangImpl02.html
介绍AST(抽象语法树)和Parser.

" />

  <meta name="keywords" content="Hugo, theme, jane" />






<meta name="generator" content="Hugo 0.49-DEV" />


<link rel="canonical" href="https://l0phtg.github.io/post/llvm/kaleidoscope-implementing-a-parser-and-ast/" />



<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" href="/favicon.ico" />
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<link href="/dist/jane.min.css?v=2.7.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">



<link rel="stylesheet" href="/css/styles/dracula.css">

<link rel="stylesheet" href="/css/mermaid.css">


<meta property="og:title" content="Kaleidoscope: Implementing a Parser and AST" />
<meta property="og:description" content="translate from: http://llvm.org/docs/tutorial/LangImpl02.html



介绍AST(抽象语法树)和Parser.

" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://l0phtg.github.io/post/llvm/kaleidoscope-implementing-a-parser-and-ast/" /><meta property="article:published_time" content="2019-04-11T15:41:17&#43;08:00"/>
<meta property="article:modified_time" content="2019-04-12T16:54:10&#43;08:00"/>
<meta itemprop="name" content="Kaleidoscope: Implementing a Parser and AST">
<meta itemprop="description" content="translate from: http://llvm.org/docs/tutorial/LangImpl02.html



介绍AST(抽象语法树)和Parser.

">


<meta itemprop="datePublished" content="2019-04-11T15:41:17&#43;08:00" />
<meta itemprop="dateModified" content="2019-04-11T15:41:17&#43;08:00" />
<meta itemprop="wordCount" content="3648">



<meta itemprop="keywords" content="llvm,Kaleidoscope," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Kaleidoscope: Implementing a Parser and AST"/>
<meta name="twitter:description" content="translate from: http://llvm.org/docs/tutorial/LangImpl02.html



介绍AST(抽象语法树)和Parser.

"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});  // 内联公式
  MathJax.Hub.Config({                                                      // support color
  showProcessingMessages: false,
  jax: ["input/TeX", "output/HTML-CSS"],
  TeX: {
    TagSide: "left",
    Macros: {
      RR: '{\\bf R}',
      bold: ['{\\bf #1}',1]
    }
  }
});
</script>


</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">L0phTg&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="https://gohugo.io">
        <li class="mobile-menu-item">external-link</li>
      </a>
  </ul>
</nav>

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      L0phTg&#39;s Blog
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
      <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="/">Home</a>
          

        

      </li>
    
      <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="/post/">Archives</a>
          

        

      </li>
    
      <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="/tags/">Tags</a>
          

        

      </li>
    
      <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="/categories/">Categories</a>
          

        

      </li>
    
      <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="/about/">About</a>
          

        

      </li>
    
      <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://gohugo.io" rel="noopener" target="_blank">
              external-link
            <i class="iconfont icon-new-window"></i>
            </a>
          

        

      </li>
    
  </ul>
</nav>
  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">Kaleidoscope: Implementing a Parser and AST</h1>
      
      <div class="post-meta">
        <span class="post-time"> 2019-04-11 </span>
        <div class="post-category">
            
              <a href="/categories/llvm/"> llvm </a>
            
          </div>
        <span class="more-meta"> 约 3648 字 </span>
        <span class="more-meta"> 预计阅读 8 分钟 </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li><a href="#2-1-introduction">2.1 Introduction</a></li>
<li><a href="#2-2-ast">2.2 AST</a></li>
<li><a href="#2-3-parser-basic">2.3 Parser Basic</a></li>
<li><a href="#2-4-basic-expression-parsing">2.4 Basic Expression Parsing</a></li>
<li><a href="#2-5-binary-expression-parsing">2.5 Binary Expression Parsing</a>
<ul>
<li><a href="#example">Example</a></li>
</ul></li>
<li><a href="#2-6-parse-the-rest">2.6 Parse the Rest</a></li>
<li><a href="#2-7-the-driver">2.7 The Driver</a></li>
<li><a href="#2-8-conclusions">2.8 Conclusions</a></li>
<li><a href="#2-9-full-code-listing">2.9 Full Code Listing</a></li>
</ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <p>translate from: <a href="http://llvm.org/docs/tutorial/LangImpl02.html">http://llvm.org/docs/tutorial/LangImpl02.html</a></p>

<p><img src="/docs-pic/dots/uml/ExprAst-1.png" alt="" /></p>

<p>介绍AST(抽象语法树)和Parser.</p>

<p></p>

<h1 id="2-1-introduction">2.1 Introduction</h1>

<p>本章介绍如何使用<strong>Lexer</strong>, 来build一个完整的<strong>parser</strong> for our Kaleidoscope language. 一旦我们有了parser, 我们将会定义并且build 一个 AST.</p>

<h1 id="2-2-ast">2.2 AST</h1>

<p><img src="/llvm/chapter2-AST.png" alt="Chapter2 AST" /></p>

<h1 id="2-3-parser-basic">2.3 Parser Basic</h1>

<p>现在我们有了AST, 我们需要定义parser code来build it. 这里的想法是我们要解析类似于&rdquo;<strong>x+y</strong>&rdquo;(由词法分析器会返回3个Token)到AST中, 可以通过下面的代码产生:</p>

<pre><code class="language-c++">auto LHS = llvm::make_unique&lt;VariableExprAST&gt;(&quot;x&quot;);
auto RHS = llvm::make_unique&lt;VariableExprAST&gt;(&quot;y&quot;);
auto Result = std::make_unique&lt;BinaryExprAST&gt;('+', std::move(LHS),
                                              std::move(RHS));
</code></pre>

<p>Log</p>

<pre><code class="language-c++">/// LogError* - These are little helper functions for error handling.
std::unique_ptr&lt;ExprAST&gt; LogError(const char *Str) {
  fprintf(stderr, &quot;LogError: %s\n&quot;, Str);
  return nullptr;
}
std::unique_ptr&lt;PrototypeAST&gt; LogErrorP(const char *Str) {
  LogError(Str);
  return nullptr;
}
</code></pre>

<h1 id="2-4-basic-expression-parsing">2.4 Basic Expression Parsing</h1>

<p><strong>ParseNumberExpr</strong>:</p>

<pre><code class="language-c++">/// numberexpr ::= number
static std::unique_ptr&lt;ExprAST&gt; ParseNumberExpr() {
  auto Result = llvm::make_unique&lt;NumberExprAST&gt;(NumVal);
  getNextToken(); // consume the number
  return std::move(Result);
}
</code></pre>

<p><strong>ParseParenExpr</strong>:</p>

<p>这里有一些有趣的点. 最主要的一点是 this routine eats all of the tokens that correspond to the production. 并且将next token返回到词法缓冲区中. (这不是一定要要求的), 这是一个实现递归下降parser的相当标准的写法.</p>

<p>a better example, 括号运算符的parser defined like this:</p>

<pre><code class="language-c++">/// parenexpr ::= '(' expression ')'
static std::unique_ptr&lt;ExprAST&gt; ParseParenExpr() {  
  getNextToken(); // eat (.
  auto V = ParseExpression();
  if (!V)
    return nullptr;

  if (CurTok != ')')
    return LogError(&quot;expected ')'&quot;);
  getNextToken(); // eat ).
  return V;
}
</code></pre>

<p>该函数说明了大量关于parser的有趣的事情:</p>

<p>1) 展示了我们可以怎么样使用<strong>LogError</strong>. 当被调用的时候, 该函数期待current token是 &lsquo;<strong>(</strong>&rsquo;, 然后之后开始解析subexpression, (可能没有&rsquo;)&rsquo; waiting), 如果用户输入&rdquo;(4 x&rdquo; 代替 &ldquo;(4)&rdquo;, the parser应该弹一个error. 因为error发生了, parser需要一种方法来表明error发生时, 程序会做什么.在我们的解析器中, 当<strong>error</strong>发生时, 我们会返回<strong>null</strong>.</p>

<p>2) 另一个有趣的点是<strong>该函数使用了递归来调用ParserExpression</strong>(我们不久将会看到<strong>ParserExpression</strong>中调用了<strong>ParserParentExpr</strong>). 这是一种处理递归语法的相当不错的方法. 并且它保证每个过程都十分simple. 注意, <strong>括号并不会引起AST node的构造</strong>. 当我们这样做的时候, 括号最重要的角色就是<strong>知道parser来提供grouping</strong>. 一旦parser成功构造了AST, 括号就不再被需要的.</p>

<p>下面的例子是处理变量引用和函数调用:</p>

<p>变量后面跟括号, 代表函数调用. 如果不是, 代码变量为identifier.</p>

<h1 id="2-5-binary-expression-parsing">2.5 Binary Expression Parsing</h1>

<p>二元表达式很难解析, 因为它们通常是模棱两可的. 例如, 当给 the string &ldquo;x+y*z&rdquo;, the parser可以选择&rdquo;(x+y)*z&rdquo;, 也可以选择&rdquo;x+(y<em>z)&ldquo;, 根据数学的定义, 我们的理解后面的是正确的. 因为 &ldquo;</em>&ldquo;的优先级比&rdquo;+&ldquo;更高.</p>

<p>有很多种方法来处理它, 但是一种优雅的和有效的方法是<strong>Operator-Precedence-Parsing</strong>. 这种解析技术使用优先级来指导二元操作符递归处理. To start with, we need a table of precedences:</p>

<pre><code class="language-c++">/// BinopPrecedence - This holds the precedence for each binary operator that is
/// defined.
static std::map&lt;char, int&gt; BinopPrecedence;

/// GetTokPrecedence - Get the precedence of the pending binary operator token.
static int GetTokPrecedence() {
  if (!isascii(CurTok))
    return -1;

  // Make sure it's a declared binop.
  int TokPrec = BinopPrecedence[CurTok];
  if (TokPrec &lt;= 0) return -1;
  return TokPrec;
}

int main() {
  // Install standard binary operators.
  // 1 is lowest precedence.
  BinopPrecedence['&lt;'] = 10;
  BinopPrecedence['+'] = 20;
  BinopPrecedence['-'] = 20;
  BinopPrecedence['*'] = 40;  // highest.
  ...
}
</code></pre>

<p>对于Kaleidoscope基本的形式来说, 我们只支持4种二元操作符(很明显你可以扩展它, our brave and interpid reader). The <strong>GetTokPrecedence</strong>返回目前token的优先级, 如果<strong>不是二元操作符的话, 返回 -1</strong>. 通过一个map来增加一些操作符是一种不错的方法. 并且这很容易比较优先级.</p>

<p>有了上面的定义, 我们就可以解析二元操作符了. 运算符优先级解析的基本思想是:<strong>将具有可能不明确的二元运算符的表达式分成多个</strong>.</p>

<p>Ex: 表达式&rdquo;<strong>a+b+(c+d)*e*f+g</strong>. operator precedence 将该表达式视为一个primary expressions流 separated by binary operators. 它将会先解析<strong>a</strong>, 然后[+, b] [+, (c+d)] [<em>, e] [</em>, f] and [+, g]. 注意括号也是primary expressions. 二元表达式不用担心它的subexpressions like (c+d) at all .</p>

<p>To start, an expression is a primary expression. 可能后面跟着[binop, primaryexpr].</p>

<pre><code class="language-c++">/// expression
///   ::= primary binoprhs
///
static std::unique_ptr&lt;ExprAST&gt; ParseExpression() {
  auto LHS = ParsePrimary();
  if (!LHS)
    return nullptr;

  return ParseBinOpRHS(0, std::move(LHS));
}
</code></pre>

<p><strong>ParseBinOpRHS</strong>是一个函数来解析一系列的<strong>pairs</strong>. 它需要一个优先级和指向表达式的指针.</p>

<p>注意 that &ldquo;<strong>x</strong>&rdquo; 是一个完全有效的表达式, 例如: &ldquo;binoprhs&rdquo; 可以是空的. 在这种情况下, it returns the expression that is passed into it. 在我们上面的例子中, 代码传递表达式&rdquo;a&rdquo;到ParseBinOpRHS 并且当前的token是 &ldquo;+&rdquo;;</p>

<p>传递给ParseBinOpRHS的优先级值表示函数被允许eat 的 the minimal operator precedence.
例如, 如果目前的pair stream is [+, x] and ParseBinOpRHS被传递的优先级是40, 它将不会消耗任何tokens(因为&rsquo;+&lsquo;的优先级是20). 根据这种思想, ParseBinOpRHS starts with:</p>

<pre><code class="language-c++">/// binoprhs
///   ::= ('+' primary)*
static std::unique_ptr&lt;ExprAST&gt; ParseBinOpRHS(int ExprPrec,
                                              std::unique_ptr&lt;ExprAST&gt; LHS) {
  // If this is a binop, find its precedence.
  while (1) {
    int TokPrec = GetTokPrecedence();

    // If this is a binop that binds at least as tightly as the current binop,
    // consume it, otherwise we are done.
    if (TokPrec &lt; ExprPrec)
      return LHS;
</code></pre>

<p>该代码获得当前token的优先级, 并且检查它是否是too low. 因为我们定义无效的tokens的优先级是-1, 所以这隐式地可以知道(当run out of binary operators时, pair-stream就结束了).如果this check succeed, 我们知道token是一个二元表达式并且它将被included in this expression:</p>

<pre><code class="language-c++">    // Okay, we know this is a binop.
    int BinOp = CurTok;
    getNextToken();  // eat binop
    
    // Parse the primary expression after the binary operator.
    auto RHS = ParsePrimary();
    if (!RHS)
      return nullptr;
</code></pre>

<p>As such, this code eats(and remembers) 二元表达式 and 解析primary expression that follows. This build up the whole pair, the first of which is [+, b] for the running example.</p>

<p>现在我们解析表达式的左边和一组RHS sequence, 我们不得不决定which way the expression associates. 特别地, 我们 have &ldquo;(a+b)&rdquo; binop unparsed or &ldquo;a+(b binop unparsed&rdquo;. 为了确定这个, 我们look ahead at &ldquo;binop&rdquo; to 确定它的优先级并且将它与BinOp&rsquo;s 优先级比较(which is &lsquo;+&rsquo; in this case):</p>

<pre><code class="language-c++">// If BinOp binds less tightly with RHS than the operator after RHS, let
// the pending operator take RHS as its LHS.
int NextPrec = GetTokPrecedence();
if (TokPrec &lt; NextPrec) {
</code></pre>

<p>如果binop在&rdquo;RHS&rdquo;右侧的优先级低于或者等于我们当前运算符的优先级. in our example, 目前的操作符是&rdquo;+&rdquo; 并且下一个操作符是&rdquo;+&ldquo;, 我们明白他们有相同的优先级. in this case 我们将会创建node for &ldquo;a+b&rdquo;, and then continue parsing:</p>

<pre><code class="language-c++">      ... if body omitted ...
    }

    // Merge LHS/RHS.
    LHS = llvm::make_unique&lt;BinaryExprAST&gt;(BinOp, std::move(LHS),
                                           std::move(RHS));
  }  // loop around to the top of the while loop.
}
</code></pre>

<p>在我们的例子中. 这将把 &ldquo;a + b&rdquo; into &ldquo;(a + b)&ldquo;并且来执行下一次循环的迭代. with &ldquo;+&rdquo; as the current token. 上面的代码将被eat, remember, and parse (&ldquo;c + d&rdquo;) as the primary expression, which makes the 目前的pair equal to [+, (c + d)]. 它将会评估上面的&rdquo;if&rdquo;条件, 并将&rdquo;<em>&ldquo;作为右侧的binop. 在该case中, 优先级 of &ldquo;</em>&rdquo; 是比+的优先级更高, 因此if条件将会被输入.</p>

<p>关键的问题是: if条件如何解析右边的全部? In particular, 为了在我们的例子中正确的build AST. 它需要将&rdquo;(c + d)*e*f&rdquo;作为RHS表达式变量. 执行该操作的代码相当简单.</p>

<pre><code class="language-c++">    // If BinOp binds less tightly with RHS than the operator after RHS, let
    // the pending operator take RHS as its LHS.
    int NextPrec = GetTokPrecedence();
    if (TokPrec &lt; NextPrec) {
      RHS = ParseBinOpRHS(TokPrec+1, std::move(RHS));
      if (!RHS)
        return nullptr;
    }
    // Merge LHS/RHS.
    LHS = llvm::make_unique&lt;BinaryExprAST&gt;(BinOp, std::move(LHS),
                                           std::move(RHS));
  }  // loop around to the top of the while loop.
}
</code></pre>

<p>在这一点上, 我们知道我们主要的RHS的二元运算符优于我们当前正在解析的binop. 因此, 我们知道任何运算符都优先于&rdquo;+&ldquo;的序列应该一起解析并作为&rdquo;RHS&rdquo;返回.</p>

<h2 id="example">Example</h2>

<p>递归构造.</p>

<p><code>a+b*c*(d+e) + f</code>:</p>

<p>第一次循环:</p>

<pre><code>&lt;!--1. [0, a] 和 [+, b]; [0, a] 为LHS; 0 &lt; +,  [1+, b] 继续ParseBinOpRHS--&gt;
&lt;!--2. [+, b] 和 [*, c]; [+, b] 为LHS; + &lt; *,  [*, c] 继续ParseBinOpRHS--&gt;
&lt;!--3. [*, c] 和 [(), d+e]; [*, c]为LHS     --&gt;
</code></pre>

<div class="mermaid">
graph TB
    1((a)) 
    2((b))
    3((c))
    4((d))
    5((e))
    
    7((+))
    8((*))
    9((*))
    10((+))
    
    7 --> 1
    
    8 --> 2
    8 --> 3
    9 --> 8
    9 --> 10
    10 --> 4
    10 --> 5
    
    7 --> 9
</div>

<p>第二次循环</p>

<div class="mermaid">
graph TB
    1((a)) 
    2((b))
    3((c))
    4((d))
    5((e))
    6((f))
    7((+))
    8((*))
    9((*))
    10((+))
    11((+))
    
    7 --> 1
    
    8 --> 2
    8 --> 3
    9 --> 8
    9 --> 10
    10 --> 4
    10 --> 5
    
    7 --> 9
    
    subgraph TB
    11 --> 7
    11 --> 6
    end
</div>

<h1 id="2-6-parse-the-rest">2.6 Parse the Rest</h1>

<p>下一件事情是解析函数申明. in Kaleidoscope, <code>extern</code>函数申明以及函数体定义. 代码是相当直接的, not very interesting(once you&rsquo;re survived expressions):</p>

<pre><code class="language-c++">/// prototype
///   ::= id '(' id* ')'
static std::unique_ptr&lt;PrototypeAST&gt; ParsePrototype() {
  if (CurTok != tok_identifier)
    return LogErrorP(&quot;Expected function name in prototype&quot;);

  std::string FnName = IdentifierStr;
  getNextToken();

  if (CurTok != '(')
    return LogErrorP(&quot;Expected '(' in prototype&quot;);

  // Read the list of argument names.
  std::vector&lt;std::string&gt; ArgNames;
  while (getNextToken() == tok_identifier)
    ArgNames.push_back(IdentifierStr);
  if (CurTok != ')')
    return LogErrorP(&quot;Expected ')' in prototype&quot;);

  // success.
  getNextToken();  // eat ')'.

  return llvm::make_unique&lt;PrototypeAST&gt;(FnName, std::move(ArgNames));
}
</code></pre>

<p>当然了, 函数定义是相当简单的, just <strong>一个申明</strong>加<strong>一个表达式</strong>来实现函数体.</p>

<pre><code class="language-c++">/// definition ::= 'def' prototype expression
static std::unique_ptr&lt;FunctionAST&gt; ParseDefinition() {
  getNextToken();  // eat def.
  auto Proto = ParsePrototype();
  if (!Proto) return nullptr;

  if (auto E = ParseExpression())
    return llvm::make_unique&lt;FunctionAST&gt;(std::move(Proto), std::move(E));
  return nullptr;
}
</code></pre>

<p>另外，我们支持<code>extern</code>来声明<code>sin</code>和<code>cos</code>之类的函数，以及支持用户函数的前向声明。这些<code>extern</code>只是没有身体的原型:</p>

<pre><code class="language-c++">/// external ::= 'extern' prototype
static std::unique_ptr&lt;PrototypeAST&gt; ParseExtern() {
  getNextToken();  // eat extern.
  return ParsePrototype();
}
</code></pre>

<p>最后, 我们让用户输入任意顶级表达式并evaluate them. 我们将会处理this by defining anonymous nullary(zero argument) functions for them:</p>

<pre><code class="language-c++">/// toplevelexpr ::= expression
static std::unique_ptr&lt;FunctionAST&gt; ParseTopLevelExpr() {
  if (auto E = ParseExpression()) {
    // Make an anonymous proto.
    auto Proto = llvm::make_unique&lt;PrototypeAST&gt;(&quot;&quot;, std::vector&lt;std::string&gt;());
    return llvm::make_unique&lt;FunctionAST&gt;(std::move(Proto), std::move(E));
  }
  return nullptr;
}

</code></pre>

<p>现在我们have all the pieces, let&rsquo;s build a little driver that will let us actually execute this code we&rsquo;ve built!</p>

<h1 id="2-7-the-driver">2.7 The Driver</h1>

<p>The Driver仅仅是通过调用所有的解析pieces.</p>

<pre><code class="language-c++">/// top ::= definition | external | expression | ';'
static void MainLoop() {
  while (1) {
    fprintf(stderr, &quot;ready&gt; &quot;);
    switch (CurTok) {
    case tok_eof:
      return;
    case ';': // ignore top-level semicolons.
      getNextToken();
      break;
    case tok_def:
      HandleDefinition();
      break;
    case tok_extern:
      HandleExtern();
      break;
    default:
      HandleTopLevelExpression();
      break;
    }
  }
}
</code></pre>

<p>一件有趣的事情是:  我们忽略了顶级&rdquo;;&ldquo;.</p>

<h1 id="2-8-conclusions">2.8 Conclusions</h1>

<p>通过这仅仅400行的代码, 我们定义了我们的最小的语言, 包含一个词法分析器, 解析器, 和AST builder.</p>

<p>这是一个简单的交互例子:</p>

<pre><code class="language-bash">$ ./a.out
ready&gt; def foo(x y) x+foo(y, 4.0);
Parsed a function definition.
ready&gt; def foo(x y) x+y y;
Parsed a function definition.
Parsed a top-level expr
ready&gt; def foo(x y) x+y );
Parsed a function definition.
Error: unknown token when expecting an expression
ready&gt; extern sin(a);
ready&gt; Parsed an extern
ready&gt; ^D
$
</code></pre>

<h1 id="2-9-full-code-listing">2.9 Full Code Listing</h1>

<p><a href="http://llvm.org/docs/tutorial/LangImpl02.html#the-abstract-syntax-tree-ast">http://llvm.org/docs/tutorial/LangImpl02.html#the-abstract-syntax-tree-ast</a></p>
    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">L0phTg</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">2019-04-12</span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content">原创文章，如需转载请注明文章作者和出处。谢谢！</span>
  </p>
</div>

    
    

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/llvm/">llvm</a>
          
          <a href="/tags/kaleidoscope/">Kaleidoscope</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/llvm/kaleidoscope-code-generation-to-llvm-ir/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Kaleidoscope: Code Generation to LLVM IR</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        
          <a class="next" href="/post/kaleidoscope-tutorial-introduction-and-lexer/">
            <span class="next-text nav-default">Kaleidoscope: Tutorial Introduction and Lexer</span>
            <span class="prev-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
    
  </article>
        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="l0phtg:l0phtg@163.com" rel="me noopener" class="iconfont icon-email"
        title="email" target="_blank">
      </a>
      <a href="https://google.com" rel="me noopener" class="iconfont icon-google"
        title="google" target="_blank">
      </a>
      <a href="https://github.com/l0phtg" rel="me noopener" class="iconfont icon-github"
        title="github" target="_blank">
      </a>
  <a href="https://l0phtg.github.io/index.xml" rel="noopener" type="application/rss+xml" class="iconfont icon-rss"
    title="rss" target="_blank">
  </a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2018 -
    2019
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span><span class="author">l0phtg</span></span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>
<script type="text/javascript" src="/dist/jane.min.js?v=2.7.0"></script>





<script src="/js/highlight.pack.js"></script>

<script src="/js/mermaid.min.js"></script>


<script>hljs.initHighlightingOnLoad();</script>
<script> mermaid.initialize({ startOnLoad: true });</script>

</body>
</html>
