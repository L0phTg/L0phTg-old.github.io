<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>elf文件格式和AndroidLinker加载.so的源码分析 - L0phTg&#39;s Blog</title>
  <link rel="alternate" hreflang="zh-cn" href="https://l0phtg.github.io/" />

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="L0phTg" />
  <meta name="description" content="最近在学习android应用的加壳和混淆方法, 所以遇到了一些有关.so是如何加载到android中去的问题, 看了一些视频和文章, 所以想在此总结一下.
本文主要内容:
 elf的文件格式 分析linker的源码, 主要dlopen流程.  
" />

  <meta name="keywords" content="Hugo, theme, jane" />






<meta name="generator" content="Hugo 0.49-DEV" />


<link rel="canonical" href="https://l0phtg.github.io/post/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%92%8Candroidlinker%E5%8A%A0%E8%BD%BD-so%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" />



<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" href="/favicon.ico" />
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<link href="/dist/jane.min.css?v=2.7.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">



<link rel="stylesheet" href="/css/styles/dracula.css">


<meta property="og:title" content="elf文件格式和AndroidLinker加载.so的源码分析" />
<meta property="og:description" content="最近在学习android应用的加壳和混淆方法, 所以遇到了一些有关.so是如何加载到android中去的问题, 看了一些视频和文章, 所以想在此总结一下.

本文主要内容:


elf的文件格式
分析linker的源码, 主要dlopen流程.


" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://l0phtg.github.io/post/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%92%8Candroidlinker%E5%8A%A0%E8%BD%BD-so%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" /><meta property="article:published_time" content="2017-03-19T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2019-04-03T19:59:08&#43;08:00"/>
<meta itemprop="name" content="elf文件格式和AndroidLinker加载.so的源码分析">
<meta itemprop="description" content="最近在学习android应用的加壳和混淆方法, 所以遇到了一些有关.so是如何加载到android中去的问题, 看了一些视频和文章, 所以想在此总结一下.

本文主要内容:


elf的文件格式
分析linker的源码, 主要dlopen流程.


">


<meta itemprop="datePublished" content="2017-03-19T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2017-03-19T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="3525">



<meta itemprop="keywords" content="文件格式,Android源码," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="elf文件格式和AndroidLinker加载.so的源码分析"/>
<meta name="twitter:description" content="最近在学习android应用的加壳和混淆方法, 所以遇到了一些有关.so是如何加载到android中去的问题, 看了一些视频和文章, 所以想在此总结一下.

本文主要内容:


elf的文件格式
分析linker的源码, 主要dlopen流程.


"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});  // 内联公式
  MathJax.Hub.Config({                                                      // support color
  showProcessingMessages: false,
  jax: ["input/TeX", "output/HTML-CSS"],
  TeX: {
    TagSide: "left",
    Macros: {
      RR: '{\\bf R}',
      bold: ['{\\bf #1}',1]
    }
  }
});
</script>


</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">L0phTg&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="https://gohugo.io">
        <li class="mobile-menu-item">external-link</li>
      </a>
  </ul>
</nav>

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      L0phTg&#39;s Blog
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
      <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="/">Home</a>
          

        

      </li>
    
      <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="/post/">Archives</a>
          

        

      </li>
    
      <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="/tags/">Tags</a>
          

        

      </li>
    
      <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="/categories/">Categories</a>
          

        

      </li>
    
      <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="/about/">About</a>
          

        

      </li>
    
      <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://gohugo.io" rel="noopener" target="_blank">
              external-link
            <i class="iconfont icon-new-window"></i>
            </a>
          

        

      </li>
    
  </ul>
</nav>
  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">elf文件格式和AndroidLinker加载.so的源码分析</h1>
      
      <div class="post-meta">
        <span class="post-time"> 2017-03-19 </span>
        <div class="post-category">
            
              <a href="/categories/android/"> Android </a>
            
          </div>
        <span class="more-meta"> 约 3525 字 </span>
        <span class="more-meta"> 预计阅读 8 分钟 </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#elf文件格式">elf文件格式</a></li>
<li><a href="#android-linker加载-so的源码分析">Android Linker加载.so的源码分析</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <p>最近在学习android应用的加壳和混淆方法, 所以遇到了一些有关.so是如何加载到android中去的问题, 看了一些视频和文章, 所以想在此总结一下.</p>

<p>本文主要内容:</p>

<ul>
<li>elf的文件格式</li>
<li>分析linker的源码, 主要dlopen流程.</li>
</ul>

<p></p>

<h2 id="elf文件格式">elf文件格式</h2>

<p>本文只对elf文件格式进行简单的分析, 如果要进行深入的了解, 推荐<code>&lt;&lt;程序员的自我修养&gt;&gt;</code>中第3章.</p>

<p>/usr/includ/elf.h中定义了elf文件头结构和相关的常数.</p>

<p>分析elf文件时, 建议使用<code>010 editor</code>这款十六进制编辑软件, 运行elf模板后可以清晰的将文件格式显示出来, 大致的显示是(坑, 此处应该用图片的)</p>

<pre><code class="language-c">                NAME                           Value            Start       Size        Color       Comment
    struct file                                                 0h          109Ch
        struct elf_header                                       0h          34h
        struct program_header_table                             34h         120h
        struct section_header_table                             1B274h      460h
        struct dynamic_symbol_table                             18Ch        F10h
</code></pre>

<p>可以看到, 一个elf文件中包含一个header, 3个table, 我们一个一个的来分析一下.
首先分析<code>Elf header</code>, 它位于每一个elf文件开始的地方:</p>

<pre><code class="language-c">typedef struct                                                            typedef struct
{                                                                         {
    unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */     unsigned char e_ident[EI_NIDENT];
    Elf32_Half    e_type;         /* Object file type */                    Elf64_Half    e_type;     
    Elf32_Half    e_machine;      /* Architecture */                        Elf64_Half    e_machine;  
    Elf32_Word    e_version;      /* Object file version */                 Elf64_Word    e_version;  
    Elf32_Addr    e_entry;        /* Entry point virtual address */         Elf64_Addr    e_entry;    
    Elf32_Off e_phoff;        /* Program header table file offset */        Elf64_Off e_phoff;        
    Elf32_Off e_shoff;        /* Section header table file offset */        Elf64_Off e_shoff;        
    Elf32_Word    e_flags;        /* Processor-specific flags */            Elf64_Word    e_flags;    
    Elf32_Half    e_ehsize;       /* ELF header size in bytes */            Elf64_Half    e_ehsize;   
    Elf32_Half    e_phentsize;        /* Program header table entry size */ Elf64_Half    e_phentsize;
    Elf32_Half    e_phnum;        /* Program header table entry count */    Elf64_Half    e_phnum;    
    Elf32_Half    e_shentsize;        /* Section header table entry size */ Elf64_Half    e_shentsize;
    Elf32_Half    e_shnum;        /* Section header table entry count */    Elf64_Half    e_shnum;    
    Elf32_Half    e_shstrndx;     /* Section header string table index */   Elf64_Half    e_shstrndx; 
} Elf32_Ehdr;                                                              } Elf64_Ehdr;
</code></pre>

<p>可以看到, header中包含了magic number, 文件类型, 目标文件版本, 入口地址(如果为0, 说明此文件为可重定位文件), program header的开始地址(即为在so文件中的offset), section header的开始地址, 标志位, elf头本身的大小, program header和section header的size和数量, 最后是section header中string section在section中的下标.(用010 editor可以看到清楚的看到一个.so文件包含众多的program header 和 section header, 这两个段在做.so混淆时会经常分析)</p>

<p>现在分析<code>program header</code></p>

<pre><code class="language-c">/* Program segment header.  */

typedef struct                                                      typedef struct
{                                                                   {
    Elf32_Word    p_type;         /* Segment type */                    Elf64_Word    p_type;   
    Elf32_Off p_offset;       /* Segment file offset */                 Elf64_Off p_offset;     
    Elf32_Addr    p_vaddr;        /* Segment virtual address */         Elf64_Addr    p_vaddr;  
    Elf32_Addr    p_paddr;        /* Segment physical address */        Elf64_Addr    p_paddr;  
    Elf32_Word    p_filesz;       /* Segment size in file */            Elf64_Word    p_filesz; 
    Elf32_Word    p_memsz;        /* Segment size in memory */          Elf64_Word    p_memsz;  
    Elf32_Word    p_flags;        /* Segment flags */                   Elf64_Word    p_flags;  
    Elf32_Word    p_align;        /* Segment alignment */               Elf64_Word    p_align;  
} Elf32_Phdr;                                                       } Elf64_Phdr;
</code></pre>

<p>接下来分析<code>section header</code>, section相信了解过汇编的同学都非常熟悉了, 这个section header里面就存放了我们elf中各个段的信息.
看一下section header段描述符的结构:(64位的与32位的结构体大致相同, 只是把类型改为了Elf64的类型)</p>

<pre><code class="language-c">typedef struct
{
    Elf32_Word    sh_name;        /* Section name (string tbl index) 段名*/
    Elf32_Word    sh_type;        /* Section type 段类型*/
    Elf32_Word    sh_flags;       /* Section flags 标志位*/
    Elf32_Addr    sh_addr;        /* Section virtual addr at execution 段虚拟地址*/
    Elf32_Off sh_offset;          /* Section file offset 段偏移*/
    Elf32_Word    sh_size;        /* Section size in bytes 段的长度*/
    Elf32_Word    sh_link;        /* Link to another section 段的链接信息*/
    Elf32_Word    sh_info;        /* Additional section information 段链接的相关信息*/
    Elf32_Word    sh_addralign;   /* Section alignment 段地址对齐*/
    Elf32_Word    sh_entsize;     /* Entry size if section holds table 项的长度*/
} Elf32_Shdr;
</code></pre>

<p>最后分析动态符号表(<code>symbol table</code>):</p>

<pre><code class="language-c">typedef struct
{
    Elf32_Word    st_name;        /* Symbol name (string tbl index) */
    Elf32_Addr    st_value;       /* Symbol value */
    Elf32_Word    st_size;        /* Symbol size */
    unsigned char st_info;        /* Symbol type and binding */
    unsigned char st_other;       /* Symbol visibility */
    Elf32_Section st_shndx;       /* Section index */
} Elf32_Sym;
</code></pre>

<p>包含的信息有符号名, 符号相对应的值, 符号大小, 符号类型和绑定信息, 符号所在的段.</p>

<h2 id="android-linker加载-so的源码分析">Android Linker加载.so的源码分析</h2>

<p>Android中的本地文件.so是通过Linker加载到内存中去并且执行的.(本文分析的源码为Android4.4.4)
                &mdash;- 推荐一款好用的源码阅读工具 source Insight</p>

<pre><code class="language-cpp">java层:  System.LoadLibrary(&quot;function&quot;);
native:         ---&gt;  Dalvik/vm/native/java_lang_Runtime.cpp: Dalvik_java_lang_Runtime_nativeLoad 
                        ---&gt;Dalvik/vm/Native.cpp: dvmLoadNativeCode(const char* fileName, Object* ClassLoader, char** reason)
                                ---&gt;bionic/linker/dlfcn.c: dlopen(const char* pathName, RTLD_LAZY)
                                        ---&gt;bionic/linker/linker.cpp: do_dlopen(const char* name, int flags)
</code></pre>

<ol>
<li>核心函数为<code>do_dlopen</code>:</li>
</ol>

<pre><code class="language-cpp">soinfo* do_dlopen(const char* name, int flags) {  // 函数的参数为
    if ((flags &amp; ~(RTLD_NOW|RTLD_LAZY|RTLD_LOCAL|RTLD_GLOBAL)) != 0) {
        DL_ERR(&quot;invalid flags to dlopen: %x&quot;, flags);
        return NULL;
    }
    set_soinfo_pool_protection(PROT_READ | PROT_WRITE); // 设置so信息池的访问权限为可读可写
    soinfo* si = find_library(name);                    // 找到name函数, 装载so, 并返回指向.soinfo的指针
    if (si != NULL) {
                      si-&gt;CallConstructors();           // 初始化so库
    }
    set_soinfo_pool_protection(PROT_READ);              // 设置so信息池的访问权限为只读
    return si;
}
</code></pre>

<ol>
<li>查看<code>find_library</code>函数可以发现它调用了<code>find_library_internal</code>函数,</li>
</ol>

<pre><code class="language-cpp">static soinfo* find_library(const char* name) {
    soinfo* si = find_library_internal(name);
    if (si != NULL) {
        si-&gt;ref_count++;
    }
    return si;
}
</code></pre>

<p>分析<code>find_library_internal</code>函数, 发现其主要调用了<code>load_library()</code>函数和 <code>soinfo_link_image()</code> 函数.
_</p>

<pre><code class="language-cpp">static soinfo* find_library_internal(const char* name) {
    if (name == NULL) {
        return somain;
    }
    soinfo* si = find_loaded_library(name);         // 判断.so是否完全加载, 如果加载: 返回有效的指针;如果没有加载, 返回null;
    if (si != NULL) {                               // 如果已经加载，返回
        if (si-&gt;flags &amp; FLAG_LINKED) {
            return si;
        }
        DL_ERR(&quot;OOPS: recursive link to \&quot;%s\&quot;&quot;, si-&gt;name);
        return NULL;
    }

    TRACE(&quot;[ '%s' has not been loaded yet.  Locating...]&quot;, name);  // 打印so还没有加载
    si = load_library(name);        // 加载.so
    if (si == NULL) {
        return NULL;
    }
    // At this point we know that whatever is loaded @ base is a valid ELF
    // shared library whose segments are properly mapped in.
    TRACE(&quot;[ init_library base=0x%08x sz=0x%08x name='%s' ]&quot;,
            si-&gt;base, si-&gt;size, si-&gt;name);

    if (!soinfo_link_image(si)) {       // 完成.so的重定位
        munmap(reinterpret_cast&lt;void*&gt;(si-&gt;base), si-&gt;size);
        soinfo_free(si);
        return NULL;
    }
    return si;
}
</code></pre>

<p>分析<code>load_library</code>函数, 会找到elf_read.<code>Load()</code>方法, 这个方法就是load</p>

<pre><code class="language-cpp">static soinfo* load_library(const char* name) {
// Open the file.
    int fd = open_library(name);                        // 打开文件, 获取fd
    if (fd == -1) {
        DL_ERR(&quot;library \&quot;%s\&quot; not found&quot;, name);
        return NULL;
    }

    // Read the ELF header and load the segments.
    ElfReader elf_reader(name, fd);                     // 初始化elfReader对象
    if (!elf_reader.Load()) {                           // 通过elfReader对象的Load()方法, 将so文件装载到内存
        return NULL;
    }

    const char* bname = strrchr(name, '/');
    soinfo* si = soinfo_alloc(bname ? bname + 1 : name);    // 分配so_info结构, 并按照装载结果更新相应的成员变量
    if (si == NULL) {
        return NULL;
    }
    si-&gt;base = elf_reader.load_start();
    si-&gt;size = elf_reader.load_size();
    si-&gt;load_bias = elf_reader.load_bias();
    si-&gt;flags = 0;
    si-&gt;entry = 0;
    si-&gt;dynamic = NULL;
    si-&gt;phnum = elf_reader.phdr_count();
    si-&gt;phdr = elf_reader.loaded_phdr();

    return si;
}

这里放一个ElfReader结构:
class ElfReader {
public:
    ElfReader(const char* name, int fd);
    ~ElfReader();

    bool Load();

    size_t phdr_count() { return phdr_num_; }
    Elf32_Addr load_start() { return reinterpret_cast&lt;Elf32_Addr&gt;(load_start_); }
    Elf32_Addr load_size() { return load_size_; }
    Elf32_Addr load_bias() { return load_bias_; }
    const Elf32_Phdr* loaded_phdr() { return loaded_phdr_; }

private:
    bool ReadElfHeader();
    bool VerifyElfHeader();
    bool ReadProgramHeader();
    bool ReserveAddressSpace();
    bool LoadSegments();
    bool FindPhdr();
    bool CheckPhdr(Elf32_Addr); 

    const char* name_;
    int fd_;    

    Elf32_Ehdr header_;
    size_t phdr_num_;   

    void* phdr_mmap_;
    Elf32_Phdr* phdr_table_;
    Elf32_Addr phdr_size_;  

    // First page of reserved address space.
    void* load_start_;
    // Size in bytes of reserved address space.
    Elf32_Addr load_size_;
    // Load bias.
    Elf32_Addr load_bias_;

    // Loaded phdr.
    const Elf32_Phdr* loaded_phdr_;
};
</code></pre>

<p>这里是<code>Load()</code>函数</p>

<pre><code class="language-cpp">bool ElfReader::Load() {
    return ReadElfHeader() &amp;&amp;                   // 读取
        VerifyElfHeader() &amp;&amp;                // 验证
        ReadProgramHeader() &amp;&amp;              // 读取Program header
        ReserveAddressSpace() &amp;&amp;            // 根据Program header计算so需要的内存size并分配相应的空间
        LoadSegments() &amp;&amp;                   // 将so按照segment为单位装载到内存
        FindPhdr();                     // on 装载到内存的so中找到program header, 方便以后链接过程use
}
</code></pre>

<ul>
<li>首先是<code>ReadElfHeader</code>()函数, 发现其是直接调用<code>read</code>函数读取到header中的.</li>
</ul>

<pre><code class="language-cpp">bool ElfReader::ReadElfHeader() {
    ssize_t rc = TEMP_FAILURE_RETRY(read(fd_, &amp;header_, sizeof(header_)));  // use read() function 直接将elfheader读取到header中
    ```//////////////////////////////
    return true;
}
</code></pre>

<ul>
<li><p>然后是<code>VerifyElfread</code>()函数, 对Elfheader进行验证识别: 是否为32位，大小端，类型和版本.</p></li>

<li><p>之后<code>ReadProgramHeader</code>()函数(加载program header table从elf文件到一个只读的私有匿名的mmap-ed block中):</p></li>
</ul>

<pre><code class="language-cpp">bool ElfReader::ReadProgramHeader() {
    phdr_num_ = header_.e_phnum;                                        
    //  将program header on内存中中单独映射一份, use于解析时临时use, on so装载到内存后, 便会释放这块内存, 转而使use装载后的so中的program header

    // Like the kernel, we only accept program header tables that
    // are smaller than 64KiB.
    if (phdr_num_ &lt; 1 || phdr_num_ &gt; 65536/sizeof(Elf32_Phdr)) {
        DL_ERR(&quot;\&quot;%s\&quot; has invalid e_phnum: %d&quot;, name_, phdr_num_);
        return false;
    }

    Elf32_Addr page_min = PAGE_START(header_.e_phoff);
    Elf32_Addr page_max = PAGE_END(header_.e_phoff + (phdr_num_ * sizeof(Elf32_Phdr)));
    Elf32_Addr page_offset = PAGE_OFFSET(header_.e_phoff);  

    phdr_size_ = page_max - page_min;

    void* mmap_result = mmap(NULL, phdr_size_, PROT_READ, MAP_PRIVATE, fd_, page_min);
        if (mmap_result == MAP_FAILED) {
        DL_ERR(&quot;\&quot;%s\&quot; phdr mmap failed: %s&quot;, name_, strerror(errno));
        return false;
    }

    phdr_mmap_ = mmap_result;
    phdr_table_ = reinterpret_cast&lt;Elf32_Phdr*&gt;(reinterpret_cast&lt;char*&gt;(mmap_result) + page_offset);
    return true;
}
</code></pre>

<ul>
<li><code>ReverveAddressSpace</code>()函数(准备虚拟内存足够的大来存放Program header中的<code>Load</code>段(两个Load段～～) 通过<code>mmap with PROT_NONE</code> 实现</li>
</ul>

<pre><code class="language-cpp">bool ElfReader::ReserveAddressSpace() {
    Elf32_Addr min_vaddr;
    load_size_ = phdr_table_get_load_size(phdr_table_, phdr_num_, &amp;min_vaddr);  // 获取so on 内存中需要的空间load_size
    if (load_size_ == 0) {
          DL_ERR(&quot;\&quot;%s\&quot; has no loadable segments&quot;, name_);
              return false;
    }

    uint8_t* addr = reinterpret_cast&lt;uint8_t*&gt;(min_vaddr);
    void* start = mmap(addr, load_size_, PROT_NONE, mmap_flags, -1, 0);         // use mmap匿名映射, 预留出相应的空间
    int mmap_flags = MAP_PRIVATE | MAP_ANONYMOUS;
    if (start == MAP_FAILED) {
        DL_ERR(&quot;couldn't reserve %d bytes of address space for \&quot;%s\&quot;&quot;, load_size_, name_);
        return false;
    }

    load_start_ = start;
    load_bias_ = reinterpret_cast&lt;uint8_t*&gt;(start) - addr;              // so可以指定加载的基址, 但是so指定的加载基址可能不是页对齐的, 这种情况
    return true;                                                            // 会导致实际映射地址和指定的加载地址有一个偏差, 这个偏差便是load_bias
}
</code></pre>

<ul>
<li><code>LoadSegments</code>()函数(在进程地址空间中加载所有可加载的段(假设你已经预留了空间为这个library)):</li>
</ul>

<pre><code class="language-cpp">bool ElfReader::LoadSegments() {    
    for (size_t i = 0; i &lt; phdr_num_; ++i) {
    const Elf32_Phdr* phdr = &amp;phdr_table_[i];   // 遍历program header table

    if (phdr-&gt;p_type != PT_LOAD) {          // 加载所有p_type == PT_LOAD的段
        continue;
    }

    ``` 之后就是一些设置段地址，段偏移, 之后mmap的一些操作

    return true;
}

</code></pre>

<ul>
<li><code>FindPhdr</code>()(返回program header table加载到内存中的地址, 因为之后还要执行.so的重定位).
现在回到我们<code>find_library_internal</code>()这里，在执行完load_library()之后, 还有一个重要的函数为 <code>soinfo_link_image</code>(soinfo* si):</li>
</ul>

<pre><code class="language-cpp">这个函数会完成.so的动态链接，其中包含我们加载的.so库的重定位过程:
 1. 定位动态section,将动态section的虚拟地址和项数和读写权限存在dynamic, dynamic_count, dynamic_flags中.
    size_t dynamic_count;
    Elf32_Word dynamic_flags;
    phdr_table_get_dynamic_section(phdr, phnum, base, &amp;si-&gt;dynamic,     // 定位dynamic section
                                       &amp;dynamic_count, &amp;dynamic_flags);     // 

 2. 解析Dynamic section
 3. 调用find_library, 返回所有依赖的.so的soinfo指针并存放在数组中.
 4. 重定位(处理plt_rel(延迟绑定)和rel):
    可以看到, 处理两个重定位表的函数都是soinfo_relocate函数.
    if (si-&gt;plt_rel != NULL) {
        DEBUG(&quot;[ relocating %s plt ]&quot;, si-&gt;name );
        if (soinfo_relocate(si, si-&gt;plt_rel, si-&gt;plt_rel_count, needed)) {
            return false;
        }
    }
    if (si-&gt;rel != NULL) {
        DEBUG(&quot;[ relocating %s ]&quot;, si-&gt;name );
        if (soinfo_relocate(si, si-&gt;rel, si-&gt;rel_count, needed)) {       
            return false;
        }
    }       
</code></pre>

<p>现在分析soinfo_relocate函数</p>

<pre><code class="language-cpp">







</code></pre>
    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">L0phTg</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">2019-04-03</span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content">原创文章，如需转载请注明文章作者和出处。谢谢！</span>
  </p>
</div>

    
    

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/">文件格式</a>
          
          <a href="/tags/android%E6%BA%90%E7%A0%81/">Android源码</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/thumb%E6%8C%87%E4%BB%A4%E8%99%9A%E6%8B%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B8%80/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">thumb指令虚拟化学习(一)</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        
          <a class="next" href="/post/%E5%88%86%E6%9E%90android%E7%9A%84jni%E7%BC%96%E7%A8%8B%E6%97%B6%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%E5%8A%9F%E8%83%BD/">
            <span class="next-text nav-default">分析Android的JNI编程时所使用的一些函数功能</span>
            <span class="prev-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
    

  

  

  
  </article>
        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="l0phtg:l0phtg@163.com" rel="me noopener" class="iconfont icon-email"
        title="email" target="_blank">
      </a>
      <a href="https://google.com" rel="me noopener" class="iconfont icon-google"
        title="google" target="_blank">
      </a>
      <a href="https://github.com/l0phtg" rel="me noopener" class="iconfont icon-github"
        title="github" target="_blank">
      </a>
  <a href="https://l0phtg.github.io/index.xml" rel="noopener" type="application/rss+xml" class="iconfont icon-rss"
    title="rss" target="_blank">
  </a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2018 -
    2019
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span><span class="author">l0phtg</span></span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>
<script type="text/javascript" src="/dist/jane.min.js?v=2.7.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML'></script>





<script src="/js/highlight.pack.js"></script>


<script>hljs.initHighlightingOnLoad();</script>

</body>
</html>
